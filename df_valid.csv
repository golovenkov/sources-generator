src,tgt
"/* { dg-do run } */
/* { dg-options ""-O2 -fipa-sra -fdump-tree-eipa_sra-details""  } */

struct bovid
{
  float red;
  int green;
  void *blue;
};

extern int printf (const char *, ...);
extern void abort (void);

static int
__attribute__((noinline))
ox (struct bovid cow)
{
  if (cow.green != 6)
    abort ();

  printf (""green: %f\nblue: %p\nblue again: %p\n"", cow.green,
	  cow.blue, cow.blue);
  return 0;
}

int
main (int argc, char *argv[])
{
  struct bovid cow;

  cow.red = 7.4;
  cow.green = 6;
  cow.blue = &cow;

  ox (cow);
  return 0;
}

/* { dg-final { scan-tree-dump-times ""About to replace expr"" 2 ""eipa_sra"" } } */
","/* { dg-do run } */
/* { dg-options ""-O2 -fipa-sra -fdump-tree-eipa_sra-details""  } */

struct bovid
{
  float red;
  int green;
  void *blue;
};

extern int printf (const char *, ...);
extern void abort (void);

static int
__attribute__((noinline))
ox (struct bovid cow)
{
  if (cow.green != 6)
    abort ();

  printf (""green: %f\nblue: %p\nblue again: %p\n"", cow.green,
	  cow.blue, cow.blue);
  return 0;
}

int
main (int argc, char *argv[])
{
  struct bovid cow;

  cow.red = 7.4;
  cow.green = 6;
  cow.blue = &cow;

  ox (cow);
  return 0;
}

/* { dg-final { scan-tree-dump-times ""About to replace expr"" 2 ""eipa_sra"" } } */
"
"/* { dg-do run } */
/* { dg-require-effective-target avx } */
/* { dg-options ""-O2 -mavx"" } */

#include ""avx-check.h""

#ifndef OFFSET
#define OFFSET 1
#endif

#if OFFSET < 0 || OFFSET > 1
#error OFFSET must be within [0..1]
#endif

void static
avx_test (void)
{
  union256d s1;
  union128d u;
  double e [2];

  s1.x = _mm256_set_pd (2134.3343,1234.635654,453.345635,54646.464356);
  u.x = _mm256_extractf128_pd (s1.x, OFFSET);

  __builtin_memcpy (e, s1.a + OFFSET * 2, sizeof e);

  if (check_union128d (u, e))
    abort ();
}
","/* { dg-do run } */
/* { dg-require-effective-target avx } */
/* { dg-options ""-O2 -mavx"" } */

#include ""avx-check.h""

#ifndef OFFSET
#define OFFSET 1
#endif

#if OFFSET < 0 || OFFSET > 1
#error OFFSET must be within [0..1]
#endif

void static
avx_test (void)
{
  union256d s1;
  union128d u;
  double e [2];

  s1.x = _mm256_set_pd (2134.3343,1234.635654,453.345635,54646.464356);
  u.x = _mm256_extractf128_pd (s1.x, OFFSET);

  __builtin_memcpy (e, s1.a + OFFSET * 2, sizeof e);

  if (check_union128d (u, e))
    abort ();
}
"
"/* { dg-do compile } */
/* { dg-require-effective-target arm_crypto_ok } */
/* { dg-add-options arm_crypto } */

#include ""arm_neon.h""

poly128_t
foo (poly128_t* ptr)
{
  return vldrq_p128 (ptr);
}

/* { dg-final { scan-assembler ""vld1.64\t{d\[0-9\]+-d\[0-9\]+}.*"" } } */
","/* { dg-do compile } */
/* { dg-require-effective-target arm_crypto_ok } */
/* { dg-add-options arm_crypto } */

#include ""arm_neon.h""

poly128_t
foo (poly128_t* ptr)
{
  return vldrq_p128 (ptr);
}

/* { dg-final { scan-assembler ""vld1.64\t{d\[0-9\]+-d\[0-9\]+}.*"" } } */
"
"/* { dg-lto-do assemble } */
/* { dg-lto-options {{-w -flto}} }  */
void Foo(void) { char bar[1]; free(bar); }
","/* { dg-lto-do assemble } */
/* { dg-lto-options {{-w -flto}} }  */
void Foo(void) { char bar[1]; free(bar); }
"
"/* A static function with a global alias should not get 'defined but
   not used' warnings.  Exposed by Linux kernel.  */
/* { dg-do compile } */
/* { dg-require-alias """" } */
/* { dg-options ""-Wall"" } */

extern void do_something (void);
extern void do_something_else (void);

static int
init_foobar(void)  /* { dg-bogus ""defined but not used"" ""not used warning"" } */
{
  do_something();
  do_something_else();
  return 0;
}

int init_module(void) __attribute__((alias(""init_foobar"")));
","/* A static function with a global alias should not get 'defined but
   not used' warnings.  Exposed by Linux kernel.  */
/* { dg-do compile } */
/* { dg-require-alias """" } */
/* { dg-options ""-Wall"" } */

extern void do_something (void);
extern void do_something_else (void);

static int
init_foobar(void)  /* { dg-bogus ""defined but not used"" ""not used warning"" } */
{
  do_something();
  do_something_else();
  return 0;
}

int init_module(void) __attribute__((alias(""init_foobar"")));
"
"/* { dg-do compile } */
/* { dg-require-effective-target arm_thumb1_ok } */
/* { dg-skip-if ""do not override -mcpu"" { *-*-* } { ""-mcpu=*"" ""-march=*"" } { ""-mcpu=cortex-m1.small-multiply"" } } */
/* { dg-options ""-mcpu=cortex-m1.small-multiply -mthumb -O2"" } */

int
test (int a)
{
  return a * 0x123456;
}

/* { dg-final { scan-assembler-not ""\[\\t \]+mul"" } } */
","/* { dg-do compile } */
/* { dg-require-effective-target arm_thumb1_ok } */
/* { dg-skip-if ""do not override -mcpu"" { *-*-* } { ""-mcpu=*"" ""-march=*"" } { ""-mcpu=cortex-m1.small-multiply"" } } */
/* { dg-options ""-mcpu=cortex-m1.small-multiply -mthumb -O2"" } */

int
test (int a)
{
  return a * 0x123456;
}

/* { dg-final { scan-assembler-not ""\[\\t \]+mul"" } } */
"
"/* { dg-do run } */
/* { dg-options ""-O2 -fdump-tree-optimized"" } */
/* Same test as 990128-1.c.  */

extern int printf (const char *,...);
extern void abort (void);

struct s { struct s *n; } *p;
struct s ss;
#define MAX     10
struct s sss[MAX];
int count = 0;

void sub( struct s *p, struct s **pp );
int look( struct s *p, struct s **pp );

int
main()
{
    struct s *pp;
    struct s *next;
    int i;

    p = &ss;
    next = p;
    for ( i = 0; i < MAX; i++ ) {
        next->n = &sss[i];
        next = next->n;
    }
    next->n = 0;

    sub( p, &pp );
    if (count != MAX+2)
      abort ();

    return( 0 );
}

void sub( struct s *p, struct s **pp )
{
   for ( ; look( p, pp ); ) {
        if ( p )
            p = p->n;
        else
            break;
   }
}

int look( struct s *p, struct s **pp )
{
    for ( ; p; p = p->n )
        ;
    *pp = p;
    count++;
    return( 1 );
}

/* { dg-final { scan-tree-dump ""Cleaned-up latch block of loop with single BB"" ""optimized"" { xfail { *-*-* } } } } */

","/* { dg-do run } */
/* { dg-options ""-O2 -fdump-tree-optimized"" } */
/* Same test as 990128-1.c.  */

extern int printf (const char *,...);
extern void abort (void);

struct s { struct s *n; } *p;
struct s ss;
#define MAX     10
struct s sss[MAX];
int count = 0;

void sub( struct s *p, struct s **pp );
int look( struct s *p, struct s **pp );

int
main()
{
    struct s *pp;
    struct s *next;
    int i;

    p = &ss;
    next = p;
    for ( i = 0; i < MAX; i++ ) {
        next->n = &sss[i];
        next = next->n;
    }
    next->n = 0;

    sub( p, &pp );
    if (count != MAX+2)
      abort ();

    return( 0 );
}

void sub( struct s *p, struct s **pp )
{
   for ( ; look( p, pp ); ) {
        if ( p )
            p = p->n;
        else
            break;
   }
}

int look( struct s *p, struct s **pp )
{
    for ( ; p; p = p->n )
        ;
    *pp = p;
    count++;
    return( 1 );
}

/* { dg-final { scan-tree-dump ""Cleaned-up latch block of loop with single BB"" ""optimized"" { xfail { *-*-* } } } } */

"
"/* { dg-do compile } */
/* { dg-options ""-fgnu-tm -O0 -fdump-tree-tmmark-lineno"" } */

/* Test that instrumented statements have correct location info.  */

int a,b, c, z;

void testing(){
    c=9;
}

int main() {
	b = 9898;
	__transaction_relaxed {
		z = c;
		a = 888;
		testing();
	}
	return 0;
}

/* { dg-final { scan-tree-dump-times "":13:.*b = 9898"" 1 ""tmmark"" } } */
/* { dg-final { scan-tree-dump-times "":14:.*_ITM_beginTransaction"" 1 ""tmmark"" } } */
/* { dg-final { scan-tree-dump-times "":15:.*ITM_WU. \\(&z"" 1 ""tmmark"" } } */
/* { dg-final { scan-tree-dump-times "":16:.*ITM_WU. \\(&a"" 1 ""tmmark"" } } */
","/* { dg-do compile } */
/* { dg-options ""-fgnu-tm -O0 -fdump-tree-tmmark-lineno"" } */

/* Test that instrumented statements have correct location info.  */

int a,b, c, z;

void testing(){
    c=9;
}

int main() {
	b = 9898;
	__transaction_relaxed {
		z = c;
		a = 888;
		testing();
	}
	return 0;
}

/* { dg-final { scan-tree-dump-times "":13:.*b = 9898"" 1 ""tmmark"" } } */
/* { dg-final { scan-tree-dump-times "":14:.*_ITM_beginTransaction"" 1 ""tmmark"" } } */
/* { dg-final { scan-tree-dump-times "":15:.*ITM_WU. \\(&z"" 1 ""tmmark"" } } */
/* { dg-final { scan-tree-dump-times "":16:.*ITM_WU. \\(&a"" 1 ""tmmark"" } } */
"
"void foo (int n, double a, double *b, double *x)
{
  int i, j;

  if(n <= 0) return;
  if (a == 0.0e0) return;

  if (a > 5.0)
    {
      i = 0;
      goto sec;
    }
  for (i = 0; i < 1024; i++)
    {
      double y = b[i];
sec:
      b[i+1] = y + 5.0;
      for (j = 0; j < n; j++)
	x[j] = x[j] + a;
    }
}
","void foo (int n, double a, double *b, double *x)
{
  int i, j;

  if(n <= 0) return;
  if (a == 0.0e0) return;

  if (a > 5.0)
    {
      i = 0;
      goto sec;
    }
  for (i = 0; i < 1024; i++)
    {
      double y = b[i];
sec:
      b[i+1] = y + 5.0;
      for (j = 0; j < n; j++)
	x[j] = x[j] + a;
    }
}
"
"/* PR 28875 */
/* { dg-do compile } */
/* { dg-options ""-O3 -Wextra -Wall"" } */
static int t(int i) /* { dg-warning ""unused parameter"" ""unused parameter warning"" } */
{
  return 0;
}
int tt()
{
  return t(0);
}
","/* PR 28875 */
/* { dg-do compile } */
/* { dg-options ""-O3 -Wextra -Wall"" } */
static int t(int i) /* { dg-warning ""unused parameter"" ""unused parameter warning"" } */
{
  return 0;
}
int tt()
{
  return t(0);
}
"
"/* { dg-do compile } */
/* { dg-options ""-std=c99 -O3 -mfma"" } */

extern double fma (double, double, double);
void fun() __attribute__((target(""fma"")));

void 
other_fun(double *restrict out, double * restrict a, double * restrict b, double * restrict c, int n)
{
    int i;
    for (i = 0; i < n; i++) {
        out[i] = fma(a[i], b[i], c[i]);
    }   
}

/* { dg-final { scan-assembler ""vfmadd"" } } */
","/* { dg-do compile } */
/* { dg-options ""-std=c99 -O3 -mfma"" } */

extern double fma (double, double, double);
void fun() __attribute__((target(""fma"")));

void 
other_fun(double *restrict out, double * restrict a, double * restrict b, double * restrict c, int n)
{
    int i;
    for (i = 0; i < n; i++) {
        out[i] = fma(a[i], b[i], c[i]);
    }   
}

/* { dg-final { scan-assembler ""vfmadd"" } } */
"
"
const double dnan = 1.0/0.0 - 1.0/0.0;
double x = 1.0;

extern void link_error (void);
extern void abort (void);

main ()
{
#if ! defined (__vax__) && ! defined (_CRAY)
  /* NaN is an IEEE unordered operand.  All these test should be false.  */
  if (dnan == dnan)
    link_error ();
  if (dnan != x)
    x = 1.0;
  else
    link_error ();

  if (dnan < x)
    link_error ();
  if (dnan > x)
    link_error ();
  if (dnan <= x)
    link_error ();
  if (dnan >= x)
    link_error ();
  if (dnan == x)
    link_error ();
#endif
  exit (0);
}

#ifndef __OPTIMIZE__
void link_error (void)
{
  abort ();
}
#endif

","
const double dnan = 1.0/0.0 - 1.0/0.0;
double x = 1.0;

extern void link_error (void);
extern void abort (void);

main ()
{
#if ! defined (__vax__) && ! defined (_CRAY)
  /* NaN is an IEEE unordered operand.  All these test should be false.  */
  if (dnan == dnan)
    link_error ();
  if (dnan != x)
    x = 1.0;
  else
    link_error ();

  if (dnan < x)
    link_error ();
  if (dnan > x)
    link_error ();
  if (dnan <= x)
    link_error ();
  if (dnan >= x)
    link_error ();
  if (dnan == x)
    link_error ();
#endif
  exit (0);
}

#ifndef __OPTIMIZE__
void link_error (void)
{
  abort ();
}
#endif

"
"/* PR middle-end/38981 */
/* Reporter: Kamaraju Kusumanchi <kamaraju@gmail.com> */

struct d_info
{
  int **subs;
};

static int *
d_substitution (struct d_info *di, int prefix)
{
  char c;

	c='_';

  if (c == '_')
    {
      unsigned int id;

      if (c != '_')
	{
	  do
	    {
	      unsigned int new_id;

	      if (new_id < id)
		return 0;
	      id = new_id;
	    }
	  while (c != '_');
	}



      return di->subs[id];
    }
  else
    {
      int verbose;
      int code;
      int simple_len;

	code=0;
	simple_len=0;
	verbose=0;
      if (! code && prefix)
	{
	  char peek;
		peek='A';

	  if (peek == 'C' || peek == 'D')
	    verbose = 1;
	}

	      if (verbose)
		{
		  code = simple_len;
		}

    }
}
","/* PR middle-end/38981 */
/* Reporter: Kamaraju Kusumanchi <kamaraju@gmail.com> */

struct d_info
{
  int **subs;
};

static int *
d_substitution (struct d_info *di, int prefix)
{
  char c;

	c='_';

  if (c == '_')
    {
      unsigned int id;

      if (c != '_')
	{
	  do
	    {
	      unsigned int new_id;

	      if (new_id < id)
		return 0;
	      id = new_id;
	    }
	  while (c != '_');
	}



      return di->subs[id];
    }
  else
    {
      int verbose;
      int code;
      int simple_len;

	code=0;
	simple_len=0;
	verbose=0;
      if (! code && prefix)
	{
	  char peek;
		peek='A';

	  if (peek == 'C' || peek == 'D')
	    verbose = 1;
	}

	      if (verbose)
		{
		  code = simple_len;
		}

    }
}
"
"/* PR target/53759 */
/* { dg-do compile } */
/* { dg-options ""-O2 -mavx"" } */

#include <xmmintrin.h>

void
foo (__m128 *x, __m64 *y)
{
  __m128 a = _mm_setzero_ps ();
  __m128 b = _mm_loadl_pi (a, y);
  *x = _mm_add_ps (b, b);
}

/* { dg-final { scan-assembler ""vmovlps\[ \\t\]"" } } */
/* { dg-final { scan-assembler-not ""vshufps\[ \\t\]"" } } */
","/* PR target/53759 */
/* { dg-do compile } */
/* { dg-options ""-O2 -mavx"" } */

#include <xmmintrin.h>

void
foo (__m128 *x, __m64 *y)
{
  __m128 a = _mm_setzero_ps ();
  __m128 b = _mm_loadl_pi (a, y);
  *x = _mm_add_ps (b, b);
}

/* { dg-final { scan-assembler ""vmovlps\[ \\t\]"" } } */
/* { dg-final { scan-assembler-not ""vshufps\[ \\t\]"" } } */
"
"/* { dg-do compile } */ 
/* { dg-options ""-O2 -fdump-tree-pre-stats"" } */
double cos (double) __attribute__ ((const));
double sin (double) __attribute__ ((const));
double f(double a)
{
  double b;
  double c,d;
  double (*fp) (double) __attribute__ ((const));
  /* Partially redundant call */
  if (a < 2.0)
    {
      fp = sin;
      c = fp (a);
    }
  else
    {
      c = 1.0; 
      fp = cos;
    }
  d = fp (a);
  return d + c;
}

/* { dg-final { scan-tree-dump-times ""Eliminated: 1"" 1 ""pre""} } */
","/* { dg-do compile } */ 
/* { dg-options ""-O2 -fdump-tree-pre-stats"" } */
double cos (double) __attribute__ ((const));
double sin (double) __attribute__ ((const));
double f(double a)
{
  double b;
  double c,d;
  double (*fp) (double) __attribute__ ((const));
  /* Partially redundant call */
  if (a < 2.0)
    {
      fp = sin;
      c = fp (a);
    }
  else
    {
      c = 1.0; 
      fp = cos;
    }
  d = fp (a);
  return d + c;
}

/* { dg-final { scan-tree-dump-times ""Eliminated: 1"" 1 ""pre""} } */
"
"/* { dg-do compile { target { powerpc*-*-* } } } */
/* { dg-skip-if ""do not override -mcpu"" { powerpc*-*-* } { ""-mcpu=*"" } { ""-mcpu=power9"" } } */
/* { dg-require-effective-target powerpc_p9vector_ok } */
/* { dg-skip-if """" { powerpc*-*-aix* } } */
/* { dg-options ""-mcpu=power9"" } */

/* This test should succeed on both 32- and 64-bit configurations.  */
#include <altivec.h>

int doTestBCDSignificance (_Decimal64 *p)
{
  _Decimal64 source = *p;

  return __builtin_dfp_dtstsfi_ov (5, source);
}

/* { dg-final { scan-assembler	   ""dtstsfi"" } } */
","/* { dg-do compile { target { powerpc*-*-* } } } */
/* { dg-skip-if ""do not override -mcpu"" { powerpc*-*-* } { ""-mcpu=*"" } { ""-mcpu=power9"" } } */
/* { dg-require-effective-target powerpc_p9vector_ok } */
/* { dg-skip-if """" { powerpc*-*-aix* } } */
/* { dg-options ""-mcpu=power9"" } */

/* This test should succeed on both 32- and 64-bit configurations.  */
#include <altivec.h>

int doTestBCDSignificance (_Decimal64 *p)
{
  _Decimal64 source = *p;

  return __builtin_dfp_dtstsfi_ov (5, source);
}

/* { dg-final { scan-assembler	   ""dtstsfi"" } } */
"
"#include <arm_neon.h>

/* { dg-do compile } */
/* { dg-skip-if """" { *-*-* } { ""-fno-fat-lto-objects"" } } */
/* { dg-skip-if """" { arm*-*-* } } */

float64x1_t
f_vmulx_laneq_f64 (float64x1_t v1, float64x2_t v2)
{
  float64x1_t res;
  /* { dg-error ""lane -1 out of range 0 - 1"" """" {target *-*-*} 0 } */
  res = vmulx_laneq_f64 (v1, v2, -1);
  /* { dg-error ""lane 2 out of range 0 - 1"" """" {target *-*-*} 0 } */
  res = vmulx_laneq_f64 (v1, v2, 2);
  return res;
}
","#include <arm_neon.h>

/* { dg-do compile } */
/* { dg-skip-if """" { *-*-* } { ""-fno-fat-lto-objects"" } } */
/* { dg-skip-if """" { arm*-*-* } } */

float64x1_t
f_vmulx_laneq_f64 (float64x1_t v1, float64x2_t v2)
{
  float64x1_t res;
  /* { dg-error ""lane -1 out of range 0 - 1"" """" {target *-*-*} 0 } */
  res = vmulx_laneq_f64 (v1, v2, -1);
  /* { dg-error ""lane 2 out of range 0 - 1"" """" {target *-*-*} 0 } */
  res = vmulx_laneq_f64 (v1, v2, 2);
  return res;
}
"
"#include <stdlib.h>
/* interopse with myftype_1 */
typedef struct {
   signed char chr;
   signed char chr2;
} myctype_t;


extern void abort(void);
void types_test(void);
/* declared in the fortran module */
extern myctype_t myVar;

int main(int argc, char **argv)
{
   myctype_t *cchr;
   asm("""":""=r""(cchr):""0""(&myVar));
   cchr->chr = 1;
   cchr->chr2 = 2;

   types_test();

   if(cchr->chr != 2)
      abort();
   if(cchr->chr2 != 2)
      abort();
   myVar.chr2 = 3;
   types_test();

   if(myVar.chr != 3)
      abort();
   if(myVar.chr2 != 3)
      abort();
   return 0;
}

","#include <stdlib.h>
/* interopse with myftype_1 */
typedef struct {
   signed char chr;
   signed char chr2;
} myctype_t;


extern void abort(void);
void types_test(void);
/* declared in the fortran module */
extern myctype_t myVar;

int main(int argc, char **argv)
{
   myctype_t *cchr;
   asm("""":""=r""(cchr):""0""(&myVar));
   cchr->chr = 1;
   cchr->chr2 = 2;

   types_test();

   if(cchr->chr != 2)
      abort();
   if(cchr->chr2 != 2)
      abort();
   myVar.chr2 = 3;
   types_test();

   if(myVar.chr != 3)
      abort();
   if(myVar.chr2 != 3)
      abort();
   return 0;
}

"
"/* { dg-do compile } */

int a, b, c, d, e;
char f, g;

void fn1 ()
{
  while (1)
    {
      if (d)
	goto L1;
      if (e)
	goto L3;
      int q = (c && a) % (f * (d || a)) && b;
      e = q;
      if (b)
	break;
L1:
L2:
      c = f;
L3:
      f = g;
      while (a)
	goto L2;
    }
}
","/* { dg-do compile } */

int a, b, c, d, e;
char f, g;

void fn1 ()
{
  while (1)
    {
      if (d)
	goto L1;
      if (e)
	goto L3;
      int q = (c && a) % (f * (d || a)) && b;
      e = q;
      if (b)
	break;
L1:
L2:
      c = f;
L3:
      f = g;
      while (a)
	goto L2;
    }
}
"
"void *g, *c;
int a, b;

int f()
{
  if ((0 == a) != (b || g == c))
    return 1;
  return 0;
}

","void *g, *c;
int a, b;

int f()
{
  if ((0 == a) != (b || g == c))
    return 1;
  return 0;
}

"
"/* { dg-do compile } */
/* { dg-options ""-mavx2 -O2"" } */
/* { dg-final { scan-assembler ""vmovntdqa\[ \\t\]+\[^\n\]*%ymm\[0-9\]"" } } */

#include <immintrin.h>

volatile __m256i x;
__m256i *y;

void extern
avx2_test (void)
{
  x = _mm256_stream_load_si256 (y);
}
","/* { dg-do compile } */
/* { dg-options ""-mavx2 -O2"" } */
/* { dg-final { scan-assembler ""vmovntdqa\[ \\t\]+\[^\n\]*%ymm\[0-9\]"" } } */

#include <immintrin.h>

volatile __m256i x;
__m256i *y;

void extern
avx2_test (void)
{
  x = _mm256_stream_load_si256 (y);
}
"
"#include <arm_neon.h>

/* { dg-do compile } */
/* { dg-skip-if """" { *-*-* } { ""-fno-fat-lto-objects"" } } */

void
f_vst2_lane_u16 (uint16_t * p, uint16x4x2_t v)
{
  /* { dg-error ""lane 4 out of range 0 - 3"" """" { target *-*-* } 0 } */
  vst2_lane_u16 (p, v, 4);
  /* { dg-error ""lane -1 out of range 0 - 3"" """" { target *-*-* } 0 } */
  vst2_lane_u16 (p, v, -1);
  return;
}
","#include <arm_neon.h>

/* { dg-do compile } */
/* { dg-skip-if """" { *-*-* } { ""-fno-fat-lto-objects"" } } */

void
f_vst2_lane_u16 (uint16_t * p, uint16x4x2_t v)
{
  /* { dg-error ""lane 4 out of range 0 - 3"" """" { target *-*-* } 0 } */
  vst2_lane_u16 (p, v, 4);
  /* { dg-error ""lane -1 out of range 0 - 3"" """" { target *-*-* } 0 } */
  vst2_lane_u16 (p, v, -1);
  return;
}
"
"/* { dg-options ""-O -fgraphite-identity -fno-tree-scev-cprop"" } */

int foo (void);

int
huft_build (unsigned *b)
{
  int k;
  for (k = 0; k <= 10; k++)
    if (foo ());
}
int
inflate_fixed ()
{
  int i;
  unsigned l[288];
  for (i = 0; i < 144; i++)
    l[i] = 8;
  for (; i < 256; i++)
    l[i] = 9;
  for (; i < 280; i++)
    l[i] = 7;
  for (; i < 288; i++)
    l[i] = 8;
  if ((i = huft_build (l)) != 0)
    return i;
  for (i = 0; i < 30; i++)
    l[i] = 5;
}
","/* { dg-options ""-O -fgraphite-identity -fno-tree-scev-cprop"" } */

int foo (void);

int
huft_build (unsigned *b)
{
  int k;
  for (k = 0; k <= 10; k++)
    if (foo ());
}
int
inflate_fixed ()
{
  int i;
  unsigned l[288];
  for (i = 0; i < 144; i++)
    l[i] = 8;
  for (; i < 256; i++)
    l[i] = 9;
  for (; i < 280; i++)
    l[i] = 7;
  for (; i < 288; i++)
    l[i] = 8;
  if ((i = huft_build (l)) != 0)
    return i;
  for (i = 0; i < 30; i++)
    l[i] = 5;
}
"
"/* { dg-do run } */
/* { dg-options ""-O3 -mpower8-vector"" } */
/* { dg-require-effective-target lp64 } */
/* { dg-require-effective-target p8vector_hw } */

#define NO_WARN_X86_INTRINSICS 1

#ifndef CHECK_H
#define CHECK_H ""sse-check.h""
#endif

#include CHECK_H

#ifndef TEST
#define TEST sse_test_movhps_2
#endif

#include <xmmintrin.h>

static void
__attribute__((noinline, unused))
test (__m64 *p, __m128 a)
{
  __asm("""" : ""+v""(a));
  return _mm_storeh_pi (p, a); 
}

static void
TEST (void)
{
  union128 s1;
  float e[2];
  float d[2];

  s1.x = _mm_set_ps (5.13, 6.12, 7.11, 8.9);
 
  test ((__m64 *)d, s1.x);

  e[0] = s1.a[2];
  e[1] = s1.a[3];

  if (checkVf (d, e, 2))
    abort ();
}
","/* { dg-do run } */
/* { dg-options ""-O3 -mpower8-vector"" } */
/* { dg-require-effective-target lp64 } */
/* { dg-require-effective-target p8vector_hw } */

#define NO_WARN_X86_INTRINSICS 1

#ifndef CHECK_H
#define CHECK_H ""sse-check.h""
#endif

#include CHECK_H

#ifndef TEST
#define TEST sse_test_movhps_2
#endif

#include <xmmintrin.h>

static void
__attribute__((noinline, unused))
test (__m64 *p, __m128 a)
{
  __asm("""" : ""+v""(a));
  return _mm_storeh_pi (p, a); 
}

static void
TEST (void)
{
  union128 s1;
  float e[2];
  float d[2];

  s1.x = _mm_set_ps (5.13, 6.12, 7.11, 8.9);
 
  test ((__m64 *)d, s1.x);

  e[0] = s1.a[2];
  e[1] = s1.a[3];

  if (checkVf (d, e, 2))
    abort ();
}
"
"/* Test for warnings for missing format attributes.  Don't warn if no
   relevant parameters for a format attribute; see c/1017.  */
/* Origin: Joseph Myers <jsm28@cam.ac.uk> */
/* { dg-do compile { target { *-*-mingw* } } } */
/* { dg-options ""-std=gnu99 -Wmissing-format-attribute"" } */

#define USE_SYSTEM_FORMATS
#include ""format.h""

void
foo (int i, ...)
{
  va_list ap;
  va_start (ap, i);
  vprintf (""Foo %s bar %s"", ap); /* { dg-bogus ""candidate"" ""bogus printf attribute warning"" } */
  va_end (ap);
}
","/* Test for warnings for missing format attributes.  Don't warn if no
   relevant parameters for a format attribute; see c/1017.  */
/* Origin: Joseph Myers <jsm28@cam.ac.uk> */
/* { dg-do compile { target { *-*-mingw* } } } */
/* { dg-options ""-std=gnu99 -Wmissing-format-attribute"" } */

#define USE_SYSTEM_FORMATS
#include ""format.h""

void
foo (int i, ...)
{
  va_list ap;
  va_start (ap, i);
  vprintf (""Foo %s bar %s"", ap); /* { dg-bogus ""candidate"" ""bogus printf attribute warning"" } */
  va_end (ap);
}
"
"/* { dg-do compile } */
/* { dg-options ""-O0 -mavx512bw"" } */
/* { dg-final { scan-assembler-times ""ktestq\[ \\t\]+\[^\{\n\]*%k\[0-7\](?:\n|\[ \\t\]+#)"" 2 } } */

#include <immintrin.h>

void
avx512bw_test () {
  volatile __mmask64 k1;
  __mmask64 k2;

  volatile unsigned char r __attribute__((unused));	

  r = _ktestc_mask64_u8(k1, k2);
  r = _ktestz_mask64_u8(k1, k2);
}
","/* { dg-do compile } */
/* { dg-options ""-O0 -mavx512bw"" } */
/* { dg-final { scan-assembler-times ""ktestq\[ \\t\]+\[^\{\n\]*%k\[0-7\](?:\n|\[ \\t\]+#)"" 2 } } */

#include <immintrin.h>

void
avx512bw_test () {
  volatile __mmask64 k1;
  __mmask64 k2;

  volatile unsigned char r __attribute__((unused));	

  r = _ktestc_mask64_u8(k1, k2);
  r = _ktestz_mask64_u8(k1, k2);
}
"
"/* { dg-lto-do link } */
/* { dg-require-effective-target fpic } */
/* { dg-lto-options {{-fPIC -r -nostdlib -O2 -flto}} } */
/* { dg-extra-ld-options ""-flinker-output=nolto-rel"" } */

typedef struct VEC_constructor_elt_gc { } VEC_constructor_elt_gc;
#include ""20091016-1_a.h""
struct stmt_tree_s {
    tree x_cur_stmt_list;
};
void *add_stmt (struct stmt_tree_s *x)
{
  return &x->x_cur_stmt_list;
}

","/* { dg-lto-do link } */
/* { dg-require-effective-target fpic } */
/* { dg-lto-options {{-fPIC -r -nostdlib -O2 -flto}} } */
/* { dg-extra-ld-options ""-flinker-output=nolto-rel"" } */

typedef struct VEC_constructor_elt_gc { } VEC_constructor_elt_gc;
#include ""20091016-1_a.h""
struct stmt_tree_s {
    tree x_cur_stmt_list;
};
void *add_stmt (struct stmt_tree_s *x)
{
  return &x->x_cur_stmt_list;
}

"
"/* Test for -mcpu=.  */
/* { dg-do preprocess } */
/* { dg-bfin-options ""-mcpu=bf592"" } */

#ifndef __ADSPBF592__
#error ""__ADSPBF592__ is not defined""
#endif

#ifndef __ADSPBF59x__
#error ""__ADSPBF59x__ is not defined""
#endif

#if __SILICON_REVISION__ != 0x0001
#error ""__SILICON_REVISION__ is not 0x0001""
#endif

#ifndef __WORKAROUNDS_ENABLED
#error ""__WORKAROUNDS_ENABLED is not defined""
#endif

#ifdef __WORKAROUND_RETS
#error ""__WORKAROUND_RETS is defined""
#endif

#ifndef __WORKAROUND_SPECULATIVE_LOADS
#error ""__WORKAROUND_SPECULATIVE_LOADS is not defined""
#endif

#ifdef __WORKAROUND_SPECULATIVE_SYNCS
#error ""__WORKAROUND_SPECULATIVE_SYNCS is defined""
#endif
","/* Test for -mcpu=.  */
/* { dg-do preprocess } */
/* { dg-bfin-options ""-mcpu=bf592"" } */

#ifndef __ADSPBF592__
#error ""__ADSPBF592__ is not defined""
#endif

#ifndef __ADSPBF59x__
#error ""__ADSPBF59x__ is not defined""
#endif

#if __SILICON_REVISION__ != 0x0001
#error ""__SILICON_REVISION__ is not 0x0001""
#endif

#ifndef __WORKAROUNDS_ENABLED
#error ""__WORKAROUNDS_ENABLED is not defined""
#endif

#ifdef __WORKAROUND_RETS
#error ""__WORKAROUND_RETS is defined""
#endif

#ifndef __WORKAROUND_SPECULATIVE_LOADS
#error ""__WORKAROUND_SPECULATIVE_LOADS is not defined""
#endif

#ifdef __WORKAROUND_SPECULATIVE_SYNCS
#error ""__WORKAROUND_SPECULATIVE_SYNCS is defined""
#endif
"
"/* { dg-skip-if """" { powerpc*-*-darwin* } } */
/* { dg-require-effective-target powerpc_vsx_ok } */
/* { dg-options ""-maltivec -mabi=altivec -std=gnu99 -mvsx"" } */

#include ""harness.h""

static int vec_long_long_eq (vector long long x, vector long long y)
{
  return (x[0] == y[0] && x[1] == y[1]);
}

static int vec_dbl_eq (vector double x, vector double y)
{
  return (x[0] == y[0] && x[1] == y[1]);
}

static void test()
{
  vector long long vl = {0, 1};
  vector double vd = {0.0, 1.0};
  vector long long vlr = vec_insert (2, vl, 0);
  vector double vdr = vec_insert (2.0, vd, 1);
  vector long long vler = {2, 1};
  vector double vder = {0.0, 2.0};

  check (vec_long_long_eq (vlr, vler), ""vl"");
  check (vec_dbl_eq (vdr, vder), ""vd"");
}
","/* { dg-skip-if """" { powerpc*-*-darwin* } } */
/* { dg-require-effective-target powerpc_vsx_ok } */
/* { dg-options ""-maltivec -mabi=altivec -std=gnu99 -mvsx"" } */

#include ""harness.h""

static int vec_long_long_eq (vector long long x, vector long long y)
{
  return (x[0] == y[0] && x[1] == y[1]);
}

static int vec_dbl_eq (vector double x, vector double y)
{
  return (x[0] == y[0] && x[1] == y[1]);
}

static void test()
{
  vector long long vl = {0, 1};
  vector double vd = {0.0, 1.0};
  vector long long vlr = vec_insert (2, vl, 0);
  vector double vdr = vec_insert (2.0, vd, 1);
  vector long long vler = {2, 1};
  vector double vder = {0.0, 2.0};

  check (vec_long_long_eq (vlr, vler), ""vl"");
  check (vec_dbl_eq (vdr, vder), ""vd"");
}
"
"/* { dg-do compile { target { ! ia32 } } } */
/* { dg-options ""-O2 -dp"" } */
/* { dg-final { scan-assembler-not ""zero_extendsidi"" } } */

unsigned long long foo (int a, unsigned int b, unsigned int c)
{
  return a ? b : c;
}
","/* { dg-do compile { target { ! ia32 } } } */
/* { dg-options ""-O2 -dp"" } */
/* { dg-final { scan-assembler-not ""zero_extendsidi"" } } */

unsigned long long foo (int a, unsigned int b, unsigned int c)
{
  return a ? b : c;
}
"
"/* PR tree-optimization/82374 */
/* { dg-do compile } */
/* { dg-options ""-O2 -fno-tree-vectorize -fdump-tree-vect-details"" } */
/* { dg-additional-options ""-mavx -mno-avx2"" { target i?86-*-* x86_64-*-* } } */
/* { dg-additional-options ""-mvsx"" { target powerpc_vsx_ok } } */

#define SIZE (1024 * 1024)

float a[SIZE];
float b[SIZE];
float c[SIZE];
float d[SIZE];

__attribute__((optimize (""O2"", ""tree-vectorize""))) void
foo (void)
{
  int i;
#pragma omp parallel for
  for (i = 0; i < SIZE; i++)
    c[i] = a[i] + b[i];
}

__attribute__((optimize (""O2"", ""tree-vectorize""))) void
bar (void)
{
  int i;
  for (i = 0; i < SIZE; i++)
    d[i] = a[i] + b[i];
}

/* { dg-final { scan-tree-dump-times ""vectorized 1 loops"" 2 ""vect"" { target { { i?86-*-* x86_64-*-* } || { powerpc_vsx_ok } } } } } */
","/* PR tree-optimization/82374 */
/* { dg-do compile } */
/* { dg-options ""-O2 -fno-tree-vectorize -fdump-tree-vect-details"" } */
/* { dg-additional-options ""-mavx -mno-avx2"" { target i?86-*-* x86_64-*-* } } */
/* { dg-additional-options ""-mvsx"" { target powerpc_vsx_ok } } */

#define SIZE (1024 * 1024)

float a[SIZE];
float b[SIZE];
float c[SIZE];
float d[SIZE];

__attribute__((optimize (""O2"", ""tree-vectorize""))) void
foo (void)
{
  int i;
#pragma omp parallel for
  for (i = 0; i < SIZE; i++)
    c[i] = a[i] + b[i];
}

__attribute__((optimize (""O2"", ""tree-vectorize""))) void
bar (void)
{
  int i;
  for (i = 0; i < SIZE; i++)
    d[i] = a[i] + b[i];
}

/* { dg-final { scan-tree-dump-times ""vectorized 1 loops"" 2 ""vect"" { target { { i?86-*-* x86_64-*-* } || { powerpc_vsx_ok } } } } } */
"
"/* { dg-do compile } */
/* { dg-require-effective-target vect_int } */

int
foo (int integral, int decimal, int power_ten)
{
  while (power_ten > 0)
    {
      integral *= 10;
      decimal *= 10;
      power_ten--;
    }

  return integral+decimal;
}


","/* { dg-do compile } */
/* { dg-require-effective-target vect_int } */

int
foo (int integral, int decimal, int power_ten)
{
  while (power_ten > 0)
    {
      integral *= 10;
      decimal *= 10;
      power_ten--;
    }

  return integral+decimal;
}


"
"/* { dg-do compile } */
/* { dg-options ""-Wparentheses"" } */

void bar (int);
void
foo (int a, int b)
{
  if (a) /* { dg-warning ""suggest explicit braces to avoid ambiguous"" } */
    if (b)
      bar (1);
  else
    bar (2);
}
","/* { dg-do compile } */
/* { dg-options ""-Wparentheses"" } */

void bar (int);
void
foo (int a, int b)
{
  if (a) /* { dg-warning ""suggest explicit braces to avoid ambiguous"" } */
    if (b)
      bar (1);
  else
    bar (2);
}
"
"/* { dg-do compile { target { ! { { logical_op_short_circuit && { ! avr-*-* } } || { m68k*-*-* mmix*-*-* bfin*-*-* v850*-*-* moxie*-*-* cris*-*-* m32c*-*-* fr30*-*-* mcore*-*-* powerpc*-*-* xtensa*-*-* arc*-*-* mips*-*-* } } } } } */

/* { dg-options ""-O2 -g -fdump-tree-optimized"" } */
/* { dg-additional-options ""-mbranch-cost=2"" { target branch_cost } } */

int t (int a, int b)
{
  if (a > 0)
    goto L1;
  else
    goto L2;
L1:
  if (b > 0)
    goto L2;
  return 5;
L2:
  return 6;
}
/* { dg-final { scan-tree-dump ""\|"" ""optimized"" } } */
","/* { dg-do compile { target { ! { { logical_op_short_circuit && { ! avr-*-* } } || { m68k*-*-* mmix*-*-* bfin*-*-* v850*-*-* moxie*-*-* cris*-*-* m32c*-*-* fr30*-*-* mcore*-*-* powerpc*-*-* xtensa*-*-* arc*-*-* mips*-*-* } } } } } */

/* { dg-options ""-O2 -g -fdump-tree-optimized"" } */
/* { dg-additional-options ""-mbranch-cost=2"" { target branch_cost } } */

int t (int a, int b)
{
  if (a > 0)
    goto L1;
  else
    goto L2;
L1:
  if (b > 0)
    goto L2;
  return 5;
L2:
  return 6;
}
/* { dg-final { scan-tree-dump ""\|"" ""optimized"" } } */
"
"/* { dg-do run } */
/* { dg-options ""-O2 -mavx512vl"" } */
/* { dg-require-effective-target avx512vl } */

#define AVX512VL
#define AVX512F_LEN 256
#define AVX512F_LEN_HALF 128
#include ""avx512f-vpexpandq-2.c""

#undef AVX512F_LEN
#undef AVX512F_LEN_HALF

#define AVX512F_LEN 128
#define AVX512F_LEN_HALF 128
#include ""avx512f-vpexpandq-2.c""
","/* { dg-do run } */
/* { dg-options ""-O2 -mavx512vl"" } */
/* { dg-require-effective-target avx512vl } */

#define AVX512VL
#define AVX512F_LEN 256
#define AVX512F_LEN_HALF 128
#include ""avx512f-vpexpandq-2.c""

#undef AVX512F_LEN
#undef AVX512F_LEN_HALF

#define AVX512F_LEN 128
#define AVX512F_LEN_HALF 128
#include ""avx512f-vpexpandq-2.c""
"
"extern void abort(void);
extern void exit(int);
void foo(int) __attribute__((noinline));
void bar(void) __attribute__((noinline));

/* Make sure foo is not inlined or considered pure/const.  */
int x;
void foo(int i) { x = i; }
void bar(void) { exit(0); }

int
main(int argc, char *argv[])
{
	int i;
	int numbers[4] = { 0xdead, 0xbeef, 0x1337, 0x4242 };

	for (i = 1; i <= 12; i++) {
		if (i <= 4)
			foo(numbers[i-1]);
		else if (i >= 7 && i <= 9)
			bar();
	}

	abort();
}

","extern void abort(void);
extern void exit(int);
void foo(int) __attribute__((noinline));
void bar(void) __attribute__((noinline));

/* Make sure foo is not inlined or considered pure/const.  */
int x;
void foo(int i) { x = i; }
void bar(void) { exit(0); }

int
main(int argc, char *argv[])
{
	int i;
	int numbers[4] = { 0xdead, 0xbeef, 0x1337, 0x4242 };

	for (i = 1; i <= 12; i++) {
		if (i <= 4)
			foo(numbers[i-1]);
		else if (i >= 7 && i <= 9)
			bar();
	}

	abort();
}

"
"/* Same test as built-in-setjmp.c.  Includes the case where
   the source block of a crossing fallthru edge ends with a call.  */
/* { dg-require-effective-target freorder } */
/* { dg-options ""-O2 -freorder-blocks-and-partition"" } */

extern int strcmp(const char *, const char *);
extern char *strcpy(char *, const char *);
extern void abort(void);
extern void exit(int);

void *buf[20];

void __attribute__((noinline))
sub2 (void)
{
  __builtin_longjmp (buf, 1);
}

int
main ()
{
  char *p = (char *) __builtin_alloca (20);

  strcpy (p, ""test"");

  if (__builtin_setjmp (buf))
    {
      if (strcmp (p, ""test"") != 0)
	abort ();

      exit (0);
    }

  {
    int *q = (int *) __builtin_alloca (p[2] * sizeof (int));
    int i;
    
    for (i = 0; i < p[2]; i++)
      q[i] = 0;

    while (1)
      sub2 ();
  }
}

","/* Same test as built-in-setjmp.c.  Includes the case where
   the source block of a crossing fallthru edge ends with a call.  */
/* { dg-require-effective-target freorder } */
/* { dg-options ""-O2 -freorder-blocks-and-partition"" } */

extern int strcmp(const char *, const char *);
extern char *strcpy(char *, const char *);
extern void abort(void);
extern void exit(int);

void *buf[20];

void __attribute__((noinline))
sub2 (void)
{
  __builtin_longjmp (buf, 1);
}

int
main ()
{
  char *p = (char *) __builtin_alloca (20);

  strcpy (p, ""test"");

  if (__builtin_setjmp (buf))
    {
      if (strcmp (p, ""test"") != 0)
	abort ();

      exit (0);
    }

  {
    int *q = (int *) __builtin_alloca (p[2] * sizeof (int));
    int i;
    
    for (i = 0; i < p[2]; i++)
      q[i] = 0;

    while (1)
      sub2 ();
  }
}

"
"/* { dg-do compile } */

extern __inline
int
getline ()
{
}
","/* { dg-do compile } */

extern __inline
int
getline ()
{
}
"
"/* { dg-options ""-O2"" } */
/* { dg-additional-sources pr64291-2.c } */
/* { dg-do run { target lp64 } } */
void f(void*,...);
void g(void*,long,long);
int nnn=0;
long test=0;

typedef struct
{
  int _mp_size;
  unsigned long *_mp_d;
} __mpz_struct;
typedef __mpz_struct mpz_t[1];
void h(mpz_t);

int main ()
{
  mpz_t n, d;
  long nn, dn;
  unsigned long *np, *dup, *dnp, *qp;
  long alloc, itch;

  f (n);
  h (d);
  qp = (unsigned long*)__builtin_alloca(4099*8) + 1;
  dnp = (unsigned long*)__builtin_alloca (2049*8);
  alloc = 1;
  for (test = 0; test < 1; test++)
    {
      dn = d->_mp_size;
      dup = d->_mp_d;
      f (dnp, dup, dn);
      dnp[dn - 1] |= 1UL<<63;
      f (0);
      nn = nnn;
      np = n->_mp_d;
      qp[-1] = -757136820;
      qp[nn - dn + 1] = 14883681;
      f (0);
      if (dn >= 6)
	f (0);
      itch = nn + 1;
      if (itch + 1> alloc)
	{
	  g(0,alloc*8,(itch+1)*8);
	  alloc = itch + 1;
	}
      f (np, nn);
    }
  return 0;
}
","/* { dg-options ""-O2"" } */
/* { dg-additional-sources pr64291-2.c } */
/* { dg-do run { target lp64 } } */
void f(void*,...);
void g(void*,long,long);
int nnn=0;
long test=0;

typedef struct
{
  int _mp_size;
  unsigned long *_mp_d;
} __mpz_struct;
typedef __mpz_struct mpz_t[1];
void h(mpz_t);

int main ()
{
  mpz_t n, d;
  long nn, dn;
  unsigned long *np, *dup, *dnp, *qp;
  long alloc, itch;

  f (n);
  h (d);
  qp = (unsigned long*)__builtin_alloca(4099*8) + 1;
  dnp = (unsigned long*)__builtin_alloca (2049*8);
  alloc = 1;
  for (test = 0; test < 1; test++)
    {
      dn = d->_mp_size;
      dup = d->_mp_d;
      f (dnp, dup, dn);
      dnp[dn - 1] |= 1UL<<63;
      f (0);
      nn = nnn;
      np = n->_mp_d;
      qp[-1] = -757136820;
      qp[nn - dn + 1] = 14883681;
      f (0);
      if (dn >= 6)
	f (0);
      itch = nn + 1;
      if (itch + 1> alloc)
	{
	  g(0,alloc*8,(itch+1)*8);
	  alloc = itch + 1;
	}
      f (np, nn);
    }
  return 0;
}
"
"/* { dg-do compile } */
/* { dg-options ""-O2 -msha"" } */
/* { dg-final { scan-assembler ""sha256msg2\[ \\t\]+\[^\n\]*%xmm\[0-9\]"" } } */

#include <immintrin.h>

volatile __m128i x;

void extern
sha_test (void)
{
  x = _mm_sha256msg2_epu32 (x, x);
}
","/* { dg-do compile } */
/* { dg-options ""-O2 -msha"" } */
/* { dg-final { scan-assembler ""sha256msg2\[ \\t\]+\[^\n\]*%xmm\[0-9\]"" } } */

#include <immintrin.h>

volatile __m128i x;

void extern
sha_test (void)
{
  x = _mm_sha256msg2_epu32 (x, x);
}
"
"/* { dg-do compile } */
/* { dg-options ""-O2 -fdump-tree-tailc"" } */

void
set_integer (void *dest, int value, int length)
{
  int tmp = value;
  __builtin_memcpy (dest, (void *) &tmp, length);
}

/* { dg-final { scan-tree-dump-not ""tail call"" ""tailc"" } } */
","/* { dg-do compile } */
/* { dg-options ""-O2 -fdump-tree-tailc"" } */

void
set_integer (void *dest, int value, int length)
{
  int tmp = value;
  __builtin_memcpy (dest, (void *) &tmp, length);
}

/* { dg-final { scan-tree-dump-not ""tail call"" ""tailc"" } } */
"
"/* PR c/83989 */
/* { dg-do compile } */
/* { dg-options ""-O2 -Wrestrict"" } */

__attribute__((__malloc__)) extern void *my_malloc (__SIZE_TYPE__);
void baz (void *);

#define SIZE 32

void
foo (void)
{
  void *recmem = __builtin_malloc (SIZE);
  baz (recmem);
  while (1)
    {
      void *oldrecmem = recmem;
      recmem = __builtin_malloc (SIZE);
      if (!recmem)
	{
	  __builtin_free (oldrecmem);
	  return;
	}
      __builtin_memcpy (recmem, oldrecmem, SIZE);	/* { dg-bogus ""accessing"" } */
      baz (recmem);
      __builtin_free (oldrecmem);
    }
}

void
bar (void)
{
  void *recmem = my_malloc (SIZE);
  baz (recmem);
  while (1)
    {
      void *oldrecmem = recmem;
      recmem = my_malloc (SIZE);
      if (!recmem)
	{
	  __builtin_free (oldrecmem);
	  return;
	}
      __builtin_memcpy (recmem, oldrecmem, SIZE);	/* { dg-bogus ""accessing"" } */
      baz (recmem);
      __builtin_free (oldrecmem);
    }
}
","/* PR c/83989 */
/* { dg-do compile } */
/* { dg-options ""-O2 -Wrestrict"" } */

__attribute__((__malloc__)) extern void *my_malloc (__SIZE_TYPE__);
void baz (void *);

#define SIZE 32

void
foo (void)
{
  void *recmem = __builtin_malloc (SIZE);
  baz (recmem);
  while (1)
    {
      void *oldrecmem = recmem;
      recmem = __builtin_malloc (SIZE);
      if (!recmem)
	{
	  __builtin_free (oldrecmem);
	  return;
	}
      __builtin_memcpy (recmem, oldrecmem, SIZE);	/* { dg-bogus ""accessing"" } */
      baz (recmem);
      __builtin_free (oldrecmem);
    }
}

void
bar (void)
{
  void *recmem = my_malloc (SIZE);
  baz (recmem);
  while (1)
    {
      void *oldrecmem = recmem;
      recmem = my_malloc (SIZE);
      if (!recmem)
	{
	  __builtin_free (oldrecmem);
	  return;
	}
      __builtin_memcpy (recmem, oldrecmem, SIZE);	/* { dg-bogus ""accessing"" } */
      baz (recmem);
      __builtin_free (oldrecmem);
    }
}
"
"/* { dg-do compile } */
/* { dg-options ""-O2 -ftree-parallelize-loops=2 -fdump-tree-parloops2-details"" } */

extern void abort (void);

char *
foo (int count, char **list)
{
  char *minaddr = list[0];
  int i;

  for (i = 0; i < count; i++)
    {
      char *addr = list[i];
      if (addr < minaddr)
	minaddr = addr;
    }

  return minaddr;
}

char *
foo2 (int count, char **list)
{
  char *maxaddr = list[0];
  int i;

  for (i = 0; i < count; i++)
    {
      char *addr = list[i];
      if (addr > maxaddr)
	maxaddr = addr;
    }

  return maxaddr;
}

/* { dg-final { scan-tree-dump-times ""parallelizing inner loop"" 2 ""parloops2"" } } */
","/* { dg-do compile } */
/* { dg-options ""-O2 -ftree-parallelize-loops=2 -fdump-tree-parloops2-details"" } */

extern void abort (void);

char *
foo (int count, char **list)
{
  char *minaddr = list[0];
  int i;

  for (i = 0; i < count; i++)
    {
      char *addr = list[i];
      if (addr < minaddr)
	minaddr = addr;
    }

  return minaddr;
}

char *
foo2 (int count, char **list)
{
  char *maxaddr = list[0];
  int i;

  for (i = 0; i < count; i++)
    {
      char *addr = list[i];
      if (addr > maxaddr)
	maxaddr = addr;
    }

  return maxaddr;
}

/* { dg-final { scan-tree-dump-times ""parallelizing inner loop"" 2 ""parloops2"" } } */
"
"/* { dg-do run { target int128 } } */
/* { dg-options ""-O2 -fno-tree-dce -mno-push-args"" } */

typedef unsigned long long u64;
typedef unsigned __int128 u128;

u64 v;
u64 g;

u64 __attribute__ ((noinline, noclone))
bar (u128 d, u64 e, u64 f, u64 g, u128 h)
{
  (void)d, (void)e, (void)f, (void)g, (void)h;
  return 0;
}

static u64 __attribute__ ((noipa))
foo (void)
{
  (void)(v - bar (0, 0, 0, 0, 0));
  return g;
}

int
main (void)
{
  (void)foo ();
  return 0;
}
","/* { dg-do run { target int128 } } */
/* { dg-options ""-O2 -fno-tree-dce -mno-push-args"" } */

typedef unsigned long long u64;
typedef unsigned __int128 u128;

u64 v;
u64 g;

u64 __attribute__ ((noinline, noclone))
bar (u128 d, u64 e, u64 f, u64 g, u128 h)
{
  (void)d, (void)e, (void)f, (void)g, (void)h;
  return 0;
}

static u64 __attribute__ ((noipa))
foo (void)
{
  (void)(v - bar (0, 0, 0, 0, 0));
  return g;
}

int
main (void)
{
  (void)foo ();
  return 0;
}
"
"/* Ensure that we don't use 'rep movX' in the presence of register globals.  */
/* { dg-do compile } */
/* { dg-options ""-Os -w"" } */

extern void *memcpy (void *, const void *, __SIZE_TYPE__);

register int regvar asm(""%ecx"");

int foo[10];
int bar[10];

char baz[15];
char quux[15];

void
do_copy ()
{
  memcpy (foo, bar, sizeof foo);
  memcpy (baz, quux, sizeof baz);
}

/* { dg-final { scan-assembler-not ""rep movsl"" } } */
/* { dg-final { scan-assembler-not ""rep movsb"" } } */
","/* Ensure that we don't use 'rep movX' in the presence of register globals.  */
/* { dg-do compile } */
/* { dg-options ""-Os -w"" } */

extern void *memcpy (void *, const void *, __SIZE_TYPE__);

register int regvar asm(""%ecx"");

int foo[10];
int bar[10];

char baz[15];
char quux[15];

void
do_copy ()
{
  memcpy (foo, bar, sizeof foo);
  memcpy (baz, quux, sizeof baz);
}

/* { dg-final { scan-assembler-not ""rep movsl"" } } */
/* { dg-final { scan-assembler-not ""rep movsb"" } } */
"
"/* { dg-options ""-O0"" } */

extern void fn1 (void);

int a;

int
main ()
{
  fn1 ();

  if (a != 0) 
    __builtin_abort (); 

  return 0;
}
","/* { dg-options ""-O0"" } */

extern void fn1 (void);

int a;

int
main ()
{
  fn1 ();

  if (a != 0) 
    __builtin_abort (); 

  return 0;
}
"
"/* { dg-do compile } */

void __assert_fail (void);

int **a, b, c, e, *j;
short *d, **f;

int *
foo ()
{
  *a = j;
  if (!(1 & e)) 
    __assert_fail ();
  return 0;
}

void
bar ()
{
  int *g = &b;
  short **h = &d;
  if ((f = &d) != h)
    for (; b;)
      {
	int i = 1;
	if (i)
	  g = foo ();
	c = 0;
      }
  if (!g)
    __assert_fail ();
}
","/* { dg-do compile } */

void __assert_fail (void);

int **a, b, c, e, *j;
short *d, **f;

int *
foo ()
{
  *a = j;
  if (!(1 & e)) 
    __assert_fail ();
  return 0;
}

void
bar ()
{
  int *g = &b;
  short **h = &d;
  if ((f = &d) != h)
    for (; b;)
      {
	int i = 1;
	if (i)
	  g = foo ();
	c = 0;
      }
  if (!g)
    __assert_fail ();
}
"
"/* { dg-do compile } */
/* { dg-options ""-mavx2 -O2"" } */
/* { dg-final { scan-assembler ""vpabsb\[ \\t\]+\[^\n\]*%ymm\[0-9\]"" } } */

#include <immintrin.h>

volatile __m256i x;

void extern
avx2_test (void)
{
  x = _mm256_abs_epi8 (x);
}
","/* { dg-do compile } */
/* { dg-options ""-mavx2 -O2"" } */
/* { dg-final { scan-assembler ""vpabsb\[ \\t\]+\[^\n\]*%ymm\[0-9\]"" } } */

#include <immintrin.h>

volatile __m256i x;

void extern
avx2_test (void)
{
  x = _mm256_abs_epi8 (x);
}
"
"/* { dg-do compile { target { ! ia32 } } } */
/* { dg-options ""-O2"" } */

typedef unsigned int UTItype __attribute__ ((mode (TI)));

void foo (UTItype *);

UTItype
test (void)
{
  UTItype c = 0;
  foo (&c);
  c = c >> 5 | c << 123;
  return c;
}
/* { dg-final { scan-assembler-times ""shrdq"" 2 } } */
","/* { dg-do compile { target { ! ia32 } } } */
/* { dg-options ""-O2"" } */

typedef unsigned int UTItype __attribute__ ((mode (TI)));

void foo (UTItype *);

UTItype
test (void)
{
  UTItype c = 0;
  foo (&c);
  c = c >> 5 | c << 123;
  return c;
}
/* { dg-final { scan-assembler-times ""shrdq"" 2 } } */
"
"typedef unsigned short t;
struct foo{t d;};
int bar(d)t d;{struct foo u;u.d=d;return(int)(&u);}
","typedef unsigned short t;
struct foo{t d;};
int bar(d)t d;{struct foo u;u.d=d;return(int)(&u);}
"
"/* Check that we get the expected alignment-checking code, op variant, int.  */
/* { dg-do compile } */
/* { dg-options ""-O2 -Dop -Dtype=int"" } */
/* { dg-additional-options ""-mtrap-using-break8 -mtrap-unaligned-atomic"" { target cris-*-elf } } */
/* { dg-additional-options ""-mno-unaligned-atomic-may-use-library"" { target cris*-*-linux* } } */
/* { dg-final { scan-assembler ""\tbreak 8"" } } */
/* { dg-final { scan-assembler ""\tbtstq \\(2-1\\),"" } } */
/* { dg-final { scan-assembler-not ""\tand"" } } */
/* { dg-final { scan-assembler-not ""\t\[jb\]sr"" } } */
#include ""sync-1.c""
","/* Check that we get the expected alignment-checking code, op variant, int.  */
/* { dg-do compile } */
/* { dg-options ""-O2 -Dop -Dtype=int"" } */
/* { dg-additional-options ""-mtrap-using-break8 -mtrap-unaligned-atomic"" { target cris-*-elf } } */
/* { dg-additional-options ""-mno-unaligned-atomic-may-use-library"" { target cris*-*-linux* } } */
/* { dg-final { scan-assembler ""\tbreak 8"" } } */
/* { dg-final { scan-assembler ""\tbtstq \\(2-1\\),"" } } */
/* { dg-final { scan-assembler-not ""\tand"" } } */
/* { dg-final { scan-assembler-not ""\t\[jb\]sr"" } } */
#include ""sync-1.c""
"
"/* Test floating-point conversions.  Standard types and long double.  */
/* Origin: Joseph Myers <joseph@codesourcery.com> */
/* { dg-do run } */
/* { dg-options """" } */

#include <float.h>
#include ""fp-int-convert.h""

int
main (void)
{
  TEST_I_F(signed char, unsigned char, long double, LDBL_MANT_DIG, LDBL_MAX_EXP);
  TEST_I_F(signed short, unsigned short, long double, LDBL_MANT_DIG, LDBL_MAX_EXP);
  TEST_I_F(signed int, unsigned int, long double, LDBL_MANT_DIG, LDBL_MAX_EXP);
  TEST_I_F(signed long, unsigned long, long double, LDBL_MANT_DIG, LDBL_MAX_EXP);
  TEST_I_F(signed long long, unsigned long long, long double, LDBL_MANT_DIG, LDBL_MAX_EXP);
  exit (0);
}
","/* Test floating-point conversions.  Standard types and long double.  */
/* Origin: Joseph Myers <joseph@codesourcery.com> */
/* { dg-do run } */
/* { dg-options """" } */

#include <float.h>
#include ""fp-int-convert.h""

int
main (void)
{
  TEST_I_F(signed char, unsigned char, long double, LDBL_MANT_DIG, LDBL_MAX_EXP);
  TEST_I_F(signed short, unsigned short, long double, LDBL_MANT_DIG, LDBL_MAX_EXP);
  TEST_I_F(signed int, unsigned int, long double, LDBL_MANT_DIG, LDBL_MAX_EXP);
  TEST_I_F(signed long, unsigned long, long double, LDBL_MANT_DIG, LDBL_MAX_EXP);
  TEST_I_F(signed long long, unsigned long long, long double, LDBL_MANT_DIG, LDBL_MAX_EXP);
  exit (0);
}
"
"/* { dg-do compile } */
/* { dg-options ""-mrdseed -O2"" } */
/* { dg-final { scan-assembler ""rdseed\[ \\t\]+"" } } */

#include <x86intrin.h>

void extern
rdseed_test (unsigned short *p)
{
    volatile int r;
    r = _rdseed16_step (p);
}

","/* { dg-do compile } */
/* { dg-options ""-mrdseed -O2"" } */
/* { dg-final { scan-assembler ""rdseed\[ \\t\]+"" } } */

#include <x86intrin.h>

void extern
rdseed_test (unsigned short *p)
{
    volatile int r;
    r = _rdseed16_step (p);
}

"
"/* { dg-do compile } */
/* { dg-options ""-Winline -O2 -fgnu89-inline"" } */
/* { dg-require-effective-target alloca } */

extern void *alloca (__SIZE_TYPE__);

void big (void);
inline void *q (void) /* { dg-warning ""(function not inlinable|alloca)"" } */
{
	return alloca (10);
}
inline void *t (void)
{
	return q ();		 /* { dg-message ""called from here"" } */
}
","/* { dg-do compile } */
/* { dg-options ""-Winline -O2 -fgnu89-inline"" } */
/* { dg-require-effective-target alloca } */

extern void *alloca (__SIZE_TYPE__);

void big (void);
inline void *q (void) /* { dg-warning ""(function not inlinable|alloca)"" } */
{
	return alloca (10);
}
inline void *t (void)
{
	return q ();		 /* { dg-message ""called from here"" } */
}
"
"﻿ /* Test case for PR 33415.  Note that the first bytes of this file
     are a UTF-8 BOM.  */

/* { dg-do compile } */

int f(void) { return 5; }
","﻿ /* Test case for PR 33415.  Note that the first bytes of this file
     are a UTF-8 BOM.  */

/* { dg-do compile } */

int f(void) { return 5; }
"
"/* { dg-do run { target aarch64_sve_hw } } */
/* { dg-options ""-O2 -ftree-vectorize"" } */

#include ""slp_13.c""

#define N1 (103 * 2)
#define N2 (111 * 2)

#define HARNESS(TYPE)						\
  {								\
    TYPE a[N2];							\
    TYPE expected = 0;						\
    for (unsigned int i = 0; i < N2; ++i)			\
      {								\
	a[i] = i * 2 + i % 5;					\
	if (i < N1)						\
	  expected += a[i] * (i & 1 ? 5 : 3);			\
	asm volatile ("""");					\
      }								\
    if (vec_slp_##TYPE (a, N1 / 2) != expected)			\
      __builtin_abort ();					\
  }

int __attribute__ ((optimize (1)))
main (void)
{
  TEST_ALL (HARNESS)
}
","/* { dg-do run { target aarch64_sve_hw } } */
/* { dg-options ""-O2 -ftree-vectorize"" } */

#include ""slp_13.c""

#define N1 (103 * 2)
#define N2 (111 * 2)

#define HARNESS(TYPE)						\
  {								\
    TYPE a[N2];							\
    TYPE expected = 0;						\
    for (unsigned int i = 0; i < N2; ++i)			\
      {								\
	a[i] = i * 2 + i % 5;					\
	if (i < N1)						\
	  expected += a[i] * (i & 1 ? 5 : 3);			\
	asm volatile ("""");					\
      }								\
    if (vec_slp_##TYPE (a, N1 / 2) != expected)			\
      __builtin_abort ();					\
  }

int __attribute__ ((optimize (1)))
main (void)
{
  TEST_ALL (HARNESS)
}
"
"/* Test the vqdmull_laneq_s32 AArch64 SIMD intrinsic.  */

/* { dg-do compile } */
/* { dg-options ""-save-temps -O3 -fno-inline"" } */

#include ""arm_neon.h""

int64x2_t
t_vqdmull_laneq_s32 (int32x2_t a, int32x4_t b)
{
  return vqdmull_laneq_s32 (a, b, 0);
}

/* { dg-final { scan-assembler-times ""sqdmull\[ \t\]+\[vV\]\[0-9\]+\.2\[dD\], ?\[vV\]\[0-9\]+\.2\[sS\], ?\[vV\]\[0-9\]+\.\[sS\]\\\[0\\\]\n"" 1 } } */
","/* Test the vqdmull_laneq_s32 AArch64 SIMD intrinsic.  */

/* { dg-do compile } */
/* { dg-options ""-save-temps -O3 -fno-inline"" } */

#include ""arm_neon.h""

int64x2_t
t_vqdmull_laneq_s32 (int32x2_t a, int32x4_t b)
{
  return vqdmull_laneq_s32 (a, b, 0);
}

/* { dg-final { scan-assembler-times ""sqdmull\[ \t\]+\[vV\]\[0-9\]+\.2\[dD\], ?\[vV\]\[0-9\]+\.2\[sS\], ?\[vV\]\[0-9\]+\.\[sS\]\\\[0\\\]\n"" 1 } } */
"
"/* { dg-do compile } */
/* { dg-options ""-O2 -floop-interchange -fdump-tree-linterchange-details"" } */
/* { dg-skip-if ""too big data segment"" { avr-*-* visium-*-* } } */

#define M 256
int a[M][M], b[M][M];

void
simple_reduc_1 (int n, int *p)
{
  for (int j = 0; j < n; j++)
    {
      int sum = p[j];
      for (int i = 0; i < n; i++)
	{
	  sum = sum + b[i][j];
	  b[i][j] += a[i][j];
	}

      p[j] = sum;
    }
}
/* { dg-final { scan-tree-dump-not ""Loop_pair<outer:., inner:.> is interchanged"" ""linterchange"" } } */
","/* { dg-do compile } */
/* { dg-options ""-O2 -floop-interchange -fdump-tree-linterchange-details"" } */
/* { dg-skip-if ""too big data segment"" { avr-*-* visium-*-* } } */

#define M 256
int a[M][M], b[M][M];

void
simple_reduc_1 (int n, int *p)
{
  for (int j = 0; j < n; j++)
    {
      int sum = p[j];
      for (int i = 0; i < n; i++)
	{
	  sum = sum + b[i][j];
	  b[i][j] += a[i][j];
	}

      p[j] = sum;
    }
}
/* { dg-final { scan-tree-dump-not ""Loop_pair<outer:., inner:.> is interchanged"" ""linterchange"" } } */
"
"int foo (int i, int b)
{
  int mask;
  int result;
  if (b)
    mask = -1;
  else
    mask = 0;
  result = i + 1;
  result = result & mask;
  return result;
}
","int foo (int i, int b)
{
  int mask;
  int result;
  if (b)
    mask = -1;
  else
    mask = 0;
  result = i + 1;
  result = result & mask;
  return result;
}
"
"/* Test for security warning when non-literal format has no arguments.  */
/* Origin: Joseph Myers <jsm28@cam.ac.uk> */
/* { dg-do compile { target { *-*-mingw* } } } */
/* { dg-options ""-std=gnu99 -Wformat -Wformat-security"" } */

#define USE_SYSTEM_FORMATS
#include ""format.h""

void
foo (char *s)
{
  printf (s); /* { dg-warning ""no format arguments"" ""security warning"" } */
}
","/* Test for security warning when non-literal format has no arguments.  */
/* Origin: Joseph Myers <jsm28@cam.ac.uk> */
/* { dg-do compile { target { *-*-mingw* } } } */
/* { dg-options ""-std=gnu99 -Wformat -Wformat-security"" } */

#define USE_SYSTEM_FORMATS
#include ""format.h""

void
foo (char *s)
{
  printf (s); /* { dg-warning ""no format arguments"" ""security warning"" } */
}
"
"/* { dg-do compile } */
/* { dg-require-effective-target arm_thumb1_ok } */
/* { dg-options ""-Os"" } */
/* { dg-skip-if """" { ! { arm_thumb1 } } } */

int
mymul3 (int x)
{
  return x * 0x555;
}

/* { dg-final { scan-assembler ""muls\[\\t \]*r.,\[\\t \]*r."" } } */
","/* { dg-do compile } */
/* { dg-require-effective-target arm_thumb1_ok } */
/* { dg-options ""-Os"" } */
/* { dg-skip-if """" { ! { arm_thumb1 } } } */

int
mymul3 (int x)
{
  return x * 0x555;
}

/* { dg-final { scan-assembler ""muls\[\\t \]*r.,\[\\t \]*r."" } } */
"
"/* { dg-do run } */
/* { dg-shouldfail ""asan"" } */

#include <sanitizer/asan_interface.h>

struct vfsmount {};
struct dentry {};

struct path {
  struct vfsmount *mnt;
  struct dentry *dentry;
};

struct fs_struct {
  int users;
  int lock;
  int seq;
  int umask;
  int in_exec;
  struct path root, pwd;
};

void __attribute__((noinline, noclone))
copy_fs_struct(struct fs_struct *a, struct fs_struct *b) {
  a->root = b->root;
}

struct fs_struct a, b;

int
main () {
  __asan_poison_memory_region (&a.root, sizeof (a.root));
  copy_fs_struct (&a, &b);
  return 0;
}

/* { dg-output ""ERROR: AddressSanitizer:\[^\n\r]*on address\[^\n\r]*"" } */
","/* { dg-do run } */
/* { dg-shouldfail ""asan"" } */

#include <sanitizer/asan_interface.h>

struct vfsmount {};
struct dentry {};

struct path {
  struct vfsmount *mnt;
  struct dentry *dentry;
};

struct fs_struct {
  int users;
  int lock;
  int seq;
  int umask;
  int in_exec;
  struct path root, pwd;
};

void __attribute__((noinline, noclone))
copy_fs_struct(struct fs_struct *a, struct fs_struct *b) {
  a->root = b->root;
}

struct fs_struct a, b;

int
main () {
  __asan_poison_memory_region (&a.root, sizeof (a.root));
  copy_fs_struct (&a, &b);
  return 0;
}

/* { dg-output ""ERROR: AddressSanitizer:\[^\n\r]*on address\[^\n\r]*"" } */
"
"// { dg-do preprocess }
// { dg-options ""-std=gnu99 -fdiagnostics-show-option -trigraphs -Wtrigraphs"" }

??=  // { dg-warning ""trigraph \\?\\?= converted to # .-Wtrigraphs."" }
","// { dg-do preprocess }
// { dg-options ""-std=gnu99 -fdiagnostics-show-option -trigraphs -Wtrigraphs"" }

??=  // { dg-warning ""trigraph \\?\\?= converted to # .-Wtrigraphs."" }
"
"/* PR rtl-optimization/80747 */
/* { dg-do compile } */
/* { dg-options ""-fprofile-use -freorder-blocks-and-partition -O1 -foptimize-sibling-calls"" } */

int
foo (int a)
{
  int r;
  if (a & 1)
    r = foo (a - 1);
  else if (a)
    r = foo (a - 2);
  else
    return 0;
  if (r)
    r = r;
  return r;
}
","/* PR rtl-optimization/80747 */
/* { dg-do compile } */
/* { dg-options ""-fprofile-use -freorder-blocks-and-partition -O1 -foptimize-sibling-calls"" } */

int
foo (int a)
{
  int r;
  if (a & 1)
    r = foo (a - 1);
  else if (a)
    r = foo (a - 2);
  else
    return 0;
  if (r)
    r = r;
  return r;
}
"
"/* PR tree-optimization/78574 */

int a, d, f, g;
int b[1];
short h;
int main() {
  long j;
  int k, i;
  for (; j; j++) {
    i = 0;
    for (; i < 6; i++) {
      int l = a, m = d || g;
    L:
      l ^ m | a;
    }
    b[j + 1] = 2;
    ++k;
    for (; g; g++) {
      d ^= h;
      if (f)
        for (;;)
          ;
    }
  }
  if (k)
    goto L;
}
","/* PR tree-optimization/78574 */

int a, d, f, g;
int b[1];
short h;
int main() {
  long j;
  int k, i;
  for (; j; j++) {
    i = 0;
    for (; i < 6; i++) {
      int l = a, m = d || g;
    L:
      l ^ m | a;
    }
    b[j + 1] = 2;
    ++k;
    for (; g; g++) {
      d ^= h;
      if (f)
        for (;;)
          ;
    }
  }
  if (k)
    goto L;
}
"
"/* { dg-do compile } */
/* { dg-options ""-O2"" } */

int foo1 (int a)
{
  int b = a + 1;
  if (b != 0)
    return b;
  return 1;
}

int foo2 (int a)
{
  int b = a + 1;
  if (b < 0)
    return b;
  return 1;
}

int foo3 (int a)
{
  int b = a + 1;
  if (b >= 0)
    return b;
  return 1;
}

/* { dg-final { scan-assembler ""move\t%""  } } */
/* { dg-final { scan-assembler ""movpos\t%""  } } */
/* { dg-final { scan-assembler ""movneg\t%"" } } */
","/* { dg-do compile } */
/* { dg-options ""-O2"" } */

int foo1 (int a)
{
  int b = a + 1;
  if (b != 0)
    return b;
  return 1;
}

int foo2 (int a)
{
  int b = a + 1;
  if (b < 0)
    return b;
  return 1;
}

int foo3 (int a)
{
  int b = a + 1;
  if (b >= 0)
    return b;
  return 1;
}

/* { dg-final { scan-assembler ""move\t%""  } } */
/* { dg-final { scan-assembler ""movpos\t%""  } } */
/* { dg-final { scan-assembler ""movneg\t%"" } } */
"
"/* PR target/65078 */
/* { dg-do compile } */
/* { dg-options ""-O2 -msse -DALL"" } */

#include ""pr65078-1.c""
","/* PR target/65078 */
/* { dg-do compile } */
/* { dg-options ""-O2 -msse -DALL"" } */

#include ""pr65078-1.c""
"
"/* { dg-lto-options ""-mcpu=v9"" { target sparc*-*-* } } */
/* { dg-require-effective-target sync_char_short } */
void
_cairo_clip_path_reference () {
  int a;
  __sync_fetch_and_add(&a, 1);
}

int main(void) {
  return 0;
}
","/* { dg-lto-options ""-mcpu=v9"" { target sparc*-*-* } } */
/* { dg-require-effective-target sync_char_short } */
void
_cairo_clip_path_reference () {
  int a;
  __sync_fetch_and_add(&a, 1);
}

int main(void) {
  return 0;
}
"
"/* Check that the mov.w displacement addressing insn is generated and the 
   base address is adjusted only once.  On SH2A this test is skipped because
   there is a 4 byte mov.w insn that can handle larger displacements.  Thus
   on SH2A the base address will not be adjusted in this case.  */
/* { dg-do compile { target { ! sh2a } } }  */
/* { dg-options ""-O1"" } */
/* { dg-final { scan-assembler-times ""add"" 2 } } */

void
testfunc_00 (const short* ap, short* bp)
{
  bp[0] = ap[15];
  bp[2] = ap[5];
  bp[9] = ap[7];
  bp[0] = ap[25];
}

void
testfunc_01 (volatile const short* ap, volatile short* bp)
{
  bp[0] = ap[15];
  bp[2] = ap[5];
  bp[9] = ap[7];
  bp[0] = ap[25];
}

","/* Check that the mov.w displacement addressing insn is generated and the 
   base address is adjusted only once.  On SH2A this test is skipped because
   there is a 4 byte mov.w insn that can handle larger displacements.  Thus
   on SH2A the base address will not be adjusted in this case.  */
/* { dg-do compile { target { ! sh2a } } }  */
/* { dg-options ""-O1"" } */
/* { dg-final { scan-assembler-times ""add"" 2 } } */

void
testfunc_00 (const short* ap, short* bp)
{
  bp[0] = ap[15];
  bp[2] = ap[5];
  bp[9] = ap[7];
  bp[0] = ap[25];
}

void
testfunc_01 (volatile const short* ap, volatile short* bp)
{
  bp[0] = ap[15];
  bp[2] = ap[5];
  bp[9] = ap[7];
  bp[0] = ap[25];
}

"
"/* { dg-do run } */
/* { dg-require-effective-target int128 } */
/* { dg-options ""-O2 -Wno-psabi"" } */

#define MAGIC 0x0706050403020100

typedef unsigned long long u64;
typedef unsigned __int128 v64u128 __attribute__ ((vector_size (64)));

v64u128 __attribute__ ((noinline, noclone))
foo (u64 x1, u64 x2, u64 x3, u64 x4, v64u128 x5)
{
  (void)x1, (void)x2;
  x4 >>= x4 & 63;
  return x3 + x4 + x5;
}

int
main ()
{
  v64u128 x = foo (0, 0, 0, MAGIC, (v64u128) {});
  if (x[0] != MAGIC || x[1] != MAGIC || x[2] != MAGIC || x[3] != MAGIC)
    __builtin_abort();
  return 0;
}
","/* { dg-do run } */
/* { dg-require-effective-target int128 } */
/* { dg-options ""-O2 -Wno-psabi"" } */

#define MAGIC 0x0706050403020100

typedef unsigned long long u64;
typedef unsigned __int128 v64u128 __attribute__ ((vector_size (64)));

v64u128 __attribute__ ((noinline, noclone))
foo (u64 x1, u64 x2, u64 x3, u64 x4, v64u128 x5)
{
  (void)x1, (void)x2;
  x4 >>= x4 & 63;
  return x3 + x4 + x5;
}

int
main ()
{
  v64u128 x = foo (0, 0, 0, MAGIC, (v64u128) {});
  if (x[0] != MAGIC || x[1] != MAGIC || x[2] != MAGIC || x[3] != MAGIC)
    __builtin_abort();
  return 0;
}
"
"/* PR middle-end/67517 */
/* { dg-do compile } */
/* { dg-options ""-fopenmp"" } */

int
foo (int x, int y, int z)
{
  int i;
  #pragma omp parallel for simd linear (y : x & 15) linear (x : 16) linear (z : x & 15)
  for (i = 0; i < 256; ++i)
    x += 16, y += x & 15, z += x & 15;
  return x + y + z;
}
","/* PR middle-end/67517 */
/* { dg-do compile } */
/* { dg-options ""-fopenmp"" } */

int
foo (int x, int y, int z)
{
  int i;
  #pragma omp parallel for simd linear (y : x & 15) linear (x : 16) linear (z : x & 15)
  for (i = 0; i < 256; ++i)
    x += 16, y += x & 15, z += x & 15;
  return x + y + z;
}
"
"/* Test the vcage_f64 AArch64 SIMD intrinsic.  */

/* { dg-do run } */
/* { dg-options ""-save-temps -O3"" } */

#include ""arm_neon.h""

#define SIZE 6

extern void abort (void);

volatile float64_t in[SIZE] = { -10.4, -3.14, 0.0, 1.5, 5.3, 532.3 };

int
main (void)
{
  uint64_t expected;
  uint64_t actual;
  float64x1_t arg1, arg2;
  int i, j;

  for (i = 0; i < SIZE; ++i)
   for (j = 0; j < SIZE; ++j)
     {
        expected = __builtin_fabs (in[i]) >= __builtin_fabs (in[j]) ? -1 : 0;
        arg1 = (float64x1_t) { in[i] };
        arg2 = (float64x1_t) { in[j] };
        actual = vget_lane_u64 (vcage_f64 (arg1, arg2), 0);

        if (actual != expected)
          abort ();
     }

  return 0;
}

/* { dg-final { scan-assembler ""facge\[ \t\]+\[dD\]\[0-9\]+, ?\[dD\]\[0-9\]+, ?\[dD\]\[0-9\]+\n"" } } */
","/* Test the vcage_f64 AArch64 SIMD intrinsic.  */

/* { dg-do run } */
/* { dg-options ""-save-temps -O3"" } */

#include ""arm_neon.h""

#define SIZE 6

extern void abort (void);

volatile float64_t in[SIZE] = { -10.4, -3.14, 0.0, 1.5, 5.3, 532.3 };

int
main (void)
{
  uint64_t expected;
  uint64_t actual;
  float64x1_t arg1, arg2;
  int i, j;

  for (i = 0; i < SIZE; ++i)
   for (j = 0; j < SIZE; ++j)
     {
        expected = __builtin_fabs (in[i]) >= __builtin_fabs (in[j]) ? -1 : 0;
        arg1 = (float64x1_t) { in[i] };
        arg2 = (float64x1_t) { in[j] };
        actual = vget_lane_u64 (vcage_f64 (arg1, arg2), 0);

        if (actual != expected)
          abort ();
     }

  return 0;
}

/* { dg-final { scan-assembler ""facge\[ \t\]+\[dD\]\[0-9\]+, ?\[dD\]\[0-9\]+, ?\[dD\]\[0-9\]+\n"" } } */
"
"/* { dg-do compile } */
/* { dg-options ""-O2 -fdump-tree-ivcanon-details"" } */

void bar();
void foo(unsigned dst)
{
  unsigned end = dst;
  do {
    bar();
    dst += 2;
  } while (dst < end);
}

/* { dg-final { scan-tree-dump "" zero if "" ""ivcanon"" } } */
","/* { dg-do compile } */
/* { dg-options ""-O2 -fdump-tree-ivcanon-details"" } */

void bar();
void foo(unsigned dst)
{
  unsigned end = dst;
  do {
    bar();
    dst += 2;
  } while (dst < end);
}

/* { dg-final { scan-tree-dump "" zero if "" ""ivcanon"" } } */
"
"extern void abort (void);

typedef short fract16;

fract16 foo (fract16 f, short n)
{
  return __builtin_bfin_shrl_fr1x16 (f, n);
}

int main ()
{
  fract16 t1;

  t1 = foo (0x4004, -4);
  if (t1 != 0x0040)
    abort ();

  return 0;
}

","extern void abort (void);

typedef short fract16;

fract16 foo (fract16 f, short n)
{
  return __builtin_bfin_shrl_fr1x16 (f, n);
}

int main ()
{
  fract16 t1;

  t1 = foo (0x4004, -4);
  if (t1 != 0x0040)
    abort ();

  return 0;
}

"
"/* { dg-do run } */
/* { dg-require-effective-target avx } */
/* { dg-options ""-O2 -mavx"" } */

#define CHECK_H ""avx-check.h""
#define TEST avx_test

#include ""sse2-pavgb-1.c""
","/* { dg-do run } */
/* { dg-require-effective-target avx } */
/* { dg-options ""-O2 -mavx"" } */

#define CHECK_H ""avx-check.h""
#define TEST avx_test

#include ""sse2-pavgb-1.c""
"
"/* { dg-do compile } */
/* { dg-options ""-O2"" } */

typedef __Float64x1_t float64x1_t;

typedef long long int64_t;

extern int64_t bar (float64x1_t f);

int
foo (void)
{
  float64x1_t f = { 3.14159265358979311599796346854 };
  int64_t c = 0x400921FB54442D18;
  int64_t r;
  r = bar (f);
  return r == c;
}
","/* { dg-do compile } */
/* { dg-options ""-O2"" } */

typedef __Float64x1_t float64x1_t;

typedef long long int64_t;

extern int64_t bar (float64x1_t f);

int
foo (void)
{
  float64x1_t f = { 3.14159265358979311599796346854 };
  int64_t c = 0x400921FB54442D18;
  int64_t r;
  r = bar (f);
  return r == c;
}
"
"/* { dg-do run } */
/* { dg-require-effective-target avx } */
/* { dg-options ""-O2 -mavx"" } */

#define CHECK_H ""avx-check.h""
#define TEST avx_test

#include ""sse2-cvtsd2si-1.c""
","/* { dg-do run } */
/* { dg-require-effective-target avx } */
/* { dg-options ""-O2 -mavx"" } */

#define CHECK_H ""avx-check.h""
#define TEST avx_test

#include ""sse2-cvtsd2si-1.c""
"
"/* PR tree-optimization/57741 */
/* { dg-require-effective-target vect_float } */
/* { dg-additional-options ""-ffast-math"" } */

#include ""tree-vect.h""

extern void abort (void);

__attribute__((noinline, noclone)) void
foo (float *p, float *q, float x)
{
  int i;
  p = (float *) __builtin_assume_aligned (p, 32);
  q = (float *) __builtin_assume_aligned (q, 32);
  float f = 1.0f, g = 2.0f;
  for (i = 0; i < 1024; i++)
    {
      *p++ = f;
      f += x;
    }
  for (i = 0; i < 1024; i++)
    {
      *q++ = g;
      g += 0.5f;
    }
}

float p[1024] __attribute__((aligned (32))) = { 17.0f };
float q[1024] __attribute__((aligned (32))) = { 17.0f };

int
main ()
{
  int i;
  check_vect ();
  foo (p, q, 1.5f);
  for (i = 0; i < 1024; i++)
    if (p[i] != 1.0f + i * 1.5f || q[i] != 2.0f + i * 0.5f)
      abort ();
  return 0;
}

/* { dg-final { scan-tree-dump-times ""vectorized 2 loop"" 1 ""vect"" } } */
","/* PR tree-optimization/57741 */
/* { dg-require-effective-target vect_float } */
/* { dg-additional-options ""-ffast-math"" } */

#include ""tree-vect.h""

extern void abort (void);

__attribute__((noinline, noclone)) void
foo (float *p, float *q, float x)
{
  int i;
  p = (float *) __builtin_assume_aligned (p, 32);
  q = (float *) __builtin_assume_aligned (q, 32);
  float f = 1.0f, g = 2.0f;
  for (i = 0; i < 1024; i++)
    {
      *p++ = f;
      f += x;
    }
  for (i = 0; i < 1024; i++)
    {
      *q++ = g;
      g += 0.5f;
    }
}

float p[1024] __attribute__((aligned (32))) = { 17.0f };
float q[1024] __attribute__((aligned (32))) = { 17.0f };

int
main ()
{
  int i;
  check_vect ();
  foo (p, q, 1.5f);
  for (i = 0; i < 1024; i++)
    if (p[i] != 1.0f + i * 1.5f || q[i] != 2.0f + i * 0.5f)
      abort ();
  return 0;
}

/* { dg-final { scan-tree-dump-times ""vectorized 2 loop"" 1 ""vect"" } } */
"
"/* PR c++/35334 */
/* { dg-do compile } */
/* { dg-options ""-std=gnu99"" } */
/* { dg-bogus ""not supported by"" """" { target *-*-* } 0 } */

__complex__ unsigned int i;
int j;
char k;
__complex__ double l;
double m;
float n;

void
foo ()
{
  ((__complex__ int)i)();		/* { dg-error ""is not a function"" } */
  ((__complex__ int)j)();		/* { dg-error ""is not a function"" } */
  ((__complex__ int)k)();		/* { dg-error ""is not a function"" } */
  ((__complex__ long double)l)();	/* { dg-error ""is not a function"" } */
  ((__complex__ long double)m)();	/* { dg-error ""is not a function"" } */
  ((__complex__ long double)n)();	/* { dg-error ""is not a function"" } */
}
","/* PR c++/35334 */
/* { dg-do compile } */
/* { dg-options ""-std=gnu99"" } */
/* { dg-bogus ""not supported by"" """" { target *-*-* } 0 } */

__complex__ unsigned int i;
int j;
char k;
__complex__ double l;
double m;
float n;

void
foo ()
{
  ((__complex__ int)i)();		/* { dg-error ""is not a function"" } */
  ((__complex__ int)j)();		/* { dg-error ""is not a function"" } */
  ((__complex__ int)k)();		/* { dg-error ""is not a function"" } */
  ((__complex__ long double)l)();	/* { dg-error ""is not a function"" } */
  ((__complex__ long double)m)();	/* { dg-error ""is not a function"" } */
  ((__complex__ long double)n)();	/* { dg-error ""is not a function"" } */
}
"
"/* PR c/63453 */
/* { dg-do compile } */
/* { dg-options ""-std=gnu11"" } */

inline int fn1 (void); /* { dg-warning ""declared but never defined"" } */
extern inline int fn2 (void); /* { dg-warning ""declared but never defined"" } */
inline int __attribute__ ((gnu_inline)) fn3 (void);
extern inline int __attribute__ ((gnu_inline)) fn4 (void);
","/* PR c/63453 */
/* { dg-do compile } */
/* { dg-options ""-std=gnu11"" } */

inline int fn1 (void); /* { dg-warning ""declared but never defined"" } */
extern inline int fn2 (void); /* { dg-warning ""declared but never defined"" } */
inline int __attribute__ ((gnu_inline)) fn3 (void);
extern inline int __attribute__ ((gnu_inline)) fn4 (void);
"
"#include ""harness.h""

vector unsigned char u8;

static void f(void *p)
{
  u8 = vec_ld(1, (unsigned char *)p);
}

static void test()
{
  static vector unsigned int value = {1,-2,3,-4};
  static vector unsigned int buffer[2];
  buffer[1] = value;
  f((void *)(-1+(char*)(buffer+1)));
  check(vec_all_eq((vector unsigned int) u8, value), ""u8"");
}
","#include ""harness.h""

vector unsigned char u8;

static void f(void *p)
{
  u8 = vec_ld(1, (unsigned char *)p);
}

static void test()
{
  static vector unsigned int value = {1,-2,3,-4};
  static vector unsigned int buffer[2];
  buffer[1] = value;
  f((void *)(-1+(char*)(buffer+1)));
  check(vec_all_eq((vector unsigned int) u8, value), ""u8"");
}
"
"/* { dg-options ""-fPIC -mno-pic-data-is-text-relative"" } */
/* { dg-final { scan-assembler-not ""j-\\(.LPIC""  } } */
/* { dg-final { scan-assembler-not ""_GLOBAL_OFFSET_TABLE_-\\(.LPIC"" } } */
/* { dg-final { scan-assembler ""j\\(GOT\\)"" } } */
/* { dg-final { scan-assembler ""(ldr|mov)\tr\[0-9\]+, \\\[?r9"" } } */

static int j;

int *Foo ()
{
  return &j;
}
","/* { dg-options ""-fPIC -mno-pic-data-is-text-relative"" } */
/* { dg-final { scan-assembler-not ""j-\\(.LPIC""  } } */
/* { dg-final { scan-assembler-not ""_GLOBAL_OFFSET_TABLE_-\\(.LPIC"" } } */
/* { dg-final { scan-assembler ""j\\(GOT\\)"" } } */
/* { dg-final { scan-assembler ""(ldr|mov)\tr\[0-9\]+, \\\[?r9"" } } */

static int j;

int *Foo ()
{
  return &j;
}
"
"unsigned char x = 50;
volatile short y = -5;

int main ()
{
  x /= y;
  if (x != (unsigned char) -10)
    abort ();
  exit (0);
}
","unsigned char x = 50;
volatile short y = -5;

int main ()
{
  x /= y;
  if (x != (unsigned char) -10)
    abort ();
  exit (0);
}
"
"// { dg-do compile }
// { dg-options ""-O -std=c11 -g -dA -gno-strict-dwarf"" }
// Expect DW_AT_noreturn once in .debug_info and once in .debug_abbrev
// { dg-final { scan-assembler-times ""DW_AT_noreturn"" 2 { xfail { powerpc-ibm-aix* } } } }

_Noreturn void exit (int);

void exit (int i)
{
  while (i < 0 || i == 0 || i > 0)
    ;
}

","// { dg-do compile }
// { dg-options ""-O -std=c11 -g -dA -gno-strict-dwarf"" }
// Expect DW_AT_noreturn once in .debug_info and once in .debug_abbrev
// { dg-final { scan-assembler-times ""DW_AT_noreturn"" 2 { xfail { powerpc-ibm-aix* } } } }

_Noreturn void exit (int);

void exit (int i)
{
  while (i < 0 || i == 0 || i > 0)
    ;
}

"
"/* { dg-do assemble } */

#include <arm_neon.h>

uint64_t
test_vget_lane_u64_before (uint64x1_t in)
{
  /* { dg-error ""lane -1 out of range 0 - 0"" """" {target *-*-*} 0 } */
  return vget_lane_u64 (in, -1);
}

uint64_t
test_vget_lane_u64_beyond (uint64x1_t in)
{
  /* { dg-error ""lane 1 out of range 0 - 0"" """" {target *-*-*} 0 } */
  return vget_lane_u64 (in, 1);
}
","/* { dg-do assemble } */

#include <arm_neon.h>

uint64_t
test_vget_lane_u64_before (uint64x1_t in)
{
  /* { dg-error ""lane -1 out of range 0 - 0"" """" {target *-*-*} 0 } */
  return vget_lane_u64 (in, -1);
}

uint64_t
test_vget_lane_u64_beyond (uint64x1_t in)
{
  /* { dg-error ""lane 1 out of range 0 - 0"" """" {target *-*-*} 0 } */
  return vget_lane_u64 (in, 1);
}
"
"/* { dg-do compile } */
/* { dg-options ""-O2 -Wno-attributes -mfpmath=sse -mfma"" } */

/* Test that the compiler properly optimizes floating point multiply
   and add instructions into FMA3 instructions.  */

#define TYPE double

#include ""fma_6.h""

/* { dg-final { scan-assembler-times ""vfmadd132sd"" 8  } } */
/* { dg-final { scan-assembler-times ""vfmsub132sd"" 8  } } */
/* { dg-final { scan-assembler-times ""vfnmadd132sd"" 8  } } */
/* { dg-final { scan-assembler-times ""vfnmsub132sd"" 8  } } */
","/* { dg-do compile } */
/* { dg-options ""-O2 -Wno-attributes -mfpmath=sse -mfma"" } */

/* Test that the compiler properly optimizes floating point multiply
   and add instructions into FMA3 instructions.  */

#define TYPE double

#include ""fma_6.h""

/* { dg-final { scan-assembler-times ""vfmadd132sd"" 8  } } */
/* { dg-final { scan-assembler-times ""vfmsub132sd"" 8  } } */
/* { dg-final { scan-assembler-times ""vfnmadd132sd"" 8  } } */
/* { dg-final { scan-assembler-times ""vfnmsub132sd"" 8  } } */
"
"/* { dg-do assemble } */
/* { dg-options ""-DOTHER_ISA=8 -march=v8"" } */

/* Check that -march=v8 is also recognized.  */

#include ""inasm-other.c""
","/* { dg-do assemble } */
/* { dg-options ""-DOTHER_ISA=8 -march=v8"" } */

/* Check that -march=v8 is also recognized.  */

#include ""inasm-other.c""
"
"/* Data definition with no type or storage class should receive a
   pedwarn, rather than a warning which becomes an error with
   -pedantic.  Test with -pedantic-errors.  */
/* Origin: Joseph Myers <jsm@polyomino.org.uk> */
/* { dg-do compile } */
/* { dg-options ""-std=gnu89 -pedantic-errors"" } */

foo(); /* { dg-error ""data definition has no type or storage class"" } */
","/* Data definition with no type or storage class should receive a
   pedwarn, rather than a warning which becomes an error with
   -pedantic.  Test with -pedantic-errors.  */
/* Origin: Joseph Myers <jsm@polyomino.org.uk> */
/* { dg-do compile } */
/* { dg-options ""-std=gnu89 -pedantic-errors"" } */

foo(); /* { dg-error ""data definition has no type or storage class"" } */
"
"/* { dg-do compile } */
/* { dg-require-effective-target vect_int } */

int a[100], b[100], c[100];

void foo(int n, int mid)
{
  int i;
  for(i=0; i<n; i++)
    {
      if (i < mid)
        a[i] = a[i] + b[i];
      else
        a[i] = a[i] + c[i];
    }
}

/* { dg-final { scan-tree-dump-times ""vectorized 2 loops"" 1 ""vect"" { xfail *-*-* } } } */
","/* { dg-do compile } */
/* { dg-require-effective-target vect_int } */

int a[100], b[100], c[100];

void foo(int n, int mid)
{
  int i;
  for(i=0; i<n; i++)
    {
      if (i < mid)
        a[i] = a[i] + b[i];
      else
        a[i] = a[i] + c[i];
    }
}

/* { dg-final { scan-tree-dump-times ""vectorized 2 loops"" 1 ""vect"" { xfail *-*-* } } } */
"
"/* { dg-do compile { target { ! ia32 } } } */

typedef int DItype __attribute__ ((mode (DI)));
typedef unsigned int UDItype __attribute__ ((mode (DI)));
typedef int TItype __attribute__ ((mode (TI)));

__floattisf (TItype u)
{
  DItype hi = u >> (8 * 8);
  UDItype count, shift;
  hi = u >> shift;
}
","/* { dg-do compile { target { ! ia32 } } } */

typedef int DItype __attribute__ ((mode (DI)));
typedef unsigned int UDItype __attribute__ ((mode (DI)));
typedef int TItype __attribute__ ((mode (TI)));

__floattisf (TItype u)
{
  DItype hi = u >> (8 * 8);
  UDItype count, shift;
  hi = u >> shift;
}
"
"/* { dg-options ""-mabi=o64 -mlong32 addressing=absolute"" } */
#include ""abi-main.h""
","/* { dg-options ""-mabi=o64 -mlong32 addressing=absolute"" } */
#include ""abi-main.h""
"
"/* { dg-do compile { target { powerpc-*-linux*paired* && ilp32 } } } */
/* { dg-options ""-mpaired -ffinite-math-only"" } */

/* Test PowerPC PAIRED extensions.  */

#include <paired.h>
#include <stdlib.h>

static float out[2] __attribute__ ((aligned (8)));

vector float b = { 3.0, 5.0 };
vector float c = { 2.0, 6.0 };

vector float a = { 0.0, 0.0 };
void
test_api ()
{

  if (paired_cmpu1_lt (b, c))
    {
      a = paired_add (b, c);
      paired_stx (a, 0, out);
    }
  if ((out[0] != 5.0) || (out[1] != 11.0))
    abort ();
}

int
main ()
{
  test_api ();
  return (0);
}

","/* { dg-do compile { target { powerpc-*-linux*paired* && ilp32 } } } */
/* { dg-options ""-mpaired -ffinite-math-only"" } */

/* Test PowerPC PAIRED extensions.  */

#include <paired.h>
#include <stdlib.h>

static float out[2] __attribute__ ((aligned (8)));

vector float b = { 3.0, 5.0 };
vector float c = { 2.0, 6.0 };

vector float a = { 0.0, 0.0 };
void
test_api ()
{

  if (paired_cmpu1_lt (b, c))
    {
      a = paired_add (b, c);
      paired_stx (a, 0, out);
    }
  if ((out[0] != 5.0) || (out[1] != 11.0))
    abort ();
}

int
main ()
{
  test_api ();
  return (0);
}

"
"/* Test for constant expressions: VLA size constraints with
   -frounding-math.  */
/* Origin: Joseph Myers <joseph@codesourcery.com> */
/* { dg-do compile } */
/* { dg-options ""-std=iso9899:1999 -pedantic-errors -frounding-math"" } */
/* { dg-require-effective-target alloca } */

void
f (void)
{
  /* With -frounding-math, presume that floating-point expressions
     that may depend on the rounding mode do not count as arithmetic
     constant expressions, and so arrays involving such expressions in
     their sizes do not have the size checked for being negative.  */
  int a1[(int)(-5.0/3.0)];
}
","/* Test for constant expressions: VLA size constraints with
   -frounding-math.  */
/* Origin: Joseph Myers <joseph@codesourcery.com> */
/* { dg-do compile } */
/* { dg-options ""-std=iso9899:1999 -pedantic-errors -frounding-math"" } */
/* { dg-require-effective-target alloca } */

void
f (void)
{
  /* With -frounding-math, presume that floating-point expressions
     that may depend on the rounding mode do not count as arithmetic
     constant expressions, and so arrays involving such expressions in
     their sizes do not have the size checked for being negative.  */
  int a1[(int)(-5.0/3.0)];
}
"
"struct s
{
  int e;
} x;

struct rbuf
{
  struct s *p __attribute__ ((packed));
} *b;

f ()
{
  b->p = &x;
}
","struct s
{
  int e;
} x;

struct rbuf
{
  struct s *p __attribute__ ((packed));
} *b;

f ()
{
  b->p = &x;
}
"
"/* PR target/79487 */
/* { dg-options ""-O2"" } */

int
main ()
{
  _Decimal32 a = (-9223372036854775807LL - 1LL); 
  _Decimal32 b = -9.223372E+18DF;
  if (b - a != 0.0DF)
    __builtin_abort ();
  _Decimal64 c = (-9223372036854775807LL - 1LL); 
  _Decimal64 d = -9.223372036854776E+18DD;
  if (d - c != 0.0DD)
    __builtin_abort ();
  return 0;
}
","/* PR target/79487 */
/* { dg-options ""-O2"" } */

int
main ()
{
  _Decimal32 a = (-9223372036854775807LL - 1LL); 
  _Decimal32 b = -9.223372E+18DF;
  if (b - a != 0.0DF)
    __builtin_abort ();
  _Decimal64 c = (-9223372036854775807LL - 1LL); 
  _Decimal64 d = -9.223372036854776E+18DD;
  if (d - c != 0.0DD)
    __builtin_abort ();
  return 0;
}
"
"/* PR target/51106 */
/* { dg-do ""compile"" } */
/* { dg-skip-if ""RTL error"" { ""*-*-*"" } { ""-fno-fat-lto-objects"" } { """" } } */

int
foo (int x)
{
  asm goto ("""" : : ""i"" (x) : : lab); /* { dg-error ""impossible constraint"" } */
  /* { dg-warning ""probably doesn.t match constraints"" """" { target *-*-* } .-1 } */
  return 1;
lab:
  return 0;
}

","/* PR target/51106 */
/* { dg-do ""compile"" } */
/* { dg-skip-if ""RTL error"" { ""*-*-*"" } { ""-fno-fat-lto-objects"" } { """" } } */

int
foo (int x)
{
  asm goto ("""" : : ""i"" (x) : : lab); /* { dg-error ""impossible constraint"" } */
  /* { dg-warning ""probably doesn.t match constraints"" """" { target *-*-* } .-1 } */
  return 1;
lab:
  return 0;
}

"
"/* { dg-do run } */
/* { dg-options ""-mavx2 -O2"" } */
/* { dg-require-effective-target avx2 } */

#include ""avx2-check.h""

static void
compute_pminsb256 (char *s1, char *s2, char *r)
{
  int i;

  for (i = 0; i < 32; i++)
    r[i] = s1[i] < s2[i] ? s1[i] : s2[i];
}

static void
avx2_test (void)
{
  union256i_b s1, s2, res;
  char res_ref[32];
  int i, j, sign = 1;
  int fail = 0;

  for (i = 0; i < 10; i++)
    {
      for (j = 0; j < 32; j++)
	{
	  s1.a[j] = j * i * sign;
	  s2.a[j] = (i + 20) * sign;
	  sign = -sign;
	}

      res.x = _mm256_min_epi8 (s1.x, s2.x);

      compute_pminsb256 (s1.a, s2.a, res_ref);

      fail += check_union256i_b (res, res_ref);
    }

  if (fail != 0)
    abort ();
}
","/* { dg-do run } */
/* { dg-options ""-mavx2 -O2"" } */
/* { dg-require-effective-target avx2 } */

#include ""avx2-check.h""

static void
compute_pminsb256 (char *s1, char *s2, char *r)
{
  int i;

  for (i = 0; i < 32; i++)
    r[i] = s1[i] < s2[i] ? s1[i] : s2[i];
}

static void
avx2_test (void)
{
  union256i_b s1, s2, res;
  char res_ref[32];
  int i, j, sign = 1;
  int fail = 0;

  for (i = 0; i < 10; i++)
    {
      for (j = 0; j < 32; j++)
	{
	  s1.a[j] = j * i * sign;
	  s2.a[j] = (i + 20) * sign;
	  sign = -sign;
	}

      res.x = _mm256_min_epi8 (s1.x, s2.x);

      compute_pminsb256 (s1.a, s2.a, res_ref);

      fail += check_union256i_b (res, res_ref);
    }

  if (fail != 0)
    abort ();
}
"
"/* { dg-do compile } */
/* { dg-additional-options ""-Ofast -funroll-loops"" } */

typedef unsigned char uchar;
typedef struct rgb_ {uchar r; uchar g; uchar b;} rgb;
#define N 512
rgb in[N], out[N];
float c[N];
void foo(int n)
{
  int i, j;
  for (i = 0; i < n; i++) //in and out are RGB byte arrays
    {
      float r = 0, g = 0, b = 0;
      for (j = 0; j < 5; j++)
	{
	  r += (float)in[i + j].r * c[j];
	  g += (float)in[i + j].g * c[j];
	  b += (float)in[i + j].b * c[j];
	}
      out[i].r = (uchar)r;
      out[i].g = (uchar)g;
      out[i].b = (uchar)b;
    }
}

/* { dg-final { scan-tree-dump ""vectorized 1 loops in function"" ""vect"" { target { vect_float && vect_intfloat_cvt } } } } */
","/* { dg-do compile } */
/* { dg-additional-options ""-Ofast -funroll-loops"" } */

typedef unsigned char uchar;
typedef struct rgb_ {uchar r; uchar g; uchar b;} rgb;
#define N 512
rgb in[N], out[N];
float c[N];
void foo(int n)
{
  int i, j;
  for (i = 0; i < n; i++) //in and out are RGB byte arrays
    {
      float r = 0, g = 0, b = 0;
      for (j = 0; j < 5; j++)
	{
	  r += (float)in[i + j].r * c[j];
	  g += (float)in[i + j].g * c[j];
	  b += (float)in[i + j].b * c[j];
	}
      out[i].r = (uchar)r;
      out[i].g = (uchar)g;
      out[i].b = (uchar)b;
    }
}

/* { dg-final { scan-tree-dump ""vectorized 1 loops in function"" ""vect"" { target { vect_float && vect_intfloat_cvt } } } } */
"
"/* { dg-do link } */
/* { dg-options ""-O2"" } */

extern int link_error (int);

int tst2 (int x, int y)
{
  /* VRP should be able to extract range information for
     x and y out of this TRUTH_AND_EXPR.  */
  if ((x > 5555) && (y < 6666))
    {
      if (x > 5555)
        if (y < 6666)
          return 1111;
        else
          return link_error (2222);
      else
        if (y < 6666)
          return link_error (3333);
        else
          return link_error (4444);
    }
  else
    return 0;
}

int main()
{
  return 0;
}
","/* { dg-do link } */
/* { dg-options ""-O2"" } */

extern int link_error (int);

int tst2 (int x, int y)
{
  /* VRP should be able to extract range information for
     x and y out of this TRUTH_AND_EXPR.  */
  if ((x > 5555) && (y < 6666))
    {
      if (x > 5555)
        if (y < 6666)
          return 1111;
        else
          return link_error (2222);
      else
        if (y < 6666)
          return link_error (3333);
        else
          return link_error (4444);
    }
  else
    return 0;
}

int main()
{
  return 0;
}
"
"/* { dg-do compile } */
/* { dg-options ""-fstrict-overflow -O2 -fdump-tree-optimized"" } */

/* Source: Ian Lance Taylor.  Dual of no-strict-overflow-2.c.  */

/* We can only simplify the division when using strict overflow
   semantics.  */

int
foo (int i)
{
  return (i * 100) / 10;
}

/* { dg-final { scan-tree-dump-not ""\\\* 100"" ""optimized"" } } */
","/* { dg-do compile } */
/* { dg-options ""-fstrict-overflow -O2 -fdump-tree-optimized"" } */

/* Source: Ian Lance Taylor.  Dual of no-strict-overflow-2.c.  */

/* We can only simplify the division when using strict overflow
   semantics.  */

int
foo (int i)
{
  return (i * 100) / 10;
}

/* { dg-final { scan-tree-dump-not ""\\\* 100"" ""optimized"" } } */
"
"/* PR target/84700 */
/* { dg-do compile } */
/* { dg-options ""-O1 -misel"" } */

long long int
foo (long long int x)
{
  long long int a = x < 2;
  int b = a >= 0;

  return a + ((x == 0) ? a : b);
}
","/* PR target/84700 */
/* { dg-do compile } */
/* { dg-options ""-O1 -misel"" } */

long long int
foo (long long int x)
{
  long long int a = x < 2;
  int b = a >= 0;

  return a + ((x == 0) ? a : b);
}
"
"/* { dg-require-effective-target vect_int } */

#include ""tree-vect.h""

int a[32];

void __attribute__((noinline))
test1(void)
{
  a[0] = 1;
  a[1] = 1;
  a[2] = 1;
  a[3] = 1;
  a[4] = 1;
  a[5] = 1;
  a[6] = 1;
  a[7] = 1;
  a[8] = 1;
  a[9] = 1;
  a[10] = 1;
  a[11] = 1;
  a[12] = 1;
  a[13] = 1;
  a[14] = 1;
  a[15] = 1;
  a[16] = 1;
  a[17] = 1;
  a[18] = 1;
  a[19] = 1;
  a[20] = 1;
  a[21] = 1;
  a[22] = 1;
  a[23] = 1;
  a[24] = 1;
  a[25] = 1;
  a[26] = 1;
  a[27] = 1;
  a[28] = 1;
  a[29] = 1;
  a[30] = 1;
  a[31] = 1;
  asm ("""" : : : ""memory"");
  a[21] = 0;
}

int main()
{ 
  check_vect ();
  test1();
  return a[21];
}

/* { dg-final { scan-tree-dump-times ""basic block vectorized"" 1 ""slp2"" } } */
","/* { dg-require-effective-target vect_int } */

#include ""tree-vect.h""

int a[32];

void __attribute__((noinline))
test1(void)
{
  a[0] = 1;
  a[1] = 1;
  a[2] = 1;
  a[3] = 1;
  a[4] = 1;
  a[5] = 1;
  a[6] = 1;
  a[7] = 1;
  a[8] = 1;
  a[9] = 1;
  a[10] = 1;
  a[11] = 1;
  a[12] = 1;
  a[13] = 1;
  a[14] = 1;
  a[15] = 1;
  a[16] = 1;
  a[17] = 1;
  a[18] = 1;
  a[19] = 1;
  a[20] = 1;
  a[21] = 1;
  a[22] = 1;
  a[23] = 1;
  a[24] = 1;
  a[25] = 1;
  a[26] = 1;
  a[27] = 1;
  a[28] = 1;
  a[29] = 1;
  a[30] = 1;
  a[31] = 1;
  asm ("""" : : : ""memory"");
  a[21] = 0;
}

int main()
{ 
  check_vect ();
  test1();
  return a[21];
}

/* { dg-final { scan-tree-dump-times ""basic block vectorized"" 1 ""slp2"" } } */
"
"/* { dg-do compile } */
/* { dg-options ""-O2"" } */
/* { dg-require-effective-target alloca } */

int y;
extern int foo (int, ...) __attribute__((pure));

int
zzz (char *s1, char *s2, int len, int *q, int c)
{
  int z = 5;
  unsigned int i, b;
  struct s { char a[z]; };
  struct s x;
  int y_tmp = 5;

  for (i = 0; i < len; i++)
    s1[i] = s2[i];

  b = z & 0x3;

  len += (b == 0 ? 0 : 1) + z;

  *q = len;

 if (c)
   y_tmp = foo (z, x, x) + 4;

 z = foo (z, x, x) + 4;
 y = y_tmp;

 return  z;
}
","/* { dg-do compile } */
/* { dg-options ""-O2"" } */
/* { dg-require-effective-target alloca } */

int y;
extern int foo (int, ...) __attribute__((pure));

int
zzz (char *s1, char *s2, int len, int *q, int c)
{
  int z = 5;
  unsigned int i, b;
  struct s { char a[z]; };
  struct s x;
  int y_tmp = 5;

  for (i = 0; i < len; i++)
    s1[i] = s2[i];

  b = z & 0x3;

  len += (b == 0 ? 0 : 1) + z;

  *q = len;

 if (c)
   y_tmp = foo (z, x, x) + 4;

 z = foo (z, x, x) + 4;
 y = y_tmp;

 return  z;
}
"
"/* PR c++/34965 */
/* { dg-do compile } */
/* { dg-options ""-O"" } */

int foo (int);

void
bar (int i, int j, double k)
{
  foo (i && j) ();	/* { dg-error ""\\(i != 0 \\&\\& j != 0\\)"" } */
  foo (!i || !j) ();	/* { dg-error ""\\(i == 0 \\|\\| j == 0\\)"" } */
  foo (!i == !j) ();	/* { dg-error ""\\(i != 0 \\^ j == 0\\)"" } */
}
","/* PR c++/34965 */
/* { dg-do compile } */
/* { dg-options ""-O"" } */

int foo (int);

void
bar (int i, int j, double k)
{
  foo (i && j) ();	/* { dg-error ""\\(i != 0 \\&\\& j != 0\\)"" } */
  foo (!i || !j) ();	/* { dg-error ""\\(i == 0 \\|\\| j == 0\\)"" } */
  foo (!i == !j) ();	/* { dg-error ""\\(i != 0 \\^ j == 0\\)"" } */
}
"
"/* { dg-require-effective-target vect_shift } */
/* { dg-require-effective-target vect_int } */

#include <stdarg.h>
#include ""tree-vect.h""

#define N 8

unsigned int A[N] = { 0x08000000, 0x08000001, 0x0ff0000ff, 0xf0000001,
		      0x08000000, 0x08000001, 0x0ff0000ff, 0xf0000001 };
unsigned int B[N] = { 0x01000000, 0x01000000, 0x01fe0001f, 0x1e000000,
		      0x01000000, 0x01000000, 0x01fe0001f, 0x1e000000 };

int main ()
{
  int i;

  check_vect ();

  for (i = 0; i < N; i++)
    A[i] = A[i] >> 3;

  /* check results:  */
  for (i = 0; i < N; i++)
    if (A[i] != B[i])
      abort ();

  return 0;
}

/* { dg-final { scan-tree-dump-times ""vectorized 1 loops"" 1 ""vect"" } } */
","/* { dg-require-effective-target vect_shift } */
/* { dg-require-effective-target vect_int } */

#include <stdarg.h>
#include ""tree-vect.h""

#define N 8

unsigned int A[N] = { 0x08000000, 0x08000001, 0x0ff0000ff, 0xf0000001,
		      0x08000000, 0x08000001, 0x0ff0000ff, 0xf0000001 };
unsigned int B[N] = { 0x01000000, 0x01000000, 0x01fe0001f, 0x1e000000,
		      0x01000000, 0x01000000, 0x01fe0001f, 0x1e000000 };

int main ()
{
  int i;

  check_vect ();

  for (i = 0; i < N; i++)
    A[i] = A[i] >> 3;

  /* check results:  */
  for (i = 0; i < N; i++)
    if (A[i] != B[i])
      abort ();

  return 0;
}

/* { dg-final { scan-tree-dump-times ""vectorized 1 loops"" 1 ""vect"" } } */
"
"#include <arm_neon.h>

/* { dg-do compile } */
/* { dg-skip-if """" { *-*-* } { ""-fno-fat-lto-objects"" } } */

void
f_vst4_lane_u16 (uint16_t * p, uint16x4x4_t v)
{
  /* { dg-error ""lane 4 out of range 0 - 3"" """" { target *-*-* } 0 } */
  vst4_lane_u16 (p, v, 4);
  /* { dg-error ""lane -1 out of range 0 - 3"" """" { target *-*-* } 0 } */
  vst4_lane_u16 (p, v, -1);
  return;
}
","#include <arm_neon.h>

/* { dg-do compile } */
/* { dg-skip-if """" { *-*-* } { ""-fno-fat-lto-objects"" } } */

void
f_vst4_lane_u16 (uint16_t * p, uint16x4x4_t v)
{
  /* { dg-error ""lane 4 out of range 0 - 3"" """" { target *-*-* } 0 } */
  vst4_lane_u16 (p, v, 4);
  /* { dg-error ""lane -1 out of range 0 - 3"" """" { target *-*-* } 0 } */
  vst4_lane_u16 (p, v, -1);
  return;
}
"
"/* { dg-do compile } */
/* { dg-options ""-mbmi2 -O2 -dp"" } */

#include ""bmi2-bzhi32-1.c""

/* { dg-final { scan-assembler-times ""bmi2_bzhi_si3"" 1 } } */
","/* { dg-do compile } */
/* { dg-options ""-mbmi2 -O2 -dp"" } */

#include ""bmi2-bzhi32-1.c""

/* { dg-final { scan-assembler-times ""bmi2_bzhi_si3"" 1 } } */
"
"#define MASK(N) ((1UL << (N)) - 1)
#define BITS(N) ((1UL << ((N) - 1)) + 2)

#define FUNC(N) void f##N(long j) { if ((j & MASK(N)) >= BITS(N)) abort();}

FUNC(3)
FUNC(4)
FUNC(5)
FUNC(6)
FUNC(7)
FUNC(8)
FUNC(9)
FUNC(10)
FUNC(11)
FUNC(12)
FUNC(13)
FUNC(14)
FUNC(15)
FUNC(16)
FUNC(17)
FUNC(18)
FUNC(19)
FUNC(20)
FUNC(21)
FUNC(22)
FUNC(23)
FUNC(24)
FUNC(25)
FUNC(26)
FUNC(27)
FUNC(28)
FUNC(29)
FUNC(30)
FUNC(31)

int main ()
{
  f3(0);
  f4(0);
  f5(0);
  f6(0);
  f7(0);
  f8(0);
  f9(0);
  f10(0);
  f11(0);
  f12(0);
  f13(0);
  f14(0);
  f15(0);
  f16(0);
  f17(0);
  f18(0);
  f19(0);
  f20(0);
  f21(0);
  f22(0);
  f23(0);
  f24(0);
  f25(0);
  f26(0);
  f27(0);
  f28(0);
  f29(0);
  f30(0);
  f31(0);

  exit(0);
}
","#define MASK(N) ((1UL << (N)) - 1)
#define BITS(N) ((1UL << ((N) - 1)) + 2)

#define FUNC(N) void f##N(long j) { if ((j & MASK(N)) >= BITS(N)) abort();}

FUNC(3)
FUNC(4)
FUNC(5)
FUNC(6)
FUNC(7)
FUNC(8)
FUNC(9)
FUNC(10)
FUNC(11)
FUNC(12)
FUNC(13)
FUNC(14)
FUNC(15)
FUNC(16)
FUNC(17)
FUNC(18)
FUNC(19)
FUNC(20)
FUNC(21)
FUNC(22)
FUNC(23)
FUNC(24)
FUNC(25)
FUNC(26)
FUNC(27)
FUNC(28)
FUNC(29)
FUNC(30)
FUNC(31)

int main ()
{
  f3(0);
  f4(0);
  f5(0);
  f6(0);
  f7(0);
  f8(0);
  f9(0);
  f10(0);
  f11(0);
  f12(0);
  f13(0);
  f14(0);
  f15(0);
  f16(0);
  f17(0);
  f18(0);
  f19(0);
  f20(0);
  f21(0);
  f22(0);
  f23(0);
  f24(0);
  f25(0);
  f26(0);
  f27(0);
  f28(0);
  f29(0);
  f30(0);
  f31(0);

  exit(0);
}
"
"/* { dg-do run } */
/* { dg-options ""-O3 -mpower8-vector -Wno-psabi"" } */
/* { dg-require-effective-target lp64 } */
/* { dg-require-effective-target p8vector_hw } */

#ifndef CHECK_H
#define CHECK_H ""sse2-check.h""
#endif

#include CHECK_H

#ifndef TEST
#define TEST sse2_test_mulsd_1
#endif

#include <emmintrin.h>

static __m128d
__attribute__((noinline, unused))
test (__m128d s1, __m128d s2)
{
  __asm("""" : ""+v""(s1), ""+v""(s2));
  return _mm_mul_sd (s1, s2); 
}

static void
TEST (void)
{
  union128d u, s1, s2;
  double e[2];
   
  s1.x = _mm_set_pd (2134.3343,1234.635654);
  s2.x = _mm_set_pd (41124.234,2344.2354);
  u.x = test (s1.x, s2.x); 
   
  e[0] = s1.a[0] * s2.a[0];
  e[1] = s1.a[1];

  if (check_union128d (u, e))
#if DEBUG
  {
      printf (""sse2_test_mul_sd_1; check_union128d failed\n"");
      printf (""\t [%f,%f] * [%f,%f] -> [%f,%f]\n"", s1.a[0], s1.a[1], s2.a[0],
	      s2.a[1], u.a[0], u.a[1]);
      printf (""\t expect [%f,%f]\n"", e[0], e[1]);
  }
#else
    abort ();
#endif
}
","/* { dg-do run } */
/* { dg-options ""-O3 -mpower8-vector -Wno-psabi"" } */
/* { dg-require-effective-target lp64 } */
/* { dg-require-effective-target p8vector_hw } */

#ifndef CHECK_H
#define CHECK_H ""sse2-check.h""
#endif

#include CHECK_H

#ifndef TEST
#define TEST sse2_test_mulsd_1
#endif

#include <emmintrin.h>

static __m128d
__attribute__((noinline, unused))
test (__m128d s1, __m128d s2)
{
  __asm("""" : ""+v""(s1), ""+v""(s2));
  return _mm_mul_sd (s1, s2); 
}

static void
TEST (void)
{
  union128d u, s1, s2;
  double e[2];
   
  s1.x = _mm_set_pd (2134.3343,1234.635654);
  s2.x = _mm_set_pd (41124.234,2344.2354);
  u.x = test (s1.x, s2.x); 
   
  e[0] = s1.a[0] * s2.a[0];
  e[1] = s1.a[1];

  if (check_union128d (u, e))
#if DEBUG
  {
      printf (""sse2_test_mul_sd_1; check_union128d failed\n"");
      printf (""\t [%f,%f] * [%f,%f] -> [%f,%f]\n"", s1.a[0], s1.a[1], s2.a[0],
	      s2.a[1], u.a[0], u.a[1]);
      printf (""\t expect [%f,%f]\n"", e[0], e[1]);
  }
#else
    abort ();
#endif
}
"
"/* Test _Float128 type-generic built-in functions: __builtin_fpclassify.  */
/* { dg-do run } */
/* { dg-options """" } */
/* { dg-add-options float128 } */
/* { dg-add-options ieee } */
/* { dg-require-effective-target float128_runtime } */

#define WIDTH 128
#define EXT 0
#include ""floatn-tg-3.h""
","/* Test _Float128 type-generic built-in functions: __builtin_fpclassify.  */
/* { dg-do run } */
/* { dg-options """" } */
/* { dg-add-options float128 } */
/* { dg-add-options ieee } */
/* { dg-require-effective-target float128_runtime } */

#define WIDTH 128
#define EXT 0
#include ""floatn-tg-3.h""
"
"/* { dg-do compile } */
/* { dg-options ""-O2 -fdisable-tree-evrp -fdump-tree-vrp1 -fdelete-null-pointer-checks"" } */

int g, h;

int
foo (int a)
{
  int *p;

  if (a)
    p = &g;
  else
    p = &h;

  if (p != 0)
    return 1;
  else
    return 0;
}

/* { dg-final { scan-tree-dump-times ""Folding predicate.*to 1"" 1 ""vrp1"" { target { ! keeps_null_pointer_checks } } } } */
","/* { dg-do compile } */
/* { dg-options ""-O2 -fdisable-tree-evrp -fdump-tree-vrp1 -fdelete-null-pointer-checks"" } */

int g, h;

int
foo (int a)
{
  int *p;

  if (a)
    p = &g;
  else
    p = &h;

  if (p != 0)
    return 1;
  else
    return 0;
}

/* { dg-final { scan-tree-dump-times ""Folding predicate.*to 1"" 1 ""vrp1"" { target { ! keeps_null_pointer_checks } } } } */
"
"/* { dg-do compile } */
/* { dg-options ""-fdump-tree-gimple"" } */

int foo(int i, int j)
{
	char g[16];
	if (&g[i] == &g[j])
		return 1;
	return 0;
}

/* { dg-final { scan-tree-dump-times ""i == j"" 1 ""gimple"" } } */
","/* { dg-do compile } */
/* { dg-options ""-fdump-tree-gimple"" } */

int foo(int i, int j)
{
	char g[16];
	if (&g[i] == &g[j])
		return 1;
	return 0;
}

/* { dg-final { scan-tree-dump-times ""i == j"" 1 ""gimple"" } } */
"
"/* PR tree-optimization/20640 */

/* After unrolling the loop, we'd turn some conditional branches into
   unconditional ones, but branch redirection would fail to compute
   the PHI args for the PHI nodes in the replacement edge
   destination, so they'd remain NULL causing crashes later on.  */

/* { dg-do compile } */

static int a = 0;
extern int foo (void);
extern int *bar (void) __attribute__ ((__const__));

void
test (int x)
{
  int b = 10;
  while (foo () == -1 && *bar () == 4 && b > 0)
    --b;
  a = x;
}
","/* PR tree-optimization/20640 */

/* After unrolling the loop, we'd turn some conditional branches into
   unconditional ones, but branch redirection would fail to compute
   the PHI args for the PHI nodes in the replacement edge
   destination, so they'd remain NULL causing crashes later on.  */

/* { dg-do compile } */

static int a = 0;
extern int foo (void);
extern int *bar (void) __attribute__ ((__const__));

void
test (int x)
{
  int b = 10;
  while (foo () == -1 && *bar () == 4 && b > 0)
    --b;
  a = x;
}
"
"/* { dg-require-effective-target vect_usad_char } */

#include <stdarg.h>
#include ""tree-vect.h""

#define N 64
#define SAD N*N/2

unsigned char X[N] __attribute__ ((__aligned__(__BIGGEST_ALIGNMENT__)));
unsigned char Y[N] __attribute__ ((__aligned__(__BIGGEST_ALIGNMENT__)));
int abs (int);

/* Sum of absolute differences between arrays of unsigned char types.
   Detected as a sad pattern.
   Vectorized on targets that support sad for unsigned chars.  */

__attribute__ ((noinline)) int
foo (int len)
{
  int i;
  int result = 0;

  for (i = 0; i < len; i++)
    result += abs (X[i] - Y[i]);

  return result;
}


int
main (void)
{
  int i;
  int sad;

  check_vect ();

  for (i = 0; i < N; i++)
    {
      X[i] = i;
      Y[i] = N - i;
      __asm__ volatile ("""");
    }

  sad = foo (N);
  if (sad != SAD)
    abort ();

  return 0;
}

/* { dg-final { scan-tree-dump-times ""vect_recog_sad_pattern: detected"" 1 ""vect"" } } */
/* { dg-final { scan-tree-dump-times ""vectorized 1 loops"" 1 ""vect"" } } */

","/* { dg-require-effective-target vect_usad_char } */

#include <stdarg.h>
#include ""tree-vect.h""

#define N 64
#define SAD N*N/2

unsigned char X[N] __attribute__ ((__aligned__(__BIGGEST_ALIGNMENT__)));
unsigned char Y[N] __attribute__ ((__aligned__(__BIGGEST_ALIGNMENT__)));
int abs (int);

/* Sum of absolute differences between arrays of unsigned char types.
   Detected as a sad pattern.
   Vectorized on targets that support sad for unsigned chars.  */

__attribute__ ((noinline)) int
foo (int len)
{
  int i;
  int result = 0;

  for (i = 0; i < len; i++)
    result += abs (X[i] - Y[i]);

  return result;
}


int
main (void)
{
  int i;
  int sad;

  check_vect ();

  for (i = 0; i < N; i++)
    {
      X[i] = i;
      Y[i] = N - i;
      __asm__ volatile ("""");
    }

  sad = foo (N);
  if (sad != SAD)
    abort ();

  return 0;
}

/* { dg-final { scan-tree-dump-times ""vect_recog_sad_pattern: detected"" 1 ""vect"" } } */
/* { dg-final { scan-tree-dump-times ""vectorized 1 loops"" 1 ""vect"" } } */

"
"/* { dg-do compile } */
/* { dg-options ""-mavx512f -O2"" } */
/* { dg-final { scan-assembler-times ""vfnmadd...sd\[ \\t\]+\[^\n\]*\{rn-sae\}\[^\{\n\]*%xmm\[0-9\]+(?:\n|\[ \\t\]+#)"" 1 } } */

#include <immintrin.h>

volatile __m128d a, b, c;

void extern
avx512f_test (void)
{
  a = _mm_fnmadd_round_sd (a, b, c, _MM_FROUND_TO_NEAREST_INT | _MM_FROUND_NO_EXC);
}
","/* { dg-do compile } */
/* { dg-options ""-mavx512f -O2"" } */
/* { dg-final { scan-assembler-times ""vfnmadd...sd\[ \\t\]+\[^\n\]*\{rn-sae\}\[^\{\n\]*%xmm\[0-9\]+(?:\n|\[ \\t\]+#)"" 1 } } */

#include <immintrin.h>

volatile __m128d a, b, c;

void extern
avx512f_test (void)
{
  a = _mm_fnmadd_round_sd (a, b, c, _MM_FROUND_TO_NEAREST_INT | _MM_FROUND_NO_EXC);
}
"
"/* { dg-do compile } */
/* { dg-options ""-mavx512f -O2"" } */
/* { dg-final { scan-assembler-times ""vmovntps\[ \\t\]+\[^\{\n\]*%zmm\[0-9\]+\[^\n\]*\\)(?:\n|\[ \\t\]+#)"" 1 } } */

#include <immintrin.h>

float *x;
volatile __m512 y;

void extern
avx512f_test (void)
{
  _mm512_stream_ps (x, y);
}
","/* { dg-do compile } */
/* { dg-options ""-mavx512f -O2"" } */
/* { dg-final { scan-assembler-times ""vmovntps\[ \\t\]+\[^\{\n\]*%zmm\[0-9\]+\[^\n\]*\\)(?:\n|\[ \\t\]+#)"" 1 } } */

#include <immintrin.h>

float *x;
volatile __m512 y;

void extern
avx512f_test (void)
{
  _mm512_stream_ps (x, y);
}
"
"/* { dg-do run } */
/* { dg-require-effective-target arm_v8_2a_fp16_scalar_hw } */
/* { dg-add-options arm_v8_2a_fp16_scalar }  */
/* { dg-skip-if """" { arm*-*-* } } */

#include <arm_fp16.h>

/* Input values.  */
float16_t input[] = { 123.9, -56.8, 0.7, 24.6, -63.5, 169.4, -4.3, 77.0 };
int64_t expected[] = { 124, -57, 1, 25, -64, 169, -4, 77 };

#define TEST_MSG ""VCVTAH_S64_F16""
#define INSN_NAME vcvtah_s64_f16

#define INPUT input
#define EXPECTED expected

#define INPUT_TYPE float16_t
#define OUTPUT_TYPE int64_t
#define OUTPUT_TYPE_SIZE 64

/* Include the template for unary scalar operations.  */
#include ""unary_scalar_op.inc""
","/* { dg-do run } */
/* { dg-require-effective-target arm_v8_2a_fp16_scalar_hw } */
/* { dg-add-options arm_v8_2a_fp16_scalar }  */
/* { dg-skip-if """" { arm*-*-* } } */

#include <arm_fp16.h>

/* Input values.  */
float16_t input[] = { 123.9, -56.8, 0.7, 24.6, -63.5, 169.4, -4.3, 77.0 };
int64_t expected[] = { 124, -57, 1, 25, -64, 169, -4, 77 };

#define TEST_MSG ""VCVTAH_S64_F16""
#define INSN_NAME vcvtah_s64_f16

#define INPUT input
#define EXPECTED expected

#define INPUT_TYPE float16_t
#define OUTPUT_TYPE int64_t
#define OUTPUT_TYPE_SIZE 64

/* Include the template for unary scalar operations.  */
#include ""unary_scalar_op.inc""
"
"/* { dg-do compile } */
/* { dg-options ""-O2 -mavx"" } */

#include <immintrin.h>

struct S
{
  __m128 a, b;
};

struct T
{
  int a;
  struct S s[8];
};


void foo (struct T *p, int i, __m128 v)
{
  struct S s;

  s = p->s[i];
  s.b = _mm_add_ps(s.b, v);
  p->s[i] = s;
}

/* { dg-final { scan-assembler-not ""vmovups"" } } */
","/* { dg-do compile } */
/* { dg-options ""-O2 -mavx"" } */

#include <immintrin.h>

struct S
{
  __m128 a, b;
};

struct T
{
  int a;
  struct S s[8];
};


void foo (struct T *p, int i, __m128 v)
{
  struct S s;

  s = p->s[i];
  s.b = _mm_add_ps(s.b, v);
  p->s[i] = s;
}

/* { dg-final { scan-assembler-not ""vmovups"" } } */
"
"/* { dg-do compile } */
/* { dg-options ""-O3 -msse2 -mno-avx"" } */

void fill(unsigned char __seg_gs *arr, unsigned char c, long n)
{
  for (long i = 0; i < n; ++i)
    arr[i] = c;
}

/* { dg-final { scan-assembler ""mov\[au\]p.\[ \t\]\[^,\]+, %gs:"" } } */
","/* { dg-do compile } */
/* { dg-options ""-O3 -msse2 -mno-avx"" } */

void fill(unsigned char __seg_gs *arr, unsigned char c, long n)
{
  for (long i = 0; i < n; ++i)
    arr[i] = c;
}

/* { dg-final { scan-assembler ""mov\[au\]p.\[ \t\]\[^,\]+, %gs:"" } } */
"
"/* Test AAPCS layout (VFP variant)  */

/* { dg-do run { target arm_eabi } }  */
/* { dg-require-effective-target arm_hard_vfp_ok }  */
/* { dg-require-effective-target arm_fp16_hw }  */
/* { dg-add-options arm_fp16_alternative }  */

#ifndef IN_FRAMEWORK
#define VFP
#define TESTFILE ""vfp25.c""

#define PCSATTR __attribute__((pcs(""aapcs"")))

#include ""abitest.h""
#else
#if defined (__ARM_BIG_ENDIAN)
ARG (__fp16, 1.0f, R0 + 2)
#else
ARG (__fp16, 1.0f, R0)
#endif
ARG (double, 2.0, R2)
ARG (__fp16, 3.0f, STACK)
ARG (float, 2.0f, STACK+4)
LAST_ARG (double, 4.0, STACK+8)
#endif
","/* Test AAPCS layout (VFP variant)  */

/* { dg-do run { target arm_eabi } }  */
/* { dg-require-effective-target arm_hard_vfp_ok }  */
/* { dg-require-effective-target arm_fp16_hw }  */
/* { dg-add-options arm_fp16_alternative }  */

#ifndef IN_FRAMEWORK
#define VFP
#define TESTFILE ""vfp25.c""

#define PCSATTR __attribute__((pcs(""aapcs"")))

#include ""abitest.h""
#else
#if defined (__ARM_BIG_ENDIAN)
ARG (__fp16, 1.0f, R0 + 2)
#else
ARG (__fp16, 1.0f, R0)
#endif
ARG (double, 2.0, R2)
ARG (__fp16, 3.0f, STACK)
ARG (float, 2.0f, STACK+4)
LAST_ARG (double, 4.0, STACK+8)
#endif
"
"/* { dg-do compile { target { powerpc*-*-* } } } */
/* { dg-skip-if ""do not override -mcpu"" { powerpc*-*-* } { ""-mcpu=*"" } { ""-mcpu=power8"" } } */
/* { dg-require-effective-target powerpc_p9vector_ok } */
/* { dg-options ""-mcpu=power8"" } */

#include <altivec.h>

int
test_all_not_equal_and_not_zero (vector unsigned short *arg1_p,
				 vector unsigned short *arg2_p)
{
  vector unsigned short arg_1 = *arg1_p;
  vector unsigned short arg_2 = *arg2_p;

  return __builtin_vec_vcmpnez_p (__CR6_LT, arg_1, arg_2);	/* { dg-error ""builtin function '__builtin_vec_vcmpnez_p' not supported in this compiler configuration"" } */
}
","/* { dg-do compile { target { powerpc*-*-* } } } */
/* { dg-skip-if ""do not override -mcpu"" { powerpc*-*-* } { ""-mcpu=*"" } { ""-mcpu=power8"" } } */
/* { dg-require-effective-target powerpc_p9vector_ok } */
/* { dg-options ""-mcpu=power8"" } */

#include <altivec.h>

int
test_all_not_equal_and_not_zero (vector unsigned short *arg1_p,
				 vector unsigned short *arg2_p)
{
  vector unsigned short arg_1 = *arg1_p;
  vector unsigned short arg_2 = *arg2_p;

  return __builtin_vec_vcmpnez_p (__CR6_LT, arg_1, arg_2);	/* { dg-error ""builtin function '__builtin_vec_vcmpnez_p' not supported in this compiler configuration"" } */
}
"
"/* PR target/66560 */
/* { dg-do compile } */
/* { dg-options ""-O2 -msse4"" } */

typedef double v2df __attribute__((vector_size(16)));
typedef long long v2di __attribute__((vector_size(16)));
v2df foo1 (v2df x, v2df y)
{
  v2df tem0 = x - y;
  v2df tem1 = x + y;
  return __builtin_shuffle (tem0, tem1, (v2di) { 0, 3 });
}

v2df foo2 (v2df x, v2df y)
{
  v2df tem0 = x - y;
  v2df tem1 = y + x;
  return __builtin_shuffle (tem0, tem1, (v2di) { 0, 3 });
}

v2df foo3 (v2df x, v2df y)
{
  v2df tem0 = x + y;
  v2df tem1 = x - y;
  return __builtin_shuffle (tem0, tem1, (v2di) { 2, 1 });
}

v2df foo4 (v2df x, v2df y)
{
  v2df tem0 = y + x;
  v2df tem1 = x - y;
  return __builtin_shuffle (tem0, tem1, (v2di) { 2, 1 });
}

/* { dg-final { scan-assembler-times ""addsubpd"" 4 } } */
","/* PR target/66560 */
/* { dg-do compile } */
/* { dg-options ""-O2 -msse4"" } */

typedef double v2df __attribute__((vector_size(16)));
typedef long long v2di __attribute__((vector_size(16)));
v2df foo1 (v2df x, v2df y)
{
  v2df tem0 = x - y;
  v2df tem1 = x + y;
  return __builtin_shuffle (tem0, tem1, (v2di) { 0, 3 });
}

v2df foo2 (v2df x, v2df y)
{
  v2df tem0 = x - y;
  v2df tem1 = y + x;
  return __builtin_shuffle (tem0, tem1, (v2di) { 0, 3 });
}

v2df foo3 (v2df x, v2df y)
{
  v2df tem0 = x + y;
  v2df tem1 = x - y;
  return __builtin_shuffle (tem0, tem1, (v2di) { 2, 1 });
}

v2df foo4 (v2df x, v2df y)
{
  v2df tem0 = y + x;
  v2df tem1 = x - y;
  return __builtin_shuffle (tem0, tem1, (v2di) { 2, 1 });
}

/* { dg-final { scan-assembler-times ""addsubpd"" 4 } } */
"
"/* { dg-do run } */ 
/* { dg-options ""-O2"" } */

void link_error (void);

struct A
{
  int a;
  int b;
};

struct A a;
const int B = 42;

void foo (int i)
{
  if (i > 10)
    a.a = 42;
  else
    {
      a.b = 21;
      a.a = a.b + 21;
    }

  /* This should be folded to 'if (0)' as a.a and B are both 42.  */
  if (a.a != B)
    link_error ();
}

int
main ()
{
  foo (3);
  return 0;
}
","/* { dg-do run } */ 
/* { dg-options ""-O2"" } */

void link_error (void);

struct A
{
  int a;
  int b;
};

struct A a;
const int B = 42;

void foo (int i)
{
  if (i > 10)
    a.a = 42;
  else
    {
      a.b = 21;
      a.a = a.b + 21;
    }

  /* This should be folded to 'if (0)' as a.a and B are both 42.  */
  if (a.a != B)
    link_error ();
}

int
main ()
{
  foo (3);
  return 0;
}
"
"/* { dg-do compile } */
/* { dg-options ""-ffast-math"" } */

void foo(int n, int nreps, float tdgefa, float tdgesl)
{
  float kflops,ops;
  ops=((2.0*n*n*n)/3.0+2.0*n*n);
  kflops=2.*nreps*ops/(1000.*(tdgefa+tdgesl));

  __builtin_printf (""%f\n"", kflops);
}
","/* { dg-do compile } */
/* { dg-options ""-ffast-math"" } */

void foo(int n, int nreps, float tdgefa, float tdgesl)
{
  float kflops,ops;
  ops=((2.0*n*n*n)/3.0+2.0*n*n);
  kflops=2.*nreps*ops/(1000.*(tdgefa+tdgesl));

  __builtin_printf (""%f\n"", kflops);
}
"
"/* Test for non-lvalue arrays decaying to pointers: in C99 only.  */
/* Origin: Joseph Myers <jsm28@cam.ac.uk> */
/* { dg-do compile } */
/* { dg-options ""-std=iso9899:1999 -pedantic-errors"" } */

struct s { char c[1]; };

extern struct s foo (void);

void
bar (void)
{
  char *t;
  (foo ()).c[0]; /* { dg-bogus ""non-lvalue"" ""array not decaying to lvalue"" } */
  t = (foo ()).c; /* { dg-bogus ""non-lvalue"" ""array not decaying to lvalue"" } */
  (foo ()).c + 1; /* { dg-bogus ""non-lvalue"" ""array not decaying to lvalue"" } */
}
","/* Test for non-lvalue arrays decaying to pointers: in C99 only.  */
/* Origin: Joseph Myers <jsm28@cam.ac.uk> */
/* { dg-do compile } */
/* { dg-options ""-std=iso9899:1999 -pedantic-errors"" } */

struct s { char c[1]; };

extern struct s foo (void);

void
bar (void)
{
  char *t;
  (foo ()).c[0]; /* { dg-bogus ""non-lvalue"" ""array not decaying to lvalue"" } */
  t = (foo ()).c; /* { dg-bogus ""non-lvalue"" ""array not decaying to lvalue"" } */
  (foo ()).c + 1; /* { dg-bogus ""non-lvalue"" ""array not decaying to lvalue"" } */
}
"
"/* { dg-do compile } */
/* { dg-options ""-O2"" } */

/* PR rtl-optimization/78038.
   Make sure ree can gracefully handle extensions of the global
   variable register after a call.  */

typedef void (*test_fptr_t) (void);
void
test_f (void)
{
}
test_fptr_t test_fptr = test_f;

struct test2_s
{
  int f;
};

register struct test2_s *g __asm__(""x28"");

void
do_something ()
{
  test_fptr ();
  struct test2_s *p1 = 0;
  *p1 = *g;
}
","/* { dg-do compile } */
/* { dg-options ""-O2"" } */

/* PR rtl-optimization/78038.
   Make sure ree can gracefully handle extensions of the global
   variable register after a call.  */

typedef void (*test_fptr_t) (void);
void
test_f (void)
{
}
test_fptr_t test_fptr = test_f;

struct test2_s
{
  int f;
};

register struct test2_s *g __asm__(""x28"");

void
do_something ()
{
  test_fptr ();
  struct test2_s *p1 = 0;
  *p1 = *g;
}
"
"/* Test for attribute non-translation.  */
/* { dg-do compile }
   { dg-require-iconv ""IBM1047"" }
   { dg-final { scan-assembler ""foo"" } } */
int walrus __attribute__ ((section ("".foo"")));

int main (void)
{
  return 0;
}
","/* Test for attribute non-translation.  */
/* { dg-do compile }
   { dg-require-iconv ""IBM1047"" }
   { dg-final { scan-assembler ""foo"" } } */
int walrus __attribute__ ((section ("".foo"")));

int main (void)
{
  return 0;
}
"
"/* PR c/7652 */
/* { dg-do compile } */
/* { dg-options ""-Wimplicit-fallthrough"" } */

int
f (int i)
{
  switch (i)
    {
    case -1:
      __attribute__((fallthrough));
    default:
      __attribute__((fallthrough));
    case 1:
      return 6;
    case 2 ... 4:
      __attribute__((fallthrough));
    case 5:
      return 7;
    }
  return 0;
}

int
g (int i)
{
  switch (i)
    {
    case -1:
      __attribute__((used)); /* { dg-warning ""ignored|only attribute"" } */
    default:
      __attribute__((used)); /* { dg-warning ""ignored|only attribute"" } */
    case 1:
      return 6;
    case 2 ... 4:
      __attribute__((used)); /* { dg-warning ""ignored|only attribute"" } */
    case 5:
      return 7;
    }
  return 0;
}
","/* PR c/7652 */
/* { dg-do compile } */
/* { dg-options ""-Wimplicit-fallthrough"" } */

int
f (int i)
{
  switch (i)
    {
    case -1:
      __attribute__((fallthrough));
    default:
      __attribute__((fallthrough));
    case 1:
      return 6;
    case 2 ... 4:
      __attribute__((fallthrough));
    case 5:
      return 7;
    }
  return 0;
}

int
g (int i)
{
  switch (i)
    {
    case -1:
      __attribute__((used)); /* { dg-warning ""ignored|only attribute"" } */
    default:
      __attribute__((used)); /* { dg-warning ""ignored|only attribute"" } */
    case 1:
      return 6;
    case 2 ... 4:
      __attribute__((used)); /* { dg-warning ""ignored|only attribute"" } */
    case 5:
      return 7;
    }
  return 0;
}
"
"/* { dg-do compile } */
/* { dg-options ""-O2"" } */
/* { dg-final { scan-assembler-not ""popcnt"" } } */

int foo (int x)
{
  return __builtin_popcount (x) == 0;
}

","/* { dg-do compile } */
/* { dg-options ""-O2"" } */
/* { dg-final { scan-assembler-not ""popcnt"" } } */

int foo (int x)
{
  return __builtin_popcount (x) == 0;
}

"
"/* PR target/78227 */
/* { dg-do compile } */
/* { dg-options ""-mavx512bw -O0 -Wno-psabi"" } */

typedef signed char V __attribute__((vector_size (64)));
typedef short int W __attribute__((vector_size (64)));

V
foo1 (V v)
{
  return v > 0;
}

V
bar1 (V v)
{
  return v != 0;
}

W
foo2 (W w)
{
  return w > 0;
}

W
bar2 (W w)
{
  return w != 0;
}
","/* PR target/78227 */
/* { dg-do compile } */
/* { dg-options ""-mavx512bw -O0 -Wno-psabi"" } */

typedef signed char V __attribute__((vector_size (64)));
typedef short int W __attribute__((vector_size (64)));

V
foo1 (V v)
{
  return v > 0;
}

V
bar1 (V v)
{
  return v != 0;
}

W
foo2 (W w)
{
  return w > 0;
}

W
bar2 (W w)
{
  return w != 0;
}
"
"/* { dg-do compile { target { powerpc*-*-* } } } */
/* { dg-skip-if ""do not override -mcpu"" { powerpc*-*-* } { ""-mcpu=*"" } { ""-mcpu=power9"" } } */
/* { dg-require-effective-target powerpc_p9vector_ok } */
/* { dg-skip-if """" { powerpc*-*-aix* } } */
/* { dg-options ""-mcpu=power9"" } */

#include <altivec.h>

int doTestBCDSignificance (_Decimal128 *p)
{
  _Decimal128 source = *p;

  if (__builtin_dfp_dtstsfi_ov (63, source))
    return 3;
  else
    return 5;
}

/* { dg-final { scan-assembler	   ""dtstsfiq"" } } */

","/* { dg-do compile { target { powerpc*-*-* } } } */
/* { dg-skip-if ""do not override -mcpu"" { powerpc*-*-* } { ""-mcpu=*"" } { ""-mcpu=power9"" } } */
/* { dg-require-effective-target powerpc_p9vector_ok } */
/* { dg-skip-if """" { powerpc*-*-aix* } } */
/* { dg-options ""-mcpu=power9"" } */

#include <altivec.h>

int doTestBCDSignificance (_Decimal128 *p)
{
  _Decimal128 source = *p;

  if (__builtin_dfp_dtstsfi_ov (63, source))
    return 3;
  else
    return 5;
}

/* { dg-final { scan-assembler	   ""dtstsfiq"" } } */

"
"/* { dg-do assemble } */
/* { dg-require-effective-target 3dnow } */
/* { dg-options ""-O2 -Werror-implicit-function-declaration -march=k8 -m3dnow"" } */
/* { dg-add-options bind_pic_locally } */

/* Test that the intrinsics compile with optimization.  All of them are
   defined as inline functions in mmintrin.h that reference the proper
   builtin functions.  Defining away ""extern"" and ""__inline"" results in
   all of them being compiled as proper functions.  */

#define extern
#define __inline

#include <mm3dnow.h>
","/* { dg-do assemble } */
/* { dg-require-effective-target 3dnow } */
/* { dg-options ""-O2 -Werror-implicit-function-declaration -march=k8 -m3dnow"" } */
/* { dg-add-options bind_pic_locally } */

/* Test that the intrinsics compile with optimization.  All of them are
   defined as inline functions in mmintrin.h that reference the proper
   builtin functions.  Defining away ""extern"" and ""__inline"" results in
   all of them being compiled as proper functions.  */

#define extern
#define __inline

#include <mm3dnow.h>
"
"/* { dg-do compile } */

#include <string.h>
#include <stdlib.h>
void treathead ()
{
  char *a = ';' == '\0' ? : 0;
  if (*a == '=')
    {
      while (*a == (*a == 0) || *a == '\'')
	a++;
      if (strlen (a) < 2)
	abort ();
    }
}
","/* { dg-do compile } */

#include <string.h>
#include <stdlib.h>
void treathead ()
{
  char *a = ';' == '\0' ? : 0;
  if (*a == '=')
    {
      while (*a == (*a == 0) || *a == '\'')
	a++;
      if (strlen (a) < 2)
	abort ();
    }
}
"
"/* Excess precision tests.  Verify excess precision doesn't affect
   actual types.  */
/* { dg-do compile } */
/* { dg-options ""-mfpmath=387 -fexcess-precision=standard"" } */

float f;
double d;

void
test_types (void)
{
  float *fp;
  double *dp;
#define CHECK_FLOAT(E) fp = &(typeof(E)){0}
#define CHECK_DOUBLE(E) dp = &(typeof(E)){0}
  CHECK_FLOAT (f + f);
  CHECK_DOUBLE (d + d);
  CHECK_FLOAT (f * f / f);
  CHECK_DOUBLE (d * d / d);
  CHECK_FLOAT (f ? f - f : f);
  CHECK_DOUBLE (d ? d - d : d);
}
","/* Excess precision tests.  Verify excess precision doesn't affect
   actual types.  */
/* { dg-do compile } */
/* { dg-options ""-mfpmath=387 -fexcess-precision=standard"" } */

float f;
double d;

void
test_types (void)
{
  float *fp;
  double *dp;
#define CHECK_FLOAT(E) fp = &(typeof(E)){0}
#define CHECK_DOUBLE(E) dp = &(typeof(E)){0}
  CHECK_FLOAT (f + f);
  CHECK_DOUBLE (d + d);
  CHECK_FLOAT (f * f / f);
  CHECK_DOUBLE (d * d / d);
  CHECK_FLOAT (f ? f - f : f);
  CHECK_DOUBLE (d ? d - d : d);
}
"
"/* { dg-do run } */
/* { dg-require-effective-target avx } */
/* { dg-options ""-O2 -mfpmath=sse -mavx"" } */

#define CHECK_H ""avx-check.h""
#define TEST avx_test

#include ""sse-unpcklps-1.c""
","/* { dg-do run } */
/* { dg-require-effective-target avx } */
/* { dg-options ""-O2 -mfpmath=sse -mavx"" } */

#define CHECK_H ""avx-check.h""
#define TEST avx_test

#include ""sse-unpcklps-1.c""
"
"/* { dg-do compile } */
/* { dg-require-effective-target fpic } */
/* { dg-options ""-O2 -fPIC"" } */

struct FILE
{
  int x;
};
extern struct FILE __sF[];
extern void bar (struct FILE *);
void dlmalloc_stats() {
   bar ((&__sF[2]));
}
","/* { dg-do compile } */
/* { dg-require-effective-target fpic } */
/* { dg-options ""-O2 -fPIC"" } */

struct FILE
{
  int x;
};
extern struct FILE __sF[];
extern void bar (struct FILE *);
void dlmalloc_stats() {
   bar ((&__sF[2]));
}
"
"/* PR sanitizer/58443 */
/* { dg-do compile } */
/* { dg-options ""-fsanitize=unreachable,integer-divide-by-zero -w"" } */

int
foo (int u, int o)
{
  return u >> o;
}

/* { dg-final { scan-assembler-not ""__ubsan_handle_shift_out_of_bounds"" } } */
","/* PR sanitizer/58443 */
/* { dg-do compile } */
/* { dg-options ""-fsanitize=unreachable,integer-divide-by-zero -w"" } */

int
foo (int u, int o)
{
  return u >> o;
}

/* { dg-final { scan-assembler-not ""__ubsan_handle_shift_out_of_bounds"" } } */
"
"/* PR tree-optimization/56350 */
/* { dg-do compile } */
/* { dg-options ""-O -ftree-vectorize"" } */

int a, b, c;

void
f (void)
{
  for (; c; c++)
    for (b = 0; b < 2; b++)
      a /= 8;
}
","/* PR tree-optimization/56350 */
/* { dg-do compile } */
/* { dg-options ""-O -ftree-vectorize"" } */

int a, b, c;

void
f (void)
{
  for (; c; c++)
    for (b = 0; b < 2; b++)
      a /= 8;
}
"
"/* { dg-do compile } */
/* { dg-options ""-std=c99"" } */

struct A
{
    char str[8];
    void* v;
};

int varf (char* fmt, ...);

void foo (struct A a, struct A b)
{
    varf (""%s%s"", b.str, b.str);
}

long long x64;

void foo2 (long long j0,
           struct A a, struct A b, struct A c, struct A d,
           struct A e, struct A f, struct A g, struct A h, struct A i,
           long long j1)
{
    varf (""%s%s"", i.str, i.str, x64, j1+j0);
}


void foo3 (long long j0,
           struct A a, struct A b, struct A c, struct A d,
           struct A e, struct A f, struct A g, struct A h, struct A i,
           long long j1)
{
    varf (""%s%s"", &i.str, &b.str, x64, j1+j0);
}
","/* { dg-do compile } */
/* { dg-options ""-std=c99"" } */

struct A
{
    char str[8];
    void* v;
};

int varf (char* fmt, ...);

void foo (struct A a, struct A b)
{
    varf (""%s%s"", b.str, b.str);
}

long long x64;

void foo2 (long long j0,
           struct A a, struct A b, struct A c, struct A d,
           struct A e, struct A f, struct A g, struct A h, struct A i,
           long long j1)
{
    varf (""%s%s"", i.str, i.str, x64, j1+j0);
}


void foo3 (long long j0,
           struct A a, struct A b, struct A c, struct A d,
           struct A e, struct A f, struct A g, struct A h, struct A i,
           long long j1)
{
    varf (""%s%s"", &i.str, &b.str, x64, j1+j0);
}
"
"/* { dg-do run { target *-*-linux* *-*-gnu* } } */
/* { dg-options ""-O2 -fdump-tree-strlen"" } */

#define USE_GNU
#include ""strlenopt-31.c""

/* { dg-final { scan-tree-dump-times ""stpcpy \\("" 1 ""strlen"" } } */
/* { dg-final { scan-tree-dump-times ""memcpy \\("" 2 ""strlen"" } } */
/* { dg-final { scan-tree-dump-not ""strlen \\("" ""strlen"" } } */
","/* { dg-do run { target *-*-linux* *-*-gnu* } } */
/* { dg-options ""-O2 -fdump-tree-strlen"" } */

#define USE_GNU
#include ""strlenopt-31.c""

/* { dg-final { scan-tree-dump-times ""stpcpy \\("" 1 ""strlen"" } } */
/* { dg-final { scan-tree-dump-times ""memcpy \\("" 2 ""strlen"" } } */
/* { dg-final { scan-tree-dump-not ""strlen \\("" ""strlen"" } } */
"
"struct A {
  long a;
};

static inline void foo(struct A *x)
{
  __asm__ __volatile__("""" : ""+m""(x->a) : ""r""(x) : ""memory"", ""cc"");
}

static inline void bar(struct A *x)
{
  foo(x);
}

struct B { char buf[640]; struct A a; };
struct B b[32];

int baz(void)
{
  int i;
  struct B *j;
  for (i = 1; i < 32; i++)
    {
      j = &b[i];
      bar(&j->a);
    }
  return 0;
}
","struct A {
  long a;
};

static inline void foo(struct A *x)
{
  __asm__ __volatile__("""" : ""+m""(x->a) : ""r""(x) : ""memory"", ""cc"");
}

static inline void bar(struct A *x)
{
  foo(x);
}

struct B { char buf[640]; struct A a; };
struct B b[32];

int baz(void)
{
  int i;
  struct B *j;
  for (i = 1; i < 32; i++)
    {
      j = &b[i];
      bar(&j->a);
    }
  return 0;
}
"
"/* { dg-do run } */
/* { dg-options ""-O2 -msha"" } */
/* { dg-require-effective-target sha } */

#include ""sha-check.h""
#include ""m128-check.h""
#include <immintrin.h>

static void
compute_sha1msg1 (int *s1, int *s2, int *r)
{
  int w0, w1, w2, w3, w4, w5;

  w0 = s1[3];
  w1 = s1[2];
  w2 = s1[1];
  w3 = s1[0];
  w4 = s2[3];
  w5 = s2[2];

  r[0] = w5 ^ w3;
  r[1] = w4 ^ w2;
  r[2] = w3 ^ w1;
  r[3] = w2 ^ w0;
}

static void
sha_test (void)
{
  union128i_d s1, s2, res;
  int res_ref[4];

  s1.x = _mm_set_epi32 (111, 222, 333, 444);
  s2.x = _mm_set_epi32 (555, 666, 0, 0);

  res.x = _mm_sha1msg1_epu32 (s1.x, s2.x);

  compute_sha1msg1 (s1.a, s2.a, res_ref);

  if (check_union128i_d (res, res_ref))
    abort ();
}
","/* { dg-do run } */
/* { dg-options ""-O2 -msha"" } */
/* { dg-require-effective-target sha } */

#include ""sha-check.h""
#include ""m128-check.h""
#include <immintrin.h>

static void
compute_sha1msg1 (int *s1, int *s2, int *r)
{
  int w0, w1, w2, w3, w4, w5;

  w0 = s1[3];
  w1 = s1[2];
  w2 = s1[1];
  w3 = s1[0];
  w4 = s2[3];
  w5 = s2[2];

  r[0] = w5 ^ w3;
  r[1] = w4 ^ w2;
  r[2] = w3 ^ w1;
  r[3] = w2 ^ w0;
}

static void
sha_test (void)
{
  union128i_d s1, s2, res;
  int res_ref[4];

  s1.x = _mm_set_epi32 (111, 222, 333, 444);
  s2.x = _mm_set_epi32 (555, 666, 0, 0);

  res.x = _mm_sha1msg1_epu32 (s1.x, s2.x);

  compute_sha1msg1 (s1.a, s2.a, res_ref);

  if (check_union128i_d (res, res_ref))
    abort ();
}
"
"/* Undefined behavior from a call to va_arg with a type other than
   that of the argument passed (in particular, with a type such as
   ""float"" that can never be the type of an argument passed through
   ""..."") does not appear until after the va_list expression is
   evaluated.  PR 38483.  */
/* Origin: Joseph Myers <joseph@codesourcery.com> */

#include <stdarg.h>

extern void exit (int);
extern void abort (void);

va_list ap;
float f;

va_list *
foo (void)
{
  exit (0);
  return &ap;
}

void
bar (int i, ...)
{
  va_start (ap, i);
  f = va_arg (*foo (), float);
  va_end (ap);
}

int
main (void)
{
  bar (1, 0);
  abort ();
}
","/* Undefined behavior from a call to va_arg with a type other than
   that of the argument passed (in particular, with a type such as
   ""float"" that can never be the type of an argument passed through
   ""..."") does not appear until after the va_list expression is
   evaluated.  PR 38483.  */
/* Origin: Joseph Myers <joseph@codesourcery.com> */

#include <stdarg.h>

extern void exit (int);
extern void abort (void);

va_list ap;
float f;

va_list *
foo (void)
{
  exit (0);
  return &ap;
}

void
bar (int i, ...)
{
  va_start (ap, i);
  f = va_arg (*foo (), float);
  va_end (ap);
}

int
main (void)
{
  bar (1, 0);
  abort ();
}
"
"/* { dg-do compile } */
/* { dg-options ""-mcpu=ultrasparc -mvis"" } */

long test_array8 (long a, long b)
{
  return __builtin_vis_array8 (a, b);
}

long test_array16 (long a, long b)
{
  return __builtin_vis_array16 (a, b);
}

long test_array32 (long a, long b)
{
  return __builtin_vis_array32 (a, b);
}

/* { dg-final { scan-assembler ""array8\t%"" } } */
/* { dg-final { scan-assembler ""array16\t%"" } } */
/* { dg-final { scan-assembler ""array32\t%"" } } */
","/* { dg-do compile } */
/* { dg-options ""-mcpu=ultrasparc -mvis"" } */

long test_array8 (long a, long b)
{
  return __builtin_vis_array8 (a, b);
}

long test_array16 (long a, long b)
{
  return __builtin_vis_array16 (a, b);
}

long test_array32 (long a, long b)
{
  return __builtin_vis_array32 (a, b);
}

/* { dg-final { scan-assembler ""array8\t%"" } } */
/* { dg-final { scan-assembler ""array16\t%"" } } */
/* { dg-final { scan-assembler ""array32\t%"" } } */
"
"/* { dg-do compile } */

void _mktm_r (long lcltime,  int *res)
{
  long rem = lcltime % ((60L * 60L) * 24L);
  if (rem < 0)
    return;
  while (rem >= ((60L * 60L) * 24L))
      rem -= ((60L * 60L) * 24L);
  *res = (int) (rem % 60L);
}
","/* { dg-do compile } */

void _mktm_r (long lcltime,  int *res)
{
  long rem = lcltime % ((60L * 60L) * 24L);
  if (rem < 0)
    return;
  while (rem >= ((60L * 60L) * 24L))
      rem -= ((60L * 60L) * 24L);
  *res = (int) (rem % 60L);
}
"
"/* { dg-do compile } */
/* { dg-options ""-mavx512f -O2"" } */
/* { dg-final { scan-assembler-times ""vpxord\[ \\t\]+\[^\{\n\]*%zmm\[0-9\]+(?:\n|\[ \\t\]+#)"" 2 } } */
/* { dg-final { scan-assembler-times ""vpxord\[ \\t\]+\[^\{\n\]*%zmm\[0-9\]+\{%k\[1-7\]\}(?:\n|\[ \\t\]+#)"" 1 } } */
/* { dg-final { scan-assembler-times ""vpxord\[ \\t\]+\[^\{\n\]*%zmm\[0-9\]+\{%k\[1-7\]\}\{z\}(?:\n|\[ \\t\]+#)"" 1 } } */

#include <immintrin.h>

volatile __m512i x;
volatile __mmask16 m;

void extern
avx512f_test (void)
{
  x = _mm512_xor_si512 (x, x);
  x = _mm512_xor_epi32 (x, x);
  x = _mm512_mask_xor_epi32 (x, m, x, x);
  x = _mm512_maskz_xor_epi32 (m, x, x);
}
","/* { dg-do compile } */
/* { dg-options ""-mavx512f -O2"" } */
/* { dg-final { scan-assembler-times ""vpxord\[ \\t\]+\[^\{\n\]*%zmm\[0-9\]+(?:\n|\[ \\t\]+#)"" 2 } } */
/* { dg-final { scan-assembler-times ""vpxord\[ \\t\]+\[^\{\n\]*%zmm\[0-9\]+\{%k\[1-7\]\}(?:\n|\[ \\t\]+#)"" 1 } } */
/* { dg-final { scan-assembler-times ""vpxord\[ \\t\]+\[^\{\n\]*%zmm\[0-9\]+\{%k\[1-7\]\}\{z\}(?:\n|\[ \\t\]+#)"" 1 } } */

#include <immintrin.h>

volatile __m512i x;
volatile __mmask16 m;

void extern
avx512f_test (void)
{
  x = _mm512_xor_si512 (x, x);
  x = _mm512_xor_epi32 (x, x);
  x = _mm512_mask_xor_epi32 (x, m, x, x);
  x = _mm512_maskz_xor_epi32 (m, x, x);
}
"
"/* { dg-do run } */
/* { dg-options ""-O2 -mavx512bw -mavx512vl"" } */
/* { dg-require-effective-target avx512vl } */
/* { dg-require-effective-target avx512bw } */

#define AVX512VL
#define AVX512F_LEN 256
#define AVX512F_LEN_HALF 128
#include ""avx512bw-vptestmb-2.c""

#undef AVX512F_LEN
#undef AVX512F_LEN_HALF

#define AVX512F_LEN 128
#define AVX512F_LEN_HALF 128
#include ""avx512bw-vptestmb-2.c""
","/* { dg-do run } */
/* { dg-options ""-O2 -mavx512bw -mavx512vl"" } */
/* { dg-require-effective-target avx512vl } */
/* { dg-require-effective-target avx512bw } */

#define AVX512VL
#define AVX512F_LEN 256
#define AVX512F_LEN_HALF 128
#include ""avx512bw-vptestmb-2.c""

#undef AVX512F_LEN
#undef AVX512F_LEN_HALF

#define AVX512F_LEN 128
#define AVX512F_LEN_HALF 128
#include ""avx512bw-vptestmb-2.c""
"
"/* Test -dead_strip support.  */
/* Contributed by Devang Patel  <dpatel@apple.com>  */

/* { dg-do compile { target *-*-darwin* } } */
/* { dg-options ""-dead_strip"" } */


int
main ()
{
  return 0;
}

","/* Test -dead_strip support.  */
/* Contributed by Devang Patel  <dpatel@apple.com>  */

/* { dg-do compile { target *-*-darwin* } } */
/* { dg-options ""-dead_strip"" } */


int
main ()
{
  return 0;
}

"
"/* { dg-options """" } */
#include <limits.h>

struct s
{
  int i1 : sizeof (int) * CHAR_BIT;
  int i2 : sizeof (int) * CHAR_BIT;
  int i3 : sizeof (int) * CHAR_BIT;
  int i4 : sizeof (int) * CHAR_BIT;
  int i5 : sizeof (int) * CHAR_BIT;
  int i6 : sizeof (int) * CHAR_BIT;
  int i7 : sizeof (int) * CHAR_BIT;
  int i8 : sizeof (int) * CHAR_BIT;
};

int f[sizeof (struct s) != sizeof (int) * 8 ? -1 : 1];
","/* { dg-options """" } */
#include <limits.h>

struct s
{
  int i1 : sizeof (int) * CHAR_BIT;
  int i2 : sizeof (int) * CHAR_BIT;
  int i3 : sizeof (int) * CHAR_BIT;
  int i4 : sizeof (int) * CHAR_BIT;
  int i5 : sizeof (int) * CHAR_BIT;
  int i6 : sizeof (int) * CHAR_BIT;
  int i7 : sizeof (int) * CHAR_BIT;
  int i8 : sizeof (int) * CHAR_BIT;
};

int f[sizeof (struct s) != sizeof (int) * 8 ? -1 : 1];
"
"/* { dg-do compile } */
/* { dg-options ""-mavx512f -O2"" } */
/* { dg-final { scan-assembler-times ""vpcmpud\[ \\t\]+\[^\{\n\]*%zmm\[0-9\]+\[^\n^k\]*%k\[0-7\](?:\n|\[ \\t\]+#)"" 1 } } */
/* { dg-final { scan-assembler-times ""vpcmpud\[ \\t\]+\[^\{\n\]*%zmm\[0-9\]+\[^\n^k\]*%k\[0-7\]\{%k\[0-7\]\}(?:\n|\[ \\t\]+#)"" 1 } } */

#include <immintrin.h>

volatile __m512i x;
volatile __mmask16 m;

void extern
avx512f_test (void)
{
  m = _mm512_cmpgt_epu32_mask (x, x);
  m = _mm512_mask_cmpgt_epu32_mask (3, x, x);
}
","/* { dg-do compile } */
/* { dg-options ""-mavx512f -O2"" } */
/* { dg-final { scan-assembler-times ""vpcmpud\[ \\t\]+\[^\{\n\]*%zmm\[0-9\]+\[^\n^k\]*%k\[0-7\](?:\n|\[ \\t\]+#)"" 1 } } */
/* { dg-final { scan-assembler-times ""vpcmpud\[ \\t\]+\[^\{\n\]*%zmm\[0-9\]+\[^\n^k\]*%k\[0-7\]\{%k\[0-7\]\}(?:\n|\[ \\t\]+#)"" 1 } } */

#include <immintrin.h>

volatile __m512i x;
volatile __mmask16 m;

void extern
avx512f_test (void)
{
  m = _mm512_cmpgt_epu32_mask (x, x);
  m = _mm512_mask_cmpgt_epu32_mask (3, x, x);
}
"
"/* Test for bad uses of 'void' in parameter lists.  */
/* Origin: Joseph Myers <jsm28@cam.ac.uk> */

typedef const void cv;
typedef volatile void vv;

void foo0 (const void); /* { dg-error ""parameter"" ""const void decl"" } */
void foo0a (cv); /* { dg-error ""parameter"" ""const void decl"" } */
void foo1 (volatile void); /* { dg-error ""parameter"" ""volatile void decl"" } */
void foo1a (vv); /* { dg-error ""parameter"" ""volatile void decl"" } */
void foo2 (register void); /* { dg-error ""parameter"" ""register void decl"" } */

void bar0 (const void) { } /* { dg-error ""parameter"" ""const void defn"" } */
void bar0a (cv) { } /* { dg-error ""parameter"" ""const void defn"" } */
void bar1 (volatile void) { } /* { dg-error ""parameter"" ""volatile void defn"" } */
void bar1a (vv) { } /* { dg-error ""parameter"" ""volatile void defn"" } */
void bar2 (register void) { } /* { dg-error ""parameter"" ""register void defn"" } */
","/* Test for bad uses of 'void' in parameter lists.  */
/* Origin: Joseph Myers <jsm28@cam.ac.uk> */

typedef const void cv;
typedef volatile void vv;

void foo0 (const void); /* { dg-error ""parameter"" ""const void decl"" } */
void foo0a (cv); /* { dg-error ""parameter"" ""const void decl"" } */
void foo1 (volatile void); /* { dg-error ""parameter"" ""volatile void decl"" } */
void foo1a (vv); /* { dg-error ""parameter"" ""volatile void decl"" } */
void foo2 (register void); /* { dg-error ""parameter"" ""register void decl"" } */

void bar0 (const void) { } /* { dg-error ""parameter"" ""const void defn"" } */
void bar0a (cv) { } /* { dg-error ""parameter"" ""const void defn"" } */
void bar1 (volatile void) { } /* { dg-error ""parameter"" ""volatile void defn"" } */
void bar1a (vv) { } /* { dg-error ""parameter"" ""volatile void defn"" } */
void bar2 (register void) { } /* { dg-error ""parameter"" ""register void defn"" } */
"
"/* { dg-do run } */
/* { dg-options ""-mavx2 -O2"" } */
/* { dg-require-effective-target avx2 } */

#include ""avx2-check.h""
#include <string.h>

#define NUM 10

static void
init_pbroadcastw256 (short *src, int seed)
{
  int i, sign = 1;

  for (i = 0; i < 8; i++)
    {
      src[i] = (i + seed) * (i + seed) * sign;
      sign = -sign;
    }
}

static void
calc_pbroadcastw256 (short *src, short *dst)
{
  int i;

  for (i = 0; i < 16; i++)
    dst[i] = src[0];
}

static void
avx2_test (void)
{
  union128i_w src;
  union256i_w dst;
  short dst_ref[16];
  int i;

  for (i = 0; i < NUM; i++)
    {
      init_pbroadcastw256 (src.a, i);

      dst.x = _mm256_broadcastw_epi16 (src.x);
      calc_pbroadcastw256 (src.a, dst_ref);

      if (check_union256i_w (dst, dst_ref))
	abort ();
    }
}
","/* { dg-do run } */
/* { dg-options ""-mavx2 -O2"" } */
/* { dg-require-effective-target avx2 } */

#include ""avx2-check.h""
#include <string.h>

#define NUM 10

static void
init_pbroadcastw256 (short *src, int seed)
{
  int i, sign = 1;

  for (i = 0; i < 8; i++)
    {
      src[i] = (i + seed) * (i + seed) * sign;
      sign = -sign;
    }
}

static void
calc_pbroadcastw256 (short *src, short *dst)
{
  int i;

  for (i = 0; i < 16; i++)
    dst[i] = src[0];
}

static void
avx2_test (void)
{
  union128i_w src;
  union256i_w dst;
  short dst_ref[16];
  int i;

  for (i = 0; i < NUM; i++)
    {
      init_pbroadcastw256 (src.a, i);

      dst.x = _mm256_broadcastw_epi16 (src.x);
      calc_pbroadcastw256 (src.a, dst_ref);

      if (check_union256i_w (dst, dst_ref))
	abort ();
    }
}
"
"/* { dg-options -mno-prologue-epilogue } */
void f (void)
{
}
","/* { dg-options -mno-prologue-epilogue } */
void f (void)
{
}
"
"/* { dg-do run } */
/* { dg-options ""-O2 -ffast-math -ftree-vectorize -mavx"" } */
/* { dg-require-effective-target avx } */
/* { dg-skip-if ""no M_PI"" { vxworks_kernel } } */

#define CHECK_H ""avx-check.h""
#define TEST avx_test

#include ""sse4_1-roundf-vec.c""
","/* { dg-do run } */
/* { dg-options ""-O2 -ffast-math -ftree-vectorize -mavx"" } */
/* { dg-require-effective-target avx } */
/* { dg-skip-if ""no M_PI"" { vxworks_kernel } } */

#define CHECK_H ""avx-check.h""
#define TEST avx_test

#include ""sse4_1-roundf-vec.c""
"
"/* { dg-do run } */
/* { dg-skip-if ""Stack alignment is too small"" { hppa*-*-hpux* } } */
/* { dg-require-effective-target alloca } */

#include ""check.h""

#ifndef ALIGNMENT
#define ALIGNMENT	64
#endif

typedef int aligned __attribute__((aligned(ALIGNMENT)));
extern int strncmp (const char *, const char *, size_t);

int global;

void
copy (char *p, int size)
{
  __builtin_strncpy (p, ""good"", size);
}

void
foo (int size)
{
  aligned j;

   __attribute__ ((__noinline__))
  void bar (int size)
    {
      char *p = __builtin_alloca (size + 1);
      aligned i;

      copy (p, size);
      if (strncmp (p, ""good"", size) != 0)
	{
#ifdef DEBUG
	  p[size] = '\0';
	  printf (""Failed: %s != good\n"", p);
#endif
	  abort ();
	}

      if (check_int (&i,  __alignof__(i)) != i)
	abort ();

      if (check_int (&j,  __alignof__(j)) != j)
	abort ();

      j = -20;
    }
  bar (size);

  if (j != -20)
    abort ();

  if (check_int (&j,  __alignof__(j)) != j)
    abort ();
}

int
main()
{
  foo (5);
  return 0;
}
","/* { dg-do run } */
/* { dg-skip-if ""Stack alignment is too small"" { hppa*-*-hpux* } } */
/* { dg-require-effective-target alloca } */

#include ""check.h""

#ifndef ALIGNMENT
#define ALIGNMENT	64
#endif

typedef int aligned __attribute__((aligned(ALIGNMENT)));
extern int strncmp (const char *, const char *, size_t);

int global;

void
copy (char *p, int size)
{
  __builtin_strncpy (p, ""good"", size);
}

void
foo (int size)
{
  aligned j;

   __attribute__ ((__noinline__))
  void bar (int size)
    {
      char *p = __builtin_alloca (size + 1);
      aligned i;

      copy (p, size);
      if (strncmp (p, ""good"", size) != 0)
	{
#ifdef DEBUG
	  p[size] = '\0';
	  printf (""Failed: %s != good\n"", p);
#endif
	  abort ();
	}

      if (check_int (&i,  __alignof__(i)) != i)
	abort ();

      if (check_int (&j,  __alignof__(j)) != j)
	abort ();

      j = -20;
    }
  bar (size);

  if (j != -20)
    abort ();

  if (check_int (&j,  __alignof__(j)) != j)
    abort ();
}

int
main()
{
  foo (5);
  return 0;
}
"
"/* { dg-do compile { target { powerpc*-*-* } } } */
/* { dg-skip-if """" { powerpc*-*-darwin* } } */
/* { dg-require-effective-target ilp32 } */
/* { dg-skip-if ""do not override -mcpu"" { powerpc*-*-* } { ""-mcpu=*"" } { ""-mcpu=power5"" } } */
/* { dg-options ""-O2 -mcpu=power5 -std=c99 -msoft-float"" } */
/* { dg-final { scan-assembler-not ""fmadd"" } } */
/* { dg-final { scan-assembler-not ""xsfmadd"" } } */

/* Test whether -msoft-float turns off the macros math.h uses for
   FP_FAST_FMA{,F,L}.  */
#ifdef __FP_FAST_FMA
#error ""__FP_FAST_FMA should not be defined""
#endif

#ifdef __FP_FAST_FMAF
#error ""__FP_FAST_FMAF should not be defined""
#endif

double
builtin_fma (double b, double c, double d)
{
  return __builtin_fma (b, c, d);			/* bl fma  */
}

float
builtin_fmaf (float b, float c, float d)
{
  return __builtin_fmaf (b, c, -d);			/* bl fmaf */
}
","/* { dg-do compile { target { powerpc*-*-* } } } */
/* { dg-skip-if """" { powerpc*-*-darwin* } } */
/* { dg-require-effective-target ilp32 } */
/* { dg-skip-if ""do not override -mcpu"" { powerpc*-*-* } { ""-mcpu=*"" } { ""-mcpu=power5"" } } */
/* { dg-options ""-O2 -mcpu=power5 -std=c99 -msoft-float"" } */
/* { dg-final { scan-assembler-not ""fmadd"" } } */
/* { dg-final { scan-assembler-not ""xsfmadd"" } } */

/* Test whether -msoft-float turns off the macros math.h uses for
   FP_FAST_FMA{,F,L}.  */
#ifdef __FP_FAST_FMA
#error ""__FP_FAST_FMA should not be defined""
#endif

#ifdef __FP_FAST_FMAF
#error ""__FP_FAST_FMAF should not be defined""
#endif

double
builtin_fma (double b, double c, double d)
{
  return __builtin_fma (b, c, d);			/* bl fma  */
}

float
builtin_fmaf (float b, float c, float d)
{
  return __builtin_fmaf (b, c, -d);			/* bl fmaf */
}
"
"/* PR middle-end/39315  */
/* { dg-do run } */
/* { dg-options ""-O -msse2 -mtune=generic"" } */
/* { dg-require-effective-target sse2_runtime } */
/* { dg-additional-sources pr39315-check.c } */

typedef float __m128 __attribute__ ((__vector_size__ (16)));

extern void bar (__m128 *, int);

void
foo (__m128 *x)
{
  __m128 b __attribute__ ((aligned(128))) = *x;
  bar (&b, __alignof__ (x));
}
","/* PR middle-end/39315  */
/* { dg-do run } */
/* { dg-options ""-O -msse2 -mtune=generic"" } */
/* { dg-require-effective-target sse2_runtime } */
/* { dg-additional-sources pr39315-check.c } */

typedef float __m128 __attribute__ ((__vector_size__ (16)));

extern void bar (__m128 *, int);

void
foo (__m128 *x)
{
  __m128 b __attribute__ ((aligned(128))) = *x;
  bar (&b, __alignof__ (x));
}
"
"#include ""harness.h""

static vector float
f(vector float f32a, vector float f32b, vector float f32c)
{
  f32c = vec_ceil(f32a);
  return vec_vmaddfp(f32a, f32b, f32c);
}

static void test()
{
  check(vec_all_eq(f(((vector float){2,3,5,7}),
		     ((vector float){11,13,17,19}),
		     ((vector float){23,29,31,37})),
		   ((vector float){24, 42, 90, 140})),
	""test"");
}
","#include ""harness.h""

static vector float
f(vector float f32a, vector float f32b, vector float f32c)
{
  f32c = vec_ceil(f32a);
  return vec_vmaddfp(f32a, f32b, f32c);
}

static void test()
{
  check(vec_all_eq(f(((vector float){2,3,5,7}),
		     ((vector float){11,13,17,19}),
		     ((vector float){23,29,31,37})),
		   ((vector float){24, 42, 90, 140})),
	""test"");
}
"
"extern void abort (void);

typedef short fract16;

fract16 foo (fract16 f, short n)
{
  return __builtin_bfin_shl_fr1x16 (f, n);
}

int main ()
{
  fract16 t1;

  t1 = foo (0x1101, 4);
  if (t1 != 0x7fff)
    abort ();

  return 0;
}

","extern void abort (void);

typedef short fract16;

fract16 foo (fract16 f, short n)
{
  return __builtin_bfin_shl_fr1x16 (f, n);
}

int main ()
{
  fract16 t1;

  t1 = foo (0x1101, 4);
  if (t1 != 0x7fff)
    abort ();

  return 0;
}

"
"/* { dg-do run } */
/* { dg-options ""-O2 -mavx512ifma -mavx512vl"" } */
/* { dg-require-effective-target avx512vl } */
/* { dg-require-effective-target avx512ifma } */

#define AVX512VL
#define AVX512F_LEN 256
#define AVX512F_LEN_HALF 128
#include ""avx512ifma-vpmaddluq-2.c""

#undef AVX512F_LEN
#undef AVX512F_LEN_HALF

#define AVX512F_LEN 128
#define AVX512F_LEN_HALF 128
#include ""avx512ifma-vpmaddluq-2.c""
","/* { dg-do run } */
/* { dg-options ""-O2 -mavx512ifma -mavx512vl"" } */
/* { dg-require-effective-target avx512vl } */
/* { dg-require-effective-target avx512ifma } */

#define AVX512VL
#define AVX512F_LEN 256
#define AVX512F_LEN_HALF 128
#include ""avx512ifma-vpmaddluq-2.c""

#undef AVX512F_LEN
#undef AVX512F_LEN_HALF

#define AVX512F_LEN 128
#define AVX512F_LEN_HALF 128
#include ""avx512ifma-vpmaddluq-2.c""
"
"/* Test for constraints on constant expressions.  In C90 it is clear that
   certain constructs are not permitted in unevaluated parts of an
   expression (except in sizeof); in C99 it might fall within implementation
   latitude.
*/
/* Origin: Joseph Myers <jsm28@cam.ac.uk>; inspired by
   http://deja.com/getdoc.xp?AN=524271595&fmt=text by Peter Seebach.
*/
/* { dg-do compile } */
/* { dg-options ""-std=iso9899:1990 -pedantic-errors"" } */

extern int bar (void);

void
foo (void)
{
  int i;
  static int j = (1 ? 0 : (i = 2)); /* { dg-error ""initial"" ""assignment"" } */
  static int k = (1 ? 0 : ++i); /* { dg-error ""initial"" ""increment"" } */
  static int l = (1 ? 0 : --i); /* { dg-error ""initial"" ""decrement"" } */
  static int m = (1 ? 0 : bar ()); /* { dg-error ""initial"" ""function call"" } */
  static int n = (1 ? 0 : (2, 3)); /* { dg-error ""initial"" ""comma"" } */
}
","/* Test for constraints on constant expressions.  In C90 it is clear that
   certain constructs are not permitted in unevaluated parts of an
   expression (except in sizeof); in C99 it might fall within implementation
   latitude.
*/
/* Origin: Joseph Myers <jsm28@cam.ac.uk>; inspired by
   http://deja.com/getdoc.xp?AN=524271595&fmt=text by Peter Seebach.
*/
/* { dg-do compile } */
/* { dg-options ""-std=iso9899:1990 -pedantic-errors"" } */

extern int bar (void);

void
foo (void)
{
  int i;
  static int j = (1 ? 0 : (i = 2)); /* { dg-error ""initial"" ""assignment"" } */
  static int k = (1 ? 0 : ++i); /* { dg-error ""initial"" ""increment"" } */
  static int l = (1 ? 0 : --i); /* { dg-error ""initial"" ""decrement"" } */
  static int m = (1 ? 0 : bar ()); /* { dg-error ""initial"" ""function call"" } */
  static int n = (1 ? 0 : (2, 3)); /* { dg-error ""initial"" ""comma"" } */
}
"
"struct A { char x[1]; };
extern void abort (void);
void __attribute__((noinline,noclone))
foo (struct A a)
{
  if (a.x[0] != 'a')
    abort ();
}
int main ()
{
  struct A a;
  int i;
  for (i = 0; i < 1; ++i)
    a.x[i] = 'a';
  foo (a);
  return 0;
}

","struct A { char x[1]; };
extern void abort (void);
void __attribute__((noinline,noclone))
foo (struct A a)
{
  if (a.x[0] != 'a')
    abort ();
}
int main ()
{
  struct A a;
  int i;
  for (i = 0; i < 1; ++i)
    a.x[i] = 'a';
  foo (a);
  return 0;
}

"
"main ()
{
  int i;
  int f;

  for (i = 0;; i--)
    {
      f = 0;

      if ((i & (i - 1)) == 0)
	{
	  printf (""d"");
	  f = 1;
	}
      if ((i & -i) == i)
	{
	  printf (""t"");
	  f = 1;
	}
      if (f)
	printf (""%d\n"", i);
    }
}
","main ()
{
  int i;
  int f;

  for (i = 0;; i--)
    {
      f = 0;

      if ((i & (i - 1)) == 0)
	{
	  printf (""d"");
	  f = 1;
	}
      if ((i & -i) == i)
	{
	  printf (""t"");
	  f = 1;
	}
      if (f)
	printf (""%d\n"", i);
    }
}
"
"#define LIM1(x) x##0, x##1, x##2, x##3, x##4, x##5, x##6, x##7, x##8, x##9,
#define LIM2(x) LIM1(x##0) LIM1(x##1) LIM1(x##2) LIM1(x##3) LIM1(x##4) \
		LIM1(x##5) LIM1(x##6) LIM1(x##7) LIM1(x##8) LIM1(x##9)
#define LIM3(x) LIM2(x##0) LIM2(x##1) LIM2(x##2) LIM2(x##3) LIM2(x##4) \
		LIM2(x##5) LIM2(x##6) LIM2(x##7) LIM2(x##8) LIM2(x##9)
#define LIM4(x) LIM3(x##0) LIM3(x##1) LIM3(x##2) LIM3(x##3) LIM3(x##4) \
		LIM3(x##5) LIM3(x##6) LIM3(x##7) LIM3(x##8) LIM3(x##9)
#define LIM5(x) LIM4(x##0) LIM4(x##1) LIM4(x##2) LIM4(x##3) LIM4(x##4) \
		LIM4(x##5) LIM4(x##6) LIM4(x##7) LIM4(x##8) LIM4(x##9)
#define LIM6(x) LIM5(x##0) LIM5(x##1) LIM5(x##2) LIM5(x##3) LIM5(x##4) \
		LIM5(x##5) LIM5(x##6) LIM5(x##7) LIM5(x##8) LIM5(x##9)
#define LIM7(x) LIM6(x##0) LIM6(x##1) LIM6(x##2) LIM6(x##3) LIM6(x##4) \
		LIM6(x##5) LIM6(x##6) LIM6(x##7) LIM6(x##8) LIM6(x##9)

enum q21_enum
{
#if __INT_MAX__ >= 100000
  LIM5 (e)
#else
  LIM4 (e)
#endif
};
","#define LIM1(x) x##0, x##1, x##2, x##3, x##4, x##5, x##6, x##7, x##8, x##9,
#define LIM2(x) LIM1(x##0) LIM1(x##1) LIM1(x##2) LIM1(x##3) LIM1(x##4) \
		LIM1(x##5) LIM1(x##6) LIM1(x##7) LIM1(x##8) LIM1(x##9)
#define LIM3(x) LIM2(x##0) LIM2(x##1) LIM2(x##2) LIM2(x##3) LIM2(x##4) \
		LIM2(x##5) LIM2(x##6) LIM2(x##7) LIM2(x##8) LIM2(x##9)
#define LIM4(x) LIM3(x##0) LIM3(x##1) LIM3(x##2) LIM3(x##3) LIM3(x##4) \
		LIM3(x##5) LIM3(x##6) LIM3(x##7) LIM3(x##8) LIM3(x##9)
#define LIM5(x) LIM4(x##0) LIM4(x##1) LIM4(x##2) LIM4(x##3) LIM4(x##4) \
		LIM4(x##5) LIM4(x##6) LIM4(x##7) LIM4(x##8) LIM4(x##9)
#define LIM6(x) LIM5(x##0) LIM5(x##1) LIM5(x##2) LIM5(x##3) LIM5(x##4) \
		LIM5(x##5) LIM5(x##6) LIM5(x##7) LIM5(x##8) LIM5(x##9)
#define LIM7(x) LIM6(x##0) LIM6(x##1) LIM6(x##2) LIM6(x##3) LIM6(x##4) \
		LIM6(x##5) LIM6(x##6) LIM6(x##7) LIM6(x##8) LIM6(x##9)

enum q21_enum
{
#if __INT_MAX__ >= 100000
  LIM5 (e)
#else
  LIM4 (e)
#endif
};
"
"#define X(x) x
int main() { return X(0/* *//* */); }
","#define X(x) x
int main() { return X(0/* *//* */); }
"
"/* Check that addressing modes for atomics are generated as expected.  */
/* { dg-do compile { target { atomic_model_soft_tcb_available } } }  */
/* { dg-options ""-O2 -matomic-model=soft-tcb,gbr-offset=128,strict"" }  */
/* { dg-final { scan-assembler-times ""@\\(16,r\[0-9\]\\)"" 44 } }  */
/* { dg-final { scan-assembler-times ""@\\(8,r\[0-9\]\\)"" 36 } }  */
/* { dg-final { scan-assembler-times ""@\\(4,r\[0-9\]\\)"" 36 } }  */
/* { dg-final { scan-assembler-times ""@\\(16,gbr\\)"" 28 } }  */
/* { dg-final { scan-assembler-times ""@\\(8,gbr\\)"" 28 } }  */
/* { dg-final { scan-assembler-times ""@\\(4,gbr\\)"" 28 } }  */

#include ""pr64661-0.h""
","/* Check that addressing modes for atomics are generated as expected.  */
/* { dg-do compile { target { atomic_model_soft_tcb_available } } }  */
/* { dg-options ""-O2 -matomic-model=soft-tcb,gbr-offset=128,strict"" }  */
/* { dg-final { scan-assembler-times ""@\\(16,r\[0-9\]\\)"" 44 } }  */
/* { dg-final { scan-assembler-times ""@\\(8,r\[0-9\]\\)"" 36 } }  */
/* { dg-final { scan-assembler-times ""@\\(4,r\[0-9\]\\)"" 36 } }  */
/* { dg-final { scan-assembler-times ""@\\(16,gbr\\)"" 28 } }  */
/* { dg-final { scan-assembler-times ""@\\(8,gbr\\)"" 28 } }  */
/* { dg-final { scan-assembler-times ""@\\(4,gbr\\)"" 28 } }  */

#include ""pr64661-0.h""
"
"/* PR optimization/5844
   This testcase was miscompiled because of an rtx sharing bug.  */
/* { dg-do run } */
/* { dg-options ""-O2"" } */
/* { dg-options ""-O2 -mtune=i586"" { target { { i?86-*-* x86_64-*-* } && ia32 } } } */
/* { dg-xfail-if ""doesn't support self-referential initializers"" { nvptx-*-* } } */

struct A
{
  struct A *a;
  int b;
};

struct B
{
  struct A *c;
  unsigned int d;
};

struct A p = { &p, -1 };
struct B q = { &p, 0 };

extern void abort (void);
extern void exit (int);

struct B *
foo (void)
{
  return &q;
}

void
bar (void)
{
  struct B *e = foo ();
  struct A *f = e->c;
  int g = f->b;

  if (++g == 0)
    {
      e->d++;
      e->c = f->a;
    }

  f->b = g;
}

int
main ()
{
  bar ();
  if (p.b != 0 || q.d != 1 || q.c != &p)
    abort ();
  exit (0);
}
","/* PR optimization/5844
   This testcase was miscompiled because of an rtx sharing bug.  */
/* { dg-do run } */
/* { dg-options ""-O2"" } */
/* { dg-options ""-O2 -mtune=i586"" { target { { i?86-*-* x86_64-*-* } && ia32 } } } */
/* { dg-xfail-if ""doesn't support self-referential initializers"" { nvptx-*-* } } */

struct A
{
  struct A *a;
  int b;
};

struct B
{
  struct A *c;
  unsigned int d;
};

struct A p = { &p, -1 };
struct B q = { &p, 0 };

extern void abort (void);
extern void exit (int);

struct B *
foo (void)
{
  return &q;
}

void
bar (void)
{
  struct B *e = foo ();
  struct A *f = e->c;
  int g = f->b;

  if (++g == 0)
    {
      e->d++;
      e->c = f->a;
    }

  f->b = g;
}

int
main ()
{
  bar ();
  if (p.b != 0 || q.d != 1 || q.c != &p)
    abort ();
  exit (0);
}
"
"/* { dg-do compile { target *-*-linux* } } */
/* { dg-options ""-O2 -fno-pic -fno-plt"" } */

extern int bar (void);

int
foo (void)
{
  return bar () + 1;
}

/* { dg-final { scan-assembler ""call\[ \t\]*.bar@GOTPCREL"" { target { ! ia32 } } } } */
/* { dg-final { scan-assembler ""call\[ \t\]*.bar@GOT"" { target { ia32 && got32x_reloc } } } } */
","/* { dg-do compile { target *-*-linux* } } */
/* { dg-options ""-O2 -fno-pic -fno-plt"" } */

extern int bar (void);

int
foo (void)
{
  return bar () + 1;
}

/* { dg-final { scan-assembler ""call\[ \t\]*.bar@GOTPCREL"" { target { ! ia32 } } } } */
/* { dg-final { scan-assembler ""call\[ \t\]*.bar@GOT"" { target { ia32 && got32x_reloc } } } } */
"
"/* PR 3997 */
/* { dg-do run } */
/* { dg-require-alias """" } */

extern void abort (void);
extern void exit (int);

void foo(void)
{
  exit(0);
}

static void bar(void) __attribute__((alias(""foo"")));

int main()
{
  bar();
  abort ();
}
","/* PR 3997 */
/* { dg-do run } */
/* { dg-require-alias """" } */

extern void abort (void);
extern void exit (int);

void foo(void)
{
  exit(0);
}

static void bar(void) __attribute__((alias(""foo"")));

int main()
{
  bar();
  abort ();
}
"
"
unsigned
reg0indreg1 (r0, p1)
     unsigned short  r0;  unsigned short p1;
{
  return (r0 + p1);
}
","
unsigned
reg0indreg1 (r0, p1)
     unsigned short  r0;  unsigned short p1;
{
  return (r0 + p1);
}
"
"/* { dg-do run } */
/* { dg-options ""-O2 -mavx512f"" } */
/* { dg-require-effective-target avx512f } */

#include ""avx512f-check.h""

static __m512d
__attribute__ ((noinline))
foo (double x1, double x2, double x3, double x4,
     double x5, double x6, double x7, double x8)
{
  return _mm512_set_pd (x1, x2, x3, x4, x5, x6, x7, x8);
}

static __m512d
__attribute__ ((noinline))
foo_r (double x1, double x2, double x3, double x4,
       double x5, double x6, double x7, double x8)
{
  return _mm512_setr_pd (x8, x7, x6, x5, x4, x3, x2, x1);
}

static void
avx512f_test (void)
{
  double v[8] = { -3.3, 2.6, 1.48, 9.104, -23.9, -173.37, -13.48, 69.78 };
  union512d res;

  res.x = foo (v[7], v[6], v[5], v[4], v[3], v[2], v[1], v[0]);

  if (check_union512d (res, v))
    abort ();

  res.x = _mm512_setzero_pd ();

  res.x = foo_r (v[7], v[6], v[5], v[4], v[3], v[2], v[1], v[0]);

  if (check_union512d (res, v))
    abort ();
}
","/* { dg-do run } */
/* { dg-options ""-O2 -mavx512f"" } */
/* { dg-require-effective-target avx512f } */

#include ""avx512f-check.h""

static __m512d
__attribute__ ((noinline))
foo (double x1, double x2, double x3, double x4,
     double x5, double x6, double x7, double x8)
{
  return _mm512_set_pd (x1, x2, x3, x4, x5, x6, x7, x8);
}

static __m512d
__attribute__ ((noinline))
foo_r (double x1, double x2, double x3, double x4,
       double x5, double x6, double x7, double x8)
{
  return _mm512_setr_pd (x8, x7, x6, x5, x4, x3, x2, x1);
}

static void
avx512f_test (void)
{
  double v[8] = { -3.3, 2.6, 1.48, 9.104, -23.9, -173.37, -13.48, 69.78 };
  union512d res;

  res.x = foo (v[7], v[6], v[5], v[4], v[3], v[2], v[1], v[0]);

  if (check_union512d (res, v))
    abort ();

  res.x = _mm512_setzero_pd ();

  res.x = foo_r (v[7], v[6], v[5], v[4], v[3], v[2], v[1], v[0]);

  if (check_union512d (res, v))
    abort ();
}
"
"extern int debug_threads;
extern void sigsuspend (void);
void my_waitpid (int flags, int wnohang)
{
  while (1)
    {
      if (flags & 0x80000000)
        {
          if (wnohang)
            break;
          if (debug_threads)
            __builtin_puts (""blocking\n"");
          sigsuspend ();
        }
      flags ^= 0x80000000;
    }
}

","extern int debug_threads;
extern void sigsuspend (void);
void my_waitpid (int flags, int wnohang)
{
  while (1)
    {
      if (flags & 0x80000000)
        {
          if (wnohang)
            break;
          if (debug_threads)
            __builtin_puts (""blocking\n"");
          sigsuspend ();
        }
      flags ^= 0x80000000;
    }
}

"
"/* { dg-do compile } */
/* { dg-options ""-O2 -mavx512vl"" } */
/* { dg-final { scan-assembler-times ""vaddpd\[ \\t\]+\[^\{\n\]*%xmm\[0-9\]+\{%k\[1-7\]\}(?:\n|\[ \\t\]+#)"" 1 } } */
/* { dg-final { scan-assembler-times ""vaddpd\[ \\t\]+\[^\{\n\]*%xmm\[0-9\]+\{%k\[1-7\]\}\{z\}(?:\n|\[ \\t\]+#)"" 1 } } */
/* { dg-final { scan-assembler-times ""vaddpd\[ \\t\]+\[^\{\n\]*%ymm\[0-9\]+\{%k\[1-7\]\}(?:\n|\[ \\t\]+#)"" 1 } } */
/* { dg-final { scan-assembler-times ""vaddpd\[ \\t\]+\[^\{\n\]*%ymm\[0-9\]+\{%k\[1-7\]\}\{z\}(?:\n|\[ \\t\]+#)"" 1 } } */

#include <immintrin.h>

volatile __m128d x128;
volatile __m256d x256;
volatile __mmask8 m;

void extern
avx512vl_test (void)
{
  x128 = _mm_mask_add_pd (x128, m, x128, x128);
  x128 = _mm_maskz_add_pd (m, x128, x128);

  x256 = _mm256_mask_add_pd (x256, m, x256, x256);
  x256 = _mm256_maskz_add_pd (m, x256, x256);
}
","/* { dg-do compile } */
/* { dg-options ""-O2 -mavx512vl"" } */
/* { dg-final { scan-assembler-times ""vaddpd\[ \\t\]+\[^\{\n\]*%xmm\[0-9\]+\{%k\[1-7\]\}(?:\n|\[ \\t\]+#)"" 1 } } */
/* { dg-final { scan-assembler-times ""vaddpd\[ \\t\]+\[^\{\n\]*%xmm\[0-9\]+\{%k\[1-7\]\}\{z\}(?:\n|\[ \\t\]+#)"" 1 } } */
/* { dg-final { scan-assembler-times ""vaddpd\[ \\t\]+\[^\{\n\]*%ymm\[0-9\]+\{%k\[1-7\]\}(?:\n|\[ \\t\]+#)"" 1 } } */
/* { dg-final { scan-assembler-times ""vaddpd\[ \\t\]+\[^\{\n\]*%ymm\[0-9\]+\{%k\[1-7\]\}\{z\}(?:\n|\[ \\t\]+#)"" 1 } } */

#include <immintrin.h>

volatile __m128d x128;
volatile __m256d x256;
volatile __mmask8 m;

void extern
avx512vl_test (void)
{
  x128 = _mm_mask_add_pd (x128, m, x128, x128);
  x128 = _mm_maskz_add_pd (m, x128, x128);

  x256 = _mm256_mask_add_pd (x256, m, x256, x256);
  x256 = _mm256_maskz_add_pd (m, x256, x256);
}
"
"/* { dg-do compile { target { powerpc*-*-* } } } */
/* { dg-skip-if ""do not override -mcpu"" { powerpc*-*-* } { ""-mcpu=*"" } { ""-mcpu=power9"" } } */
/* { dg-require-effective-target powerpc_p9vector_ok } */
/* { dg-options ""-mcpu=power9"" } */

#include <altivec.h>

__vector bool int
get_data_class_flags (__vector float *p, int condition_flag)
{
  __vector float source = *p;

  return vec_test_data_class (source, condition_flag); /* { dg-error ""argument 2 must be a 7-bit unsigned literal"" } */
}
","/* { dg-do compile { target { powerpc*-*-* } } } */
/* { dg-skip-if ""do not override -mcpu"" { powerpc*-*-* } { ""-mcpu=*"" } { ""-mcpu=power9"" } } */
/* { dg-require-effective-target powerpc_p9vector_ok } */
/* { dg-options ""-mcpu=power9"" } */

#include <altivec.h>

__vector bool int
get_data_class_flags (__vector float *p, int condition_flag)
{
  __vector float source = *p;

  return vec_test_data_class (source, condition_flag); /* { dg-error ""argument 2 must be a 7-bit unsigned literal"" } */
}
"
"extern void abort (void);

int test(int n)
{
  struct s { char b[n]; } __attribute__((packed));
  n++;
  return sizeof(struct s);
}

int main()
{
  if (test(123) != 123)
    abort ();
  return 0;
}
","extern void abort (void);

int test(int n)
{
  struct s { char b[n]; } __attribute__((packed));
  n++;
  return sizeof(struct s);
}

int main()
{
  if (test(123) != 123)
    abort ();
  return 0;
}
"
"/* { dg-do run } */
/* { dg-options ""-O3 -mpower8-vector -Wno-psabi"" } */
/* { dg-require-effective-target lp64 } */
/* { dg-require-effective-target p8vector_hw } */

#ifndef CHECK_H
#define CHECK_H ""sse2-check.h""
#endif

#include CHECK_H

#ifndef TEST
#define TEST sse2_test_punpcklbw_1
#endif

#include <emmintrin.h>

static __m128i
__attribute__((noinline, unused))
test (__m128i s1, __m128i s2)
{
  __asm("""" : ""+v""(s1), ""+v""(s2));
  return _mm_unpacklo_epi8 (s1, s2); 
}

static void
TEST (void)
{
  union128i_b u, s1, s2;
  char e[16];
  int i;
   
  s1.x = _mm_set_epi8 (1,2,3,4,10,20,30,90,-80,-40,-100,-15,98, 25, 98,7);
  s2.x = _mm_set_epi8 (88, 44, 33, 22, 11, 98, 76, -100, -34, -78, -39, 6, 3, 4, 5, 119);
  u.x = test (s1.x, s2.x); 
   
  for (i = 0; i < 8; i++)
    {
      e[2*i] = s1.a[i];
      e[2*i + 1] = s2.a[i];
    }

  if (check_union128i_b (u, e))
    abort ();
}
","/* { dg-do run } */
/* { dg-options ""-O3 -mpower8-vector -Wno-psabi"" } */
/* { dg-require-effective-target lp64 } */
/* { dg-require-effective-target p8vector_hw } */

#ifndef CHECK_H
#define CHECK_H ""sse2-check.h""
#endif

#include CHECK_H

#ifndef TEST
#define TEST sse2_test_punpcklbw_1
#endif

#include <emmintrin.h>

static __m128i
__attribute__((noinline, unused))
test (__m128i s1, __m128i s2)
{
  __asm("""" : ""+v""(s1), ""+v""(s2));
  return _mm_unpacklo_epi8 (s1, s2); 
}

static void
TEST (void)
{
  union128i_b u, s1, s2;
  char e[16];
  int i;
   
  s1.x = _mm_set_epi8 (1,2,3,4,10,20,30,90,-80,-40,-100,-15,98, 25, 98,7);
  s2.x = _mm_set_epi8 (88, 44, 33, 22, 11, 98, 76, -100, -34, -78, -39, 6, 3, 4, 5, 119);
  u.x = test (s1.x, s2.x); 
   
  for (i = 0; i < 8; i++)
    {
      e[2*i] = s1.a[i];
      e[2*i + 1] = s2.a[i];
    }

  if (check_union128i_b (u, e))
    abort ();
}
"
"/* { dg-do compile } */
/* { dg-additional-options ""-O1 --param ggc-min-heapsize=0 --param ggc-min-expand=0"" } */

void unscrunch (unsigned char *, int *);

int DES_CBCUpdate(unsigned char * output, int len)
{
  int work[2];
  unsigned int i;
  for(i = 0;i < len/8;i++)
    unscrunch (&output[8*i], work);
}
","/* { dg-do compile } */
/* { dg-additional-options ""-O1 --param ggc-min-heapsize=0 --param ggc-min-expand=0"" } */

void unscrunch (unsigned char *, int *);

int DES_CBCUpdate(unsigned char * output, int len)
{
  int work[2];
  unsigned int i;
  for(i = 0;i < len/8;i++)
    unscrunch (&output[8*i], work);
}
"
"/* { dg-lto-do link } */
/* { dg-require-effective-target vect_simd_clones } */
/* { dg-require-effective-target avx2 } */
/* { dg-lto-options { { -fopenmp-simd -O3 -ffast-math -mavx2 -flto -flto-partition=max } } } */

#define SIZE 4096
float x[SIZE];


#pragma omp declare simd
float
__attribute__ ((noinline))
my_mul (float x, float y) {
  return x * y;
}

__attribute__ ((noinline))
int foo ()
{
  int i = 0;
#pragma omp simd safelen (16)
  for (i = 0; i < SIZE; i++)
    x[i] = my_mul ((float)i, 9932.3323);
  return (int)x[0];
}

int main ()
{
  int i = 0;
  for (i = 0; i < SIZE; i++)
    x[i] = my_mul ((float) i, 9932.3323);
  foo ();
  return (int)x[0];
}

","/* { dg-lto-do link } */
/* { dg-require-effective-target vect_simd_clones } */
/* { dg-require-effective-target avx2 } */
/* { dg-lto-options { { -fopenmp-simd -O3 -ffast-math -mavx2 -flto -flto-partition=max } } } */

#define SIZE 4096
float x[SIZE];


#pragma omp declare simd
float
__attribute__ ((noinline))
my_mul (float x, float y) {
  return x * y;
}

__attribute__ ((noinline))
int foo ()
{
  int i = 0;
#pragma omp simd safelen (16)
  for (i = 0; i < SIZE; i++)
    x[i] = my_mul ((float)i, 9932.3323);
  return (int)x[0];
}

int main ()
{
  int i = 0;
  for (i = 0; i < SIZE; i++)
    x[i] = my_mul ((float) i, 9932.3323);
  foo ();
  return (int)x[0];
}

"
"/* PR tree-optimization/67916 */
/* { dg-do run } */

int a[6], b = 1, d, e;
long long c;
static int f = 1;

void
fn1 (int p1)
{
  b = (b >> 1) & (1 ^ a[(1 ^ p1) & 5]);
}

void
fn2 ()
{
  b = (b >> 1) & (1 ^ a[(b ^ 1) & 1]);
  fn1 (c >> 1 & 5);
  fn1 (c >> 2 & 5);
  fn1 (c >> 4 & 5);
  fn1 (c >> 8 & 5);
}

int
main ()
{
  int i, j;
  for (; d;)
    {
      for (; e;)
	fn2 ();
      f = 0;
    }
  for (i = 0; i < 8; i++)
    {
      if (f)
	i = 9;
      for (j = 0; j < 7; j++)
	fn2 ();
    }

  if (b != 0)
    __builtin_abort ();

  return 0;
}
","/* PR tree-optimization/67916 */
/* { dg-do run } */

int a[6], b = 1, d, e;
long long c;
static int f = 1;

void
fn1 (int p1)
{
  b = (b >> 1) & (1 ^ a[(1 ^ p1) & 5]);
}

void
fn2 ()
{
  b = (b >> 1) & (1 ^ a[(b ^ 1) & 1]);
  fn1 (c >> 1 & 5);
  fn1 (c >> 2 & 5);
  fn1 (c >> 4 & 5);
  fn1 (c >> 8 & 5);
}

int
main ()
{
  int i, j;
  for (; d;)
    {
      for (; e;)
	fn2 ();
      f = 0;
    }
  for (i = 0; i < 8; i++)
    {
      if (f)
	i = 9;
      for (j = 0; j < 7; j++)
	fn2 ();
    }

  if (b != 0)
    __builtin_abort ();

  return 0;
}
"
"/* PR sanitizer/80308 */
/* { dg-do run } */

__attribute__((noinline, noclone)) int
foo (char *a)
{
  int i, j = 0;
  asm volatile ("""" : ""+r"" (a) : : ""memory"");
  for (i = 0; i < 12; i++)
    j += a[i];
  return j;
}

int
main ()
{
  int i, j = 0;
  for (i = 0; i < 4; i++)
    {
      char a[12];
      __builtin_memset (a, 0, sizeof (a));
      j += foo (a);
    }
  return j;
}
","/* PR sanitizer/80308 */
/* { dg-do run } */

__attribute__((noinline, noclone)) int
foo (char *a)
{
  int i, j = 0;
  asm volatile ("""" : ""+r"" (a) : : ""memory"");
  for (i = 0; i < 12; i++)
    j += a[i];
  return j;
}

int
main ()
{
  int i, j = 0;
  for (i = 0; i < 4; i++)
    {
      char a[12];
      __builtin_memset (a, 0, sizeof (a));
      j += foo (a);
    }
  return j;
}
"
"extern void abort (void);

static int inv_J(int a[][2])
{
  int i, j;
  int det = 0.0;
   for (j=0; j<2; ++j)
     det += a[j][0] + a[j][1];
  return det;
}

int foo()
{
  int mat[2][2];
  mat[0][0] = 1;
  mat[0][1] = 2;
  mat[1][0] = 4;
  mat[1][1] = 8;
  return inv_J(mat);
}

int main()
{
  if (foo () != 15)
    abort ();
  return 0;
}

","extern void abort (void);

static int inv_J(int a[][2])
{
  int i, j;
  int det = 0.0;
   for (j=0; j<2; ++j)
     det += a[j][0] + a[j][1];
  return det;
}

int foo()
{
  int mat[2][2];
  mat[0][0] = 1;
  mat[0][1] = 2;
  mat[1][0] = 4;
  mat[1][1] = 8;
  return inv_J(mat);
}

int main()
{
  if (foo () != 15)
    abort ();
  return 0;
}

"
"/* { dg-do compile } */
/* { dg-options ""-Ofast -floop-nest-optimize"" } */

int a, b, c, d, f, g;
int e[1], h[1];
void fn2 ();
void fn3 ();
void
fn1 ()
{
  fn2 ();
  b = 0;
  for (; b < 10; b++)
    ;
}

void
fn2 ()
{
  if (a)
    {
      fn3 ();
      c = d;
    }
}

void
fn3 ()
{
  for (; g; g++)
    e[g] = 2;
  if (f)
    for (; g; g++)
      h[g] = 5;
}
","/* { dg-do compile } */
/* { dg-options ""-Ofast -floop-nest-optimize"" } */

int a, b, c, d, f, g;
int e[1], h[1];
void fn2 ();
void fn3 ();
void
fn1 ()
{
  fn2 ();
  b = 0;
  for (; b < 10; b++)
    ;
}

void
fn2 ()
{
  if (a)
    {
      fn3 ();
      c = d;
    }
}

void
fn3 ()
{
  for (; g; g++)
    e[g] = 2;
  if (f)
    for (; g; g++)
      h[g] = 5;
}
"
"/* { dg-options { -nostartfiles below100.o -Tbelow100.ld -O2 } } */
/* { dg-final { scan-assembler ""set1 32533,#7"" } } */

typedef struct
{
  unsigned short b0:1;
  unsigned short b1:1;
  unsigned short b2:1;
  unsigned short b3:1;
  unsigned short b4:1;
  unsigned short b5:1;
  unsigned short b6:1;
  unsigned short b7:1;
  unsigned short b8:1;
  unsigned short b9:1;
  unsigned short b10:1;
  unsigned short b11:1;
  unsigned short b12:1;
  unsigned short b13:1;
  unsigned short b14:1;
  unsigned short b15:1;
} BitField;

#define SFR (*((volatile BitField*)0x7f14))
unsigned short *p = (unsigned short *) 0x7f14;

void
Do (void)
{
  SFR.b15 = 1;
}

int
main (void)
{
  *p = 0x1234;
  Do ();
  return (*p == 0x9234) ? 0 : 1;
}
","/* { dg-options { -nostartfiles below100.o -Tbelow100.ld -O2 } } */
/* { dg-final { scan-assembler ""set1 32533,#7"" } } */

typedef struct
{
  unsigned short b0:1;
  unsigned short b1:1;
  unsigned short b2:1;
  unsigned short b3:1;
  unsigned short b4:1;
  unsigned short b5:1;
  unsigned short b6:1;
  unsigned short b7:1;
  unsigned short b8:1;
  unsigned short b9:1;
  unsigned short b10:1;
  unsigned short b11:1;
  unsigned short b12:1;
  unsigned short b13:1;
  unsigned short b14:1;
  unsigned short b15:1;
} BitField;

#define SFR (*((volatile BitField*)0x7f14))
unsigned short *p = (unsigned short *) 0x7f14;

void
Do (void)
{
  SFR.b15 = 1;
}

int
main (void)
{
  *p = 0x1234;
  Do ();
  return (*p == 0x9234) ? 0 : 1;
}
"
"typedef int tt;

tt a1;
tt a2;
tt a3;

foo ()
{
  a1++;
  a2++;
  a1++;
}
","typedef int tt;

tt a1;
tt a2;
tt a3;

foo ()
{
  a1++;
  a2++;
  a1++;
}
"
"/* { dg-do compile } */
/* { dg-options ""-mavx512f -O2"" } */
/* { dg-final { scan-assembler-times ""vpmaxuq\[ \\t\]+\[^\{\n\]*%zmm\[0-9\]+(?:\n|\[ \\t\]+#)""  1 } } */
/* { dg-final { scan-assembler-times ""vpmaxuq\[ \\t\]+\[^\{\n\]*%zmm\[0-9\]+\{%k\[1-7\]\}(?:\n|\[ \\t\]+#)"" 1 } } */
/* { dg-final { scan-assembler-times ""vpmaxuq\[ \\t\]+\[^\{\n\]*%zmm\[0-9\]+\{%k\[1-7\]\}\{z\}(?:\n|\[ \\t\]+#)"" 1 } } */

#include <immintrin.h>

volatile __m512i x;
volatile __mmask8 m;

void extern
avx512f_test (void)
{
  x = _mm512_max_epu64 (x, x);
  x = _mm512_mask_max_epu64 (x, m, x, x);
  x = _mm512_maskz_max_epu64 (m, x, x);
}
","/* { dg-do compile } */
/* { dg-options ""-mavx512f -O2"" } */
/* { dg-final { scan-assembler-times ""vpmaxuq\[ \\t\]+\[^\{\n\]*%zmm\[0-9\]+(?:\n|\[ \\t\]+#)""  1 } } */
/* { dg-final { scan-assembler-times ""vpmaxuq\[ \\t\]+\[^\{\n\]*%zmm\[0-9\]+\{%k\[1-7\]\}(?:\n|\[ \\t\]+#)"" 1 } } */
/* { dg-final { scan-assembler-times ""vpmaxuq\[ \\t\]+\[^\{\n\]*%zmm\[0-9\]+\{%k\[1-7\]\}\{z\}(?:\n|\[ \\t\]+#)"" 1 } } */

#include <immintrin.h>

volatile __m512i x;
volatile __mmask8 m;

void extern
avx512f_test (void)
{
  x = _mm512_max_epu64 (x, x);
  x = _mm512_mask_max_epu64 (x, m, x, x);
  x = _mm512_maskz_max_epu64 (m, x, x);
}
"
"/* { dg-require-effective-target size32plus } */
double u[1782225];

void foo(int N, int *res)
{
  int i;
  double a, b;
  double sum = 0.0;

  for (i = 0; i < N; i++)
    sum += u[i];

  for (i = 0; i < N; i++)
    {
      a = u[i];
      u[i] = i * i;
      b = u[i];
      sum += a + b;
    }

  *res = sum + N;
}

/* { dg-final { scan-tree-dump-times ""number of SCoPs: 1"" 1 ""graphite""} } */
","/* { dg-require-effective-target size32plus } */
double u[1782225];

void foo(int N, int *res)
{
  int i;
  double a, b;
  double sum = 0.0;

  for (i = 0; i < N; i++)
    sum += u[i];

  for (i = 0; i < N; i++)
    {
      a = u[i];
      u[i] = i * i;
      b = u[i];
      sum += a + b;
    }

  *res = sum + N;
}

/* { dg-final { scan-tree-dump-times ""number of SCoPs: 1"" 1 ""graphite""} } */
"
"/* PR target/48767 */

void
foo (__builtin_va_list ap)
{
  __builtin_va_arg (ap, void); /* { dg-error ""second argument to .va_arg. is of incomplete type .void."" } */
}
","/* PR target/48767 */

void
foo (__builtin_va_list ap)
{
  __builtin_va_arg (ap, void); /* { dg-error ""second argument to .va_arg. is of incomplete type .void."" } */
}
"
"/* { dg-do run } */
/* { dg-require-effective-target avx2 } */
/* { dg-options ""-O2 -mavx2"" } */

#include <string.h>
#include ""avx2-check.h""

#define N 0x5

static void
compute_punpckhbw256 (char *s1, char *s2, char *r)
{
  int i;

  for (i = 0; i < 8; i++)
    {
      r[2 * i] = s1[i + 8];
      r[2 * i + 1] = s2[i + 8];

      r[2 * i + 16] = s1[i + 24];
      r[2 * i + 16 + 1] = s2[i + 24];
    }
}

void static
avx2_test (void)
{
  union256i_b s1, s2, res;
  char res_ref[32];
  int i, j;
  int fail = 0;

  for (i = 0; i < 10; i++)
    {
      for (j = 0; j < 32; j++)
	{
	  s1.a[j] = j * i;
	  s2.a[j] = j + 20;
	}

      res.x = _mm256_unpackhi_epi8 (s1.x, s2.x);

      compute_punpckhbw256 (s1.a, s2.a, res_ref);

      fail += check_union256i_b (res, res_ref);
    }

  if (fail != 0)
    abort ();
}
","/* { dg-do run } */
/* { dg-require-effective-target avx2 } */
/* { dg-options ""-O2 -mavx2"" } */

#include <string.h>
#include ""avx2-check.h""

#define N 0x5

static void
compute_punpckhbw256 (char *s1, char *s2, char *r)
{
  int i;

  for (i = 0; i < 8; i++)
    {
      r[2 * i] = s1[i + 8];
      r[2 * i + 1] = s2[i + 8];

      r[2 * i + 16] = s1[i + 24];
      r[2 * i + 16 + 1] = s2[i + 24];
    }
}

void static
avx2_test (void)
{
  union256i_b s1, s2, res;
  char res_ref[32];
  int i, j;
  int fail = 0;

  for (i = 0; i < 10; i++)
    {
      for (j = 0; j < 32; j++)
	{
	  s1.a[j] = j * i;
	  s2.a[j] = j + 20;
	}

      res.x = _mm256_unpackhi_epi8 (s1.x, s2.x);

      compute_punpckhbw256 (s1.a, s2.a, res_ref);

      fail += check_union256i_b (res, res_ref);
    }

  if (fail != 0)
    abort ();
}
"
"/* On Darwin, you have to have a definition of the function to link,
   even if later on it won't be present in some dylib.  (That is,
   you have to link with the latest version of the dylib.)  */
void wf1(void) { }
void wf6(void) { }
void wf9(void) { }
void wf10(void) { }
void wf11(void) { }
void wf12(void) { }
void wf13(void) { }
void wf14(void) { }

int wv1;
int wv6;
int wv9;
int wv10;
int wv11;
int wv12;
int wv13;
int wv14;
","/* On Darwin, you have to have a definition of the function to link,
   even if later on it won't be present in some dylib.  (That is,
   you have to link with the latest version of the dylib.)  */
void wf1(void) { }
void wf6(void) { }
void wf9(void) { }
void wf10(void) { }
void wf11(void) { }
void wf12(void) { }
void wf13(void) { }
void wf14(void) { }

int wv1;
int wv6;
int wv9;
int wv10;
int wv11;
int wv12;
int wv13;
int wv14;
"
"#include ""lib/chk.c""
","#include ""lib/chk.c""
"
"/* { dg-do compile } */
/* { dg-options ""-O3"" } */

#pragma GCC target ""+nosve""

int a[30 +1][30 +1], b[30 +1][30 +1], r[30 +1][30 +1];

void foo (void) {
  int i, j, k;

  for ( i = 1; i <= 30; i++ )
    for ( j = 1; j <= 30; j++ ) {
      r[i][j] = 0;
      for(k = 1; k <= 30; k++ )
        r[i][j] += a[i][k]*b[k][j];
    }
}

/* { dg-final { scan-assembler ""ldr\\ts\[0-9\]+, \\\[x\[0-9\]+, \[0-9\]+\\\]!"" } } */
/* { dg-final { scan-assembler ""ldr\\tq\[0-9\]+, \\\[x\[0-9\]+\\\], \[0-9\]+"" } } */
/* { dg-final { scan-assembler ""mla\\tv\[0-9\]+\.4s, v\[0-9\]+\.4s, v\[0-9\]+\.s\\\[0\\\]"" } } */
","/* { dg-do compile } */
/* { dg-options ""-O3"" } */

#pragma GCC target ""+nosve""

int a[30 +1][30 +1], b[30 +1][30 +1], r[30 +1][30 +1];

void foo (void) {
  int i, j, k;

  for ( i = 1; i <= 30; i++ )
    for ( j = 1; j <= 30; j++ ) {
      r[i][j] = 0;
      for(k = 1; k <= 30; k++ )
        r[i][j] += a[i][k]*b[k][j];
    }
}

/* { dg-final { scan-assembler ""ldr\\ts\[0-9\]+, \\\[x\[0-9\]+, \[0-9\]+\\\]!"" } } */
/* { dg-final { scan-assembler ""ldr\\tq\[0-9\]+, \\\[x\[0-9\]+\\\], \[0-9\]+"" } } */
/* { dg-final { scan-assembler ""mla\\tv\[0-9\]+\.4s, v\[0-9\]+\.4s, v\[0-9\]+\.s\\\[0\\\]"" } } */
"
"typedef struct
{
  short v, h;
} S;

S a;

f (S pnt)
{
  S mpnt, mtp;

  (&pnt)->v -= 1;
  mpnt = pnt;
  mtp = a;
  if (mtp.v != mpnt.v)
    {
      S tpnt;

      tpnt = mtp;
      mtp = mpnt;
      mpnt = tpnt;
    }
}
","typedef struct
{
  short v, h;
} S;

S a;

f (S pnt)
{
  S mpnt, mtp;

  (&pnt)->v -= 1;
  mpnt = pnt;
  mtp = a;
  if (mtp.v != mpnt.v)
    {
      S tpnt;

      tpnt = mtp;
      mtp = mpnt;
      mpnt = tpnt;
    }
}
"
"/* { dg-do run } */
/* { dg-options ""-O2 -mavx512bw -mavx512vl"" } */
/* { dg-require-effective-target avx512vl } */
/* { dg-require-effective-target avx512bw } */

#define AVX512VL
#define AVX512F_LEN 256
#define AVX512F_LEN_HALF 128
#include ""avx512bw-vpmulhuw-2.c""

#undef AVX512F_LEN
#undef AVX512F_LEN_HALF

#define AVX512F_LEN 128
#define AVX512F_LEN_HALF 128
#include ""avx512bw-vpmulhuw-2.c""
","/* { dg-do run } */
/* { dg-options ""-O2 -mavx512bw -mavx512vl"" } */
/* { dg-require-effective-target avx512vl } */
/* { dg-require-effective-target avx512bw } */

#define AVX512VL
#define AVX512F_LEN 256
#define AVX512F_LEN_HALF 128
#include ""avx512bw-vpmulhuw-2.c""

#undef AVX512F_LEN
#undef AVX512F_LEN_HALF

#define AVX512F_LEN 128
#define AVX512F_LEN_HALF 128
#include ""avx512bw-vpmulhuw-2.c""
"
"void
f1 (void)
{
  int i, j;
  #pragma omp critical
  {
    #pragma omp simd
    for (i = 0; i < 64; i++)
      {
	#pragma omp ordered simd
	;
      }
  }
  #pragma omp ordered threads
  {
    #pragma omp simd
    for (i = 0; i < 64; i++)
      {
	#pragma omp ordered simd
	;
      }
  }
  #pragma omp task
  {
    #pragma omp simd
    for (i = 0; i < 64; i++)
      {
	#pragma omp ordered simd
	;
      }
  }
  #pragma omp taskloop
  for (j = 0; j < 64; j++)
    #pragma omp simd
    for (i = 0; i < 64; i++)
      {
	#pragma omp ordered simd
	;
      }
}

void
f2 (void)
{
  #pragma omp ordered simd
  ;
}

void
f3 (void)
{
  #pragma omp ordered threads , simd
  ;
}
","void
f1 (void)
{
  int i, j;
  #pragma omp critical
  {
    #pragma omp simd
    for (i = 0; i < 64; i++)
      {
	#pragma omp ordered simd
	;
      }
  }
  #pragma omp ordered threads
  {
    #pragma omp simd
    for (i = 0; i < 64; i++)
      {
	#pragma omp ordered simd
	;
      }
  }
  #pragma omp task
  {
    #pragma omp simd
    for (i = 0; i < 64; i++)
      {
	#pragma omp ordered simd
	;
      }
  }
  #pragma omp taskloop
  for (j = 0; j < 64; j++)
    #pragma omp simd
    for (i = 0; i < 64; i++)
      {
	#pragma omp ordered simd
	;
      }
}

void
f2 (void)
{
  #pragma omp ordered simd
  ;
}

void
f3 (void)
{
  #pragma omp ordered threads , simd
  ;
}
"
"/* { dg-do compile } */
/* { dg-options ""-mavx512f -O2"" } */
/* { dg-final { scan-assembler-times ""vunpcklps\[ \\t\]+\[^\{\n\]*%zmm\[0-9\]+(?:\n|\[ \\t\]+#)""  1 } } */
/* { dg-final { scan-assembler-times ""vunpcklps\[ \\t\]+\[^\{\n\]*%zmm\[0-9\]+\{%k\[1-7\]\}\{z\}(?:\n|\[ \\t\]+#)"" 1 } } */
/* { dg-final { scan-assembler-times ""vunpcklps\[ \\t\]+\[^\{\n\]*%zmm\[0-9\]+\{%k\[1-7\]\}(?:\n|\[ \\t\]+#)"" 1 } } */

#include <immintrin.h>

volatile __m512 x, y, z;

void extern
avx512f_test (void)
{
  x = _mm512_unpacklo_ps (y, z);
  x = _mm512_mask_unpacklo_ps (x, 2, y, z);
  x = _mm512_maskz_unpacklo_ps (2, y, z);
}
","/* { dg-do compile } */
/* { dg-options ""-mavx512f -O2"" } */
/* { dg-final { scan-assembler-times ""vunpcklps\[ \\t\]+\[^\{\n\]*%zmm\[0-9\]+(?:\n|\[ \\t\]+#)""  1 } } */
/* { dg-final { scan-assembler-times ""vunpcklps\[ \\t\]+\[^\{\n\]*%zmm\[0-9\]+\{%k\[1-7\]\}\{z\}(?:\n|\[ \\t\]+#)"" 1 } } */
/* { dg-final { scan-assembler-times ""vunpcklps\[ \\t\]+\[^\{\n\]*%zmm\[0-9\]+\{%k\[1-7\]\}(?:\n|\[ \\t\]+#)"" 1 } } */

#include <immintrin.h>

volatile __m512 x, y, z;

void extern
avx512f_test (void)
{
  x = _mm512_unpacklo_ps (y, z);
  x = _mm512_mask_unpacklo_ps (x, 2, y, z);
  x = _mm512_maskz_unpacklo_ps (2, y, z);
}
"
"/* Functional tests for the ""target"" attribute and pragma.  */

/* { dg-do compile { target { lp64 } } } */
/* { dg-require-effective-target target_attribute } */
/* { dg-options ""-O3 -march=z13 -mno-vx -mno-zvector"" } */

#include <vecintrin.h>

#pragma GCC target(""no-zvector"")
__attribute__ ((target(""vx"")))
void a1(void)
{
#ifdef __VEC__
#error __VEC__ is defined
#endif
  vec_load_bndry ((const signed char *)0, 64);
  __builtin_s390_vll ((unsigned int)0, (const void *)8);
}
#pragma GCC reset_options

__attribute__ ((target(""no-vx"")))
void a0(void)
{
#ifdef __VEC__
#error __VEC__ is defined
#endif
  __builtin_s390_vll ((unsigned int)0, (const void *)8); /* { dg-error ""requires -mvx"" } */
}

void d(void)
{
#ifdef __VEC__
#error __VEC__ is defined
#endif
  __builtin_s390_vll ((unsigned int)0, (const void *)8); /* { dg-error ""requires -mvx"" } */
}
","/* Functional tests for the ""target"" attribute and pragma.  */

/* { dg-do compile { target { lp64 } } } */
/* { dg-require-effective-target target_attribute } */
/* { dg-options ""-O3 -march=z13 -mno-vx -mno-zvector"" } */

#include <vecintrin.h>

#pragma GCC target(""no-zvector"")
__attribute__ ((target(""vx"")))
void a1(void)
{
#ifdef __VEC__
#error __VEC__ is defined
#endif
  vec_load_bndry ((const signed char *)0, 64);
  __builtin_s390_vll ((unsigned int)0, (const void *)8);
}
#pragma GCC reset_options

__attribute__ ((target(""no-vx"")))
void a0(void)
{
#ifdef __VEC__
#error __VEC__ is defined
#endif
  __builtin_s390_vll ((unsigned int)0, (const void *)8); /* { dg-error ""requires -mvx"" } */
}

void d(void)
{
#ifdef __VEC__
#error __VEC__ is defined
#endif
  __builtin_s390_vll ((unsigned int)0, (const void *)8); /* { dg-error ""requires -mvx"" } */
}
"
"/* { dg-do run } */
/* { dg-options ""-fsanitize=null -w"" } */
/* { dg-shouldfail ""ubsan"" } */

int *
gao (void)
{
  return 0;
}

int
main (void)
{
  return *gao ();
}

/* { dg-output ""load of null pointer of type 'int'"" } */
","/* { dg-do run } */
/* { dg-options ""-fsanitize=null -w"" } */
/* { dg-shouldfail ""ubsan"" } */

int *
gao (void)
{
  return 0;
}

int
main (void)
{
  return *gao ();
}

/* { dg-output ""load of null pointer of type 'int'"" } */
"
"#include <arm_neon.h>

/* { dg-do compile } */
/* { dg-skip-if """" { *-*-* } { ""-fno-fat-lto-objects"" } } */

int16x4x4_t
f_vld4_lane_s16 (int16_t * p, int16x4x4_t v)
{
  int16x4x4_t res;
  /* { dg-error ""lane 4 out of range 0 - 3"" """" { target *-*-* } 0 } */
  res = vld4_lane_s16 (p, v, 4);
  /* { dg-error ""lane -1 out of range 0 - 3"" """" { target *-*-* } 0 } */
  res = vld4_lane_s16 (p, v, -1);
  return res;
}
","#include <arm_neon.h>

/* { dg-do compile } */
/* { dg-skip-if """" { *-*-* } { ""-fno-fat-lto-objects"" } } */

int16x4x4_t
f_vld4_lane_s16 (int16_t * p, int16x4x4_t v)
{
  int16x4x4_t res;
  /* { dg-error ""lane 4 out of range 0 - 3"" """" { target *-*-* } 0 } */
  res = vld4_lane_s16 (p, v, 4);
  /* { dg-error ""lane -1 out of range 0 - 3"" """" { target *-*-* } 0 } */
  res = vld4_lane_s16 (p, v, -1);
  return res;
}
"
"/* { dg-do compile } */
/* { dg-options ""-mavx512f -O2"" } */
/* { dg-final { scan-assembler-times ""vprolvq\[ \\t\]+\[^\{\n\]*%zmm\[0-9\]+(?:\n|\[ \\t\]+#)""  1 } } */
/* { dg-final { scan-assembler-times ""vprolvq\[ \\t\]+\[^\{\n\]*%zmm\[0-9\]+\{%k\[1-7\]\}(?:\n|\[ \\t\]+#)"" 1 } } */
/* { dg-final { scan-assembler-times ""vprolvq\[ \\t\]+\[^\{\n\]*%zmm\[0-9\]+\{%k\[1-7\]\}\{z\}(?:\n|\[ \\t\]+#)"" 1 } } */

#include <immintrin.h>

volatile __m512i x;
volatile __mmask8 m;

void extern
avx512f_test (void)
{
  x = _mm512_rolv_epi64 (x, x);
  x = _mm512_mask_rolv_epi64 (x, m, x, x);
  x = _mm512_maskz_rolv_epi64 (m, x, x);
}
","/* { dg-do compile } */
/* { dg-options ""-mavx512f -O2"" } */
/* { dg-final { scan-assembler-times ""vprolvq\[ \\t\]+\[^\{\n\]*%zmm\[0-9\]+(?:\n|\[ \\t\]+#)""  1 } } */
/* { dg-final { scan-assembler-times ""vprolvq\[ \\t\]+\[^\{\n\]*%zmm\[0-9\]+\{%k\[1-7\]\}(?:\n|\[ \\t\]+#)"" 1 } } */
/* { dg-final { scan-assembler-times ""vprolvq\[ \\t\]+\[^\{\n\]*%zmm\[0-9\]+\{%k\[1-7\]\}\{z\}(?:\n|\[ \\t\]+#)"" 1 } } */

#include <immintrin.h>

volatile __m512i x;
volatile __mmask8 m;

void extern
avx512f_test (void)
{
  x = _mm512_rolv_epi64 (x, x);
  x = _mm512_mask_rolv_epi64 (x, m, x, x);
  x = _mm512_maskz_rolv_epi64 (m, x, x);
}
"
"/* { dg-options ""-O2"" } */
/* { dg-do compile } */
/* { dg-require-effective-target ia32 } */

int test(long long a, long long b)
{
        return a * b;
}

/* Check that we did not spill anything.  This is all that is needed
   to qualify the generated code as ""decent""...  */

/* { dg-final { scan-assembler-not ""%e\[sd\]i"" } } */
","/* { dg-options ""-O2"" } */
/* { dg-do compile } */
/* { dg-require-effective-target ia32 } */

int test(long long a, long long b)
{
        return a * b;
}

/* Check that we did not spill anything.  This is all that is needed
   to qualify the generated code as ""decent""...  */

/* { dg-final { scan-assembler-not ""%e\[sd\]i"" } } */
"
"/* { dg-do compile } */
/* { dg-options ""-O -fstrict-aliasing -fdump-tree-optimized"" } */

struct S { float f; int i; };
struct R { int x; int i; };

/* Strict-aliasing rules say that int and float do not alias.  */
int bar(struct S *s, int *i)
{
  *i = 0;
  s->f = 1.0;
  return *i;
}

/* Strict-aliasing rules say that S and R do not alias.  */
int foo(struct S *s, struct R *r)
{
  r->i = 0;
  s->i = 1;
  return r->i;
}

/* { dg-final { scan-tree-dump-times ""return 0;"" 2 ""optimized"" } } */
","/* { dg-do compile } */
/* { dg-options ""-O -fstrict-aliasing -fdump-tree-optimized"" } */

struct S { float f; int i; };
struct R { int x; int i; };

/* Strict-aliasing rules say that int and float do not alias.  */
int bar(struct S *s, int *i)
{
  *i = 0;
  s->f = 1.0;
  return *i;
}

/* Strict-aliasing rules say that S and R do not alias.  */
int foo(struct S *s, struct R *r)
{
  r->i = 0;
  s->i = 1;
  return r->i;
}

/* { dg-final { scan-tree-dump-times ""return 0;"" 2 ""optimized"" } } */
"
"/* { dg-do compile } */
/* { dg-options ""-O2 -ffast-math -fno-inline -fno-unroll-loops -lm -mpowerpc-gpopt -fno-ident"" } */

#include <math.h>

extern void abort (void);

#define NVALS 6

static double
convert_it (double x)
{
  return pow (x, 0.25);
}

int
main (int argc, char *argv[])
{
  double values[NVALS] = { 3.0, 1.95, 2.227, 4.0, 256.0, .0008797 };
  unsigned i;

  for (i = 0; i < NVALS; i++)
    if (convert_it (values[i]) != sqrt (sqrt (values[i])))
      abort ();

  return 0;
}


/* { dg-final { scan-assembler-times ""fsqrt|xssqrtdp"" 4 { target powerpc*-*-* } } } */
/* { dg-final { scan-assembler-not ""bl\[\\. \]+pow"" { target powerpc*-*-* } } } */
","/* { dg-do compile } */
/* { dg-options ""-O2 -ffast-math -fno-inline -fno-unroll-loops -lm -mpowerpc-gpopt -fno-ident"" } */

#include <math.h>

extern void abort (void);

#define NVALS 6

static double
convert_it (double x)
{
  return pow (x, 0.25);
}

int
main (int argc, char *argv[])
{
  double values[NVALS] = { 3.0, 1.95, 2.227, 4.0, 256.0, .0008797 };
  unsigned i;

  for (i = 0; i < NVALS; i++)
    if (convert_it (values[i]) != sqrt (sqrt (values[i])))
      abort ();

  return 0;
}


/* { dg-final { scan-assembler-times ""fsqrt|xssqrtdp"" 4 { target powerpc*-*-* } } } */
/* { dg-final { scan-assembler-not ""bl\[\\. \]+pow"" { target powerpc*-*-* } } } */
"
"/* PR c++/79512 */
/* { dg-options ""-fopenmp-simd"" } */

void
foo (void)
{
  #pragma omp target
  #pragma omp teams
  {
    int i;
    for (i = 0; i < 10; i++)
      ;
  }
}
","/* PR c++/79512 */
/* { dg-options ""-fopenmp-simd"" } */

void
foo (void)
{
  #pragma omp target
  #pragma omp teams
  {
    int i;
    for (i = 0; i < 10; i++)
      ;
  }
}
"
"/* { dg-do compile } */
/* { dg-additional-options ""-fdump-tree-optimized -fassociative-math -fno-trapping-math -fno-signed-zeros"" } */

#include ""tree-vect.h""

#define N (VECTOR_BITS * 11 / 64 + 3)

double
dot_prod (double *x, double *y)
{
  double sum = 0;
  for (int i = 0; i < N; ++i)
    sum += x[i] * y[i];
  return sum;
}

/* { dg-final { scan-tree-dump { = \.COND_FMA } ""optimized"" { target { vect_double && { vect_fully_masked && scalar_all_fma } } } } } */
","/* { dg-do compile } */
/* { dg-additional-options ""-fdump-tree-optimized -fassociative-math -fno-trapping-math -fno-signed-zeros"" } */

#include ""tree-vect.h""

#define N (VECTOR_BITS * 11 / 64 + 3)

double
dot_prod (double *x, double *y)
{
  double sum = 0;
  for (int i = 0; i < N; ++i)
    sum += x[i] * y[i];
  return sum;
}

/* { dg-final { scan-tree-dump { = \.COND_FMA } ""optimized"" { target { vect_double && { vect_fully_masked && scalar_all_fma } } } } } */
"
"/* PR target/45336 */
/* { dg-do compile { target { ! ia32 } } } */
/* { dg-options ""-O2 -msse4 -mtune=generic"" } */
/* { dg-final { scan-assembler-not ""movsbl"" } } */
/* { dg-final { scan-assembler-not ""movswl"" } } */
/* { dg-final { scan-assembler-not ""movzbl"" } } */
/* { dg-final { scan-assembler-not ""movzwl"" } } */
/* { dg-final { scan-assembler-not ""cwtl"" } } */
/* { dg-final { scan-assembler-not ""cltq"" } } */
/* { dg-final { scan-assembler ""pextrb"" } } */
/* { dg-final { scan-assembler ""pextrw"" } } */
/* { dg-final { scan-assembler ""pextrd"" { target { ! x86_64-*-mingw* } } } } */

#include <smmintrin.h>
unsigned long long int foo8(__m128i x) { return _mm_extract_epi8(x, 4); }
unsigned long long int foo16(__m128i x) { return _mm_extract_epi16(x, 3); }
unsigned long long int foo32(__m128i x)
{ 
  return (unsigned int) _mm_extract_epi32(x, 2);
}
","/* PR target/45336 */
/* { dg-do compile { target { ! ia32 } } } */
/* { dg-options ""-O2 -msse4 -mtune=generic"" } */
/* { dg-final { scan-assembler-not ""movsbl"" } } */
/* { dg-final { scan-assembler-not ""movswl"" } } */
/* { dg-final { scan-assembler-not ""movzbl"" } } */
/* { dg-final { scan-assembler-not ""movzwl"" } } */
/* { dg-final { scan-assembler-not ""cwtl"" } } */
/* { dg-final { scan-assembler-not ""cltq"" } } */
/* { dg-final { scan-assembler ""pextrb"" } } */
/* { dg-final { scan-assembler ""pextrw"" } } */
/* { dg-final { scan-assembler ""pextrd"" { target { ! x86_64-*-mingw* } } } } */

#include <smmintrin.h>
unsigned long long int foo8(__m128i x) { return _mm_extract_epi8(x, 4); }
unsigned long long int foo16(__m128i x) { return _mm_extract_epi16(x, 3); }
unsigned long long int foo32(__m128i x)
{ 
  return (unsigned int) _mm_extract_epi32(x, 2);
}
"
"/* PR tree-optimization/78720 */

__attribute__((noinline, noclone)) long int
foo (signed char x)
{
  return x < 0 ? 0x80000L : 0L;
}

__attribute__((noinline, noclone)) long int
bar (signed char x)
{
  return x < 0 ? 0x80L : 0L;
}

__attribute__((noinline, noclone)) long int
baz (signed char x)
{
  return x < 0 ? 0x20L : 0L;
}

int
main ()
{
  if (foo (-1) != 0x80000L || bar (-1) != 0x80L || baz (-1) != 0x20L
      || foo (0) != 0L || bar (0) != 0L || baz (0) != 0L
      || foo (31) != 0L || bar (31) != 0L || baz (31) != 0L)
    __builtin_abort ();
  return 0;
}
","/* PR tree-optimization/78720 */

__attribute__((noinline, noclone)) long int
foo (signed char x)
{
  return x < 0 ? 0x80000L : 0L;
}

__attribute__((noinline, noclone)) long int
bar (signed char x)
{
  return x < 0 ? 0x80L : 0L;
}

__attribute__((noinline, noclone)) long int
baz (signed char x)
{
  return x < 0 ? 0x20L : 0L;
}

int
main ()
{
  if (foo (-1) != 0x80000L || bar (-1) != 0x80L || baz (-1) != 0x20L
      || foo (0) != 0L || bar (0) != 0L || baz (0) != 0L
      || foo (31) != 0L || bar (31) != 0L || baz (31) != 0L)
    __builtin_abort ();
  return 0;
}
"
"/* { dg-do compile } */
/* { dg-options ""-O1 -fdump-tree-optimized"" } */

void f (long *p) {
  *p = 42;
  p[4] = 42;
  __builtin_free (p);
}

/* { dg-final { scan-tree-dump-not ""= 42"" ""optimized"" } } */

","/* { dg-do compile } */
/* { dg-options ""-O1 -fdump-tree-optimized"" } */

void f (long *p) {
  *p = 42;
  p[4] = 42;
  __builtin_free (p);
}

/* { dg-final { scan-tree-dump-not ""= 42"" ""optimized"" } } */

"
"test ()
{
  short *p, q[3];
  int x;

  p = q;
  for (x = 0; x < 3; x++)
    *p++ = 0;
}
","test ()
{
  short *p, q[3];
  int x;

  p = q;
  for (x = 0; x < 3; x++)
    *p++ = 0;
}
"
"/* { dg-do compile } */
/* { dg-options ""-O2 -fdump-tree-evrp"" } */

static int blocksize = 4096;

int bar (int);

void foo (void)
{
  int toread;
  int bytes;
  static char eof_reached = 0;

  toread = blocksize;
  bytes = 1;

  while (toread != 0)
    {
      bytes = bar (toread);
      if (bytes <= 0)
        {
          if (bytes < 0)
            continue;
          break;
        }
      toread -= bytes;
    }

  if (bytes == 0)
    eof_reached = 1;
}

/* { dg-final { scan-tree-dump-times ""Simplified relational"" 1 ""evrp"" } } */
","/* { dg-do compile } */
/* { dg-options ""-O2 -fdump-tree-evrp"" } */

static int blocksize = 4096;

int bar (int);

void foo (void)
{
  int toread;
  int bytes;
  static char eof_reached = 0;

  toread = blocksize;
  bytes = 1;

  while (toread != 0)
    {
      bytes = bar (toread);
      if (bytes <= 0)
        {
          if (bytes < 0)
            continue;
          break;
        }
      toread -= bytes;
    }

  if (bytes == 0)
    eof_reached = 1;
}

/* { dg-final { scan-tree-dump-times ""Simplified relational"" 1 ""evrp"" } } */
"
"/* { dg-do compile } */
/* { dg-options "" "" } */
/* { dg-final { scan-assembler-not ""wrctl\\tctl6, zero"" } } */

void foo(void){
  __builtin_wrctl(6,4);
}
","/* { dg-do compile } */
/* { dg-options "" "" } */
/* { dg-final { scan-assembler-not ""wrctl\\tctl6, zero"" } } */

void foo(void){
  __builtin_wrctl(6,4);
}
"
"/* { dg-options ""-O2 -ffast-math -fdump-tree-optimized"" } */
/* { dg-do compile } */
float f(float x)
{
  float t = __builtin_copysignf (1.0f, x);
  return x * t;
}
float f1(float x)
{
  float t = __builtin_copysignf (1.0f, -x);
  return x * t;
}
/* { dg-final { scan-tree-dump-times ""ABS"" 2 ""optimized""} } */
","/* { dg-options ""-O2 -ffast-math -fdump-tree-optimized"" } */
/* { dg-do compile } */
float f(float x)
{
  float t = __builtin_copysignf (1.0f, x);
  return x * t;
}
float f1(float x)
{
  float t = __builtin_copysignf (1.0f, -x);
  return x * t;
}
/* { dg-final { scan-tree-dump-times ""ABS"" 2 ""optimized""} } */
"
"/* { dg-do run } */
/* { dg-require-effective-target avx2 } */
/* { dg-options ""-O2 -mavx2"" } */

#include <string.h>
#include ""avx2-check.h""

#define N 0x5

static void
compute_punpckhwd256 (short *s1, short *s2, short *r)
{
  int i;

  for (i = 0; i < 4; i++)
    {
      r[2 * i] = s1[i + 4];
      r[2 * i + 1] = s2[i + 4];

      r[2 * i + 8] = s1[i + 4 + 8];
      r[2 * i + 8 + 1] = s2[i + 4 + 8];
    }
}

void static
avx2_test (void)
{
  union256i_w s1, s2, res;
  short res_ref[16];
  int i, j;
  int fail = 0;

  for (i = 0; i < 10; i++)
    {
      for (j = 0; j < 16; j++)
	{
	  s1.a[j] = j * i;
	  s2.a[j] = j + 20;
	}

      res.x = _mm256_unpackhi_epi16 (s1.x, s2.x);

      compute_punpckhwd256 (s1.a, s2.a, res_ref);

      fail += check_union256i_w (res, res_ref);
    }

  if (fail != 0)
    abort ();
}
","/* { dg-do run } */
/* { dg-require-effective-target avx2 } */
/* { dg-options ""-O2 -mavx2"" } */

#include <string.h>
#include ""avx2-check.h""

#define N 0x5

static void
compute_punpckhwd256 (short *s1, short *s2, short *r)
{
  int i;

  for (i = 0; i < 4; i++)
    {
      r[2 * i] = s1[i + 4];
      r[2 * i + 1] = s2[i + 4];

      r[2 * i + 8] = s1[i + 4 + 8];
      r[2 * i + 8 + 1] = s2[i + 4 + 8];
    }
}

void static
avx2_test (void)
{
  union256i_w s1, s2, res;
  short res_ref[16];
  int i, j;
  int fail = 0;

  for (i = 0; i < 10; i++)
    {
      for (j = 0; j < 16; j++)
	{
	  s1.a[j] = j * i;
	  s2.a[j] = j + 20;
	}

      res.x = _mm256_unpackhi_epi16 (s1.x, s2.x);

      compute_punpckhwd256 (s1.a, s2.a, res_ref);

      fail += check_union256i_w (res, res_ref);
    }

  if (fail != 0)
    abort ();
}
"
"/* { dg-do compile } */
/* { dg-options ""-O"" } */
int func()
{
  const int *arr;
  const int arr2[5];
  arr[0] = 1; /* { dg-error ""assignment of read-only location"" ""*(arr)"" } */
  arr[1] = 1; /* { dg-error ""assignment of read-only location"" ""*(arr + 4u)"" } */
  arr2[0] = 1; /* { dg-error ""assignment of read-only location"" ""arr2\[0\]"" } */
  arr2[1] = 1; /* { dg-error ""assignment of read-only location"" ""arr2\[1\]"" } */
}
","/* { dg-do compile } */
/* { dg-options ""-O"" } */
int func()
{
  const int *arr;
  const int arr2[5];
  arr[0] = 1; /* { dg-error ""assignment of read-only location"" ""*(arr)"" } */
  arr[1] = 1; /* { dg-error ""assignment of read-only location"" ""*(arr + 4u)"" } */
  arr2[0] = 1; /* { dg-error ""assignment of read-only location"" ""arr2\[0\]"" } */
  arr2[1] = 1; /* { dg-error ""assignment of read-only location"" ""arr2\[1\]"" } */
}
"
"/* { dg-do compile { target { powerpc*-*-* } } } */
/* { dg-skip-if ""do not override -mcpu"" { powerpc*-*-* } { ""-mcpu=*"" } { ""-mcpu=power9"" } } */
/* { dg-require-effective-target lp64 } */
/* { dg-require-effective-target powerpc_p9vector_ok } */
/* { dg-options ""-mcpu=power9"" } */

#include <stddef.h>
#include <altivec.h>

void
store_data (vector signed short *datap, signed short *address,  size_t length)
{
  vector signed short data = *datap;

  vec_xst_len (data, address, length);
}

/* { dg-final { scan-assembler ""sldi"" } } */
/* { dg-final { scan-assembler ""stxvl"" } } */
","/* { dg-do compile { target { powerpc*-*-* } } } */
/* { dg-skip-if ""do not override -mcpu"" { powerpc*-*-* } { ""-mcpu=*"" } { ""-mcpu=power9"" } } */
/* { dg-require-effective-target lp64 } */
/* { dg-require-effective-target powerpc_p9vector_ok } */
/* { dg-options ""-mcpu=power9"" } */

#include <stddef.h>
#include <altivec.h>

void
store_data (vector signed short *datap, signed short *address,  size_t length)
{
  vector signed short data = *datap;

  vec_xst_len (data, address, length);
}

/* { dg-final { scan-assembler ""sldi"" } } */
/* { dg-final { scan-assembler ""stxvl"" } } */
"
"
short
func(void)
{
	unsigned char x, y;

	return  y | x << 8;
}

","
short
func(void)
{
	unsigned char x, y;

	return  y | x << 8;
}

"
"/* PR inline-asm/84625 */
/* { dg-do compile } */
/* { dg-options ""-O2 -msse2"" } */

typedef int V __attribute__((vector_size (16)));

void
foo (void)
{
  asm volatile (""# %0"" : : ""X"" ((V) { 1, 2, 3, 4 }));	// { dg-error ""invalid vector immediate"" }
  asm volatile (""# %0"" : : """" ((V) { 2, 3, 4, 5 }));	// { dg-error ""invalid vector immediate"" }
}
","/* PR inline-asm/84625 */
/* { dg-do compile } */
/* { dg-options ""-O2 -msse2"" } */

typedef int V __attribute__((vector_size (16)));

void
foo (void)
{
  asm volatile (""# %0"" : : ""X"" ((V) { 1, 2, 3, 4 }));	// { dg-error ""invalid vector immediate"" }
  asm volatile (""# %0"" : : """" ((V) { 2, 3, 4, 5 }));	// { dg-error ""invalid vector immediate"" }
}
"
"/* { dg-do run } */
/* { dg-options ""-O2"" } */

extern void abort (void);
extern void exit (int);

unsigned int __attribute__ ((noinline, noclone))
foo(unsigned int i) {

  return 0xFFFF & (0xd066 << (((i & 0x1) ^ 0x2f) & 0xf));
}

int main() {
  if (foo (1) != 0x8000)
    abort ();
  exit (0);
}
","/* { dg-do run } */
/* { dg-options ""-O2"" } */

extern void abort (void);
extern void exit (int);

unsigned int __attribute__ ((noinline, noclone))
foo(unsigned int i) {

  return 0xFFFF & (0xd066 << (((i & 0x1) ^ 0x2f) & 0xf));
}

int main() {
  if (foo (1) != 0x8000)
    abort ();
  exit (0);
}
"
"/* { dg-do compile } */
/* { dg-require-effective-target arm_eabi } */
/* { dg-options ""-O2"" } */
/* { dg-final { scan-assembler-times ""ldr\[\\t \]+\[^\n\]*,\[\\t \]*\\\[\[^\n\]*\\\]"" 2 } } */
/* { dg-final { scan-assembler-times ""str\[\\t \]+\[^\n\]*,\[\\t \]*\\\[\[^\n\]*\\\]"" 2 } } */
/* { dg-final { scan-assembler-not ""strb"" } } */

struct thing {
  unsigned a: 8;
  unsigned b: 8;
  unsigned c: 8;
  unsigned d: 8;
};

struct thing2 {
  volatile unsigned a: 8;
  volatile unsigned b: 8;
  volatile unsigned c: 8;
  volatile unsigned d: 8;
};

void test1(volatile struct thing *t)
{
  t->a = 5;
}

void test2(struct thing2 *t)
{
  t->a = 5;
}
","/* { dg-do compile } */
/* { dg-require-effective-target arm_eabi } */
/* { dg-options ""-O2"" } */
/* { dg-final { scan-assembler-times ""ldr\[\\t \]+\[^\n\]*,\[\\t \]*\\\[\[^\n\]*\\\]"" 2 } } */
/* { dg-final { scan-assembler-times ""str\[\\t \]+\[^\n\]*,\[\\t \]*\\\[\[^\n\]*\\\]"" 2 } } */
/* { dg-final { scan-assembler-not ""strb"" } } */

struct thing {
  unsigned a: 8;
  unsigned b: 8;
  unsigned c: 8;
  unsigned d: 8;
};

struct thing2 {
  volatile unsigned a: 8;
  volatile unsigned b: 8;
  volatile unsigned c: 8;
  volatile unsigned d: 8;
};

void test1(volatile struct thing *t)
{
  t->a = 5;
}

void test2(struct thing2 *t)
{
  t->a = 5;
}
"
"#define FLOAT long double
#include ""fp-cmp-4.c""
","#define FLOAT long double
#include ""fp-cmp-4.c""
"
"/* PR c/69558 */
/* { dg-do compile } */
/* { dg-options ""-Wdeprecated-declarations"" } */

/* Verify disabling -Wdeprecated-declarations, where neither the _Pragma nor
   the affected code are in macros.  */

__attribute__((deprecated)) void foo (void);

void bar (void)
{
  _Pragma (""GCC diagnostic push"")
  _Pragma (""GCC diagnostic ignored \""-Wdeprecated-declarations\"""")
  foo ();
  _Pragma (""GCC diagnostic pop"")
}
","/* PR c/69558 */
/* { dg-do compile } */
/* { dg-options ""-Wdeprecated-declarations"" } */

/* Verify disabling -Wdeprecated-declarations, where neither the _Pragma nor
   the affected code are in macros.  */

__attribute__((deprecated)) void foo (void);

void bar (void)
{
  _Pragma (""GCC diagnostic push"")
  _Pragma (""GCC diagnostic ignored \""-Wdeprecated-declarations\"""")
  foo ();
  _Pragma (""GCC diagnostic pop"")
}
"
"/* { dg-do compile } */
/* { dg-options ""-O2 -march=r2 -mbypass-cache"" } */

/* Check that the compiler is aware of the reduced offset range for ldio/stio
   instructions in the Nios II R2 encoding.  */

unsigned int too_big (unsigned int *p)
{
  return *(p + 0x400);
}

unsigned int small_enough (unsigned int *p)
{
  return *(p + 0x100);
}

/* { dg-final { scan-assembler-not ""\tldwio\t.*, 4096\\(r.*\\)"" } }  */
/* { dg-final { scan-assembler ""\tldwio\t.*, 1024\\(r.*\\)"" } }  */
","/* { dg-do compile } */
/* { dg-options ""-O2 -march=r2 -mbypass-cache"" } */

/* Check that the compiler is aware of the reduced offset range for ldio/stio
   instructions in the Nios II R2 encoding.  */

unsigned int too_big (unsigned int *p)
{
  return *(p + 0x400);
}

unsigned int small_enough (unsigned int *p)
{
  return *(p + 0x100);
}

/* { dg-final { scan-assembler-not ""\tldwio\t.*, 4096\\(r.*\\)"" } }  */
/* { dg-final { scan-assembler ""\tldwio\t.*, 1024\\(r.*\\)"" } }  */
"
"/* { dg-do compile } */
/* { dg-final { scan-assembler ""custom"" } } */

/* This test case used to cause an unrecognizable insn crash.  */

void foo (void)
{
  int offset = __builtin_custom_in(0x1);
}
","/* { dg-do compile } */
/* { dg-final { scan-assembler ""custom"" } } */

/* This test case used to cause an unrecognizable insn crash.  */

void foo (void)
{
  int offset = __builtin_custom_in(0x1);
}
"
"/* { dg-do compile } */
/* { dg-options """" } */

register long double F80 asm(""st""); /* { dg-error ""stack register"" } */
","/* { dg-do compile } */
/* { dg-options """" } */

register long double F80 asm(""st""); /* { dg-error ""stack register"" } */
"
"extern void abort (void);

struct S {
  unsigned b4:4;
  unsigned b6:6;
} s;

int main()
{
  s.b6 = 31;
  s.b4 = s.b6;
  s.b6 = s.b4;
  if (s.b6 != 15)
    abort ();
  return 0;
}

","extern void abort (void);

struct S {
  unsigned b4:4;
  unsigned b6:6;
} s;

int main()
{
  s.b6 = 31;
  s.b4 = s.b6;
  s.b6 = s.b4;
  if (s.b6 != 15)
    abort ();
  return 0;
}

"
"/* Test the optimization of `vdupq_n_u32' ARM Neon intrinsic.  */

/* { dg-do compile } */
/* { dg-require-effective-target arm_neon_ok } */
/* { dg-options ""-O2"" } */
/* { dg-add-options arm_neon } */

#include <arm_neon.h>

uint32x4_t out_uint32x4_t;
void test_vdupq_nu32 (void)
{
  out_uint32x4_t = vdupq_n_u32 (0x12ffff);
}

/* { dg-final { scan-assembler ""vmov\.i32\[ 	\]+\[qQ\]\[0-9\]+, #1245183\(\[ \]+@\[a-zA-Z0-9 \]+\)?\n"" } } */
","/* Test the optimization of `vdupq_n_u32' ARM Neon intrinsic.  */

/* { dg-do compile } */
/* { dg-require-effective-target arm_neon_ok } */
/* { dg-options ""-O2"" } */
/* { dg-add-options arm_neon } */

#include <arm_neon.h>

uint32x4_t out_uint32x4_t;
void test_vdupq_nu32 (void)
{
  out_uint32x4_t = vdupq_n_u32 (0x12ffff);
}

/* { dg-final { scan-assembler ""vmov\.i32\[ 	\]+\[qQ\]\[0-9\]+, #1245183\(\[ \]+@\[a-zA-Z0-9 \]+\)?\n"" } } */
"
"/* Check that malloc's alignment honors what we trust it
   minimally should.  */

/* { dg-do run } */
/* { dg-options ""-fno-builtin-malloc"" } */

#include <stdlib.h>                                                            
typedef int word __attribute__((mode(word)));

int main()
{
    if ((__UINTPTR_TYPE__)malloc (1) & (sizeof(word)-1))
	abort ();
    return 0;
}                                                                              
","/* Check that malloc's alignment honors what we trust it
   minimally should.  */

/* { dg-do run } */
/* { dg-options ""-fno-builtin-malloc"" } */

#include <stdlib.h>                                                            
typedef int word __attribute__((mode(word)));

int main()
{
    if ((__UINTPTR_TYPE__)malloc (1) & (sizeof(word)-1))
	abort ();
    return 0;
}                                                                              
"
"/* { dg-do run { target *-*-linux* } } */
/* { dg-options ""-O2 -fpic -fno-plt"" } */
/* { dg-additional-sources noplt-ld-1.c } */

extern void abort (void);
extern int * get_ld (void);
extern void set_ld (int);
extern int test_ld (int);

int
main ()
{
  int *p;
 
  p = get_ld ();
  set_ld (4);
  if (*p != 4 || !test_ld (4))
    abort ();

  return 0;
}
","/* { dg-do run { target *-*-linux* } } */
/* { dg-options ""-O2 -fpic -fno-plt"" } */
/* { dg-additional-sources noplt-ld-1.c } */

extern void abort (void);
extern int * get_ld (void);
extern void set_ld (int);
extern int test_ld (int);

int
main ()
{
  int *p;
 
  p = get_ld ();
  set_ld (4);
  if (*p != 4 || !test_ld (4))
    abort ();

  return 0;
}
"
"/* { dg-options ""-mshared -mabi=n32"" } */
/* { dg-final { scan-assembler-not ""(\\\$25|\\\$28|%gp_rel|%got)"" } } */
/* { dg-final { scan-assembler-not ""\tjrc?\t\\\$1\n"" } } */

#include ""branch-helper.h""

NOCOMPRESSION void
foo (volatile int *x)
{
  if (__builtin_expect (*x == 0, 1))
    OCCUPY_0x1fff8;
}
","/* { dg-options ""-mshared -mabi=n32"" } */
/* { dg-final { scan-assembler-not ""(\\\$25|\\\$28|%gp_rel|%got)"" } } */
/* { dg-final { scan-assembler-not ""\tjrc?\t\\\$1\n"" } } */

#include ""branch-helper.h""

NOCOMPRESSION void
foo (volatile int *x)
{
  if (__builtin_expect (*x == 0, 1))
    OCCUPY_0x1fff8;
}
"
"/* { dg-require-effective-target vect_condition } */

#include ""tree-vect.h""

extern void abort (void) __attribute__ ((noreturn));

#define N 30

/* Condition reduction where loop type is different than the data type.  */

int
condition_reduction (int *a, int min_v)
{
  int last = N + 65;

  for (char i = 0; i < N; i++)
    if (a[i] < min_v)
      last = a[i];

  return last;
}


int
main (void)
{
  int a[N] = {
  67, 32, 45, 43, 21, -11, 12, 3, 4, 5,
  6, 76, -32, 56, -32, -1, 4, 5, 6, 99,
  43, 22, -3, 22, 16, 34, 55, 31, 87, 324
  };

  check_vect ();

  int ret = condition_reduction (a, 16);

  if (ret != -3)
    abort ();

  return 0;
}

/* { dg-final { scan-tree-dump-times ""LOOP VECTORIZED"" 2 ""vect"" } } */
/* { dg-final { scan-tree-dump-times ""optimizing condition reduction with FOLD_EXTRACT_LAST"" 4 ""vect"" { target vect_fold_extract_last } } } */
/* { dg-final { scan-tree-dump-not ""condition expression based on integer induction."" ""vect"" } } */
","/* { dg-require-effective-target vect_condition } */

#include ""tree-vect.h""

extern void abort (void) __attribute__ ((noreturn));

#define N 30

/* Condition reduction where loop type is different than the data type.  */

int
condition_reduction (int *a, int min_v)
{
  int last = N + 65;

  for (char i = 0; i < N; i++)
    if (a[i] < min_v)
      last = a[i];

  return last;
}


int
main (void)
{
  int a[N] = {
  67, 32, 45, 43, 21, -11, 12, 3, 4, 5,
  6, 76, -32, 56, -32, -1, 4, 5, 6, 99,
  43, 22, -3, 22, 16, 34, 55, 31, 87, 324
  };

  check_vect ();

  int ret = condition_reduction (a, 16);

  if (ret != -3)
    abort ();

  return 0;
}

/* { dg-final { scan-tree-dump-times ""LOOP VECTORIZED"" 2 ""vect"" } } */
/* { dg-final { scan-tree-dump-times ""optimizing condition reduction with FOLD_EXTRACT_LAST"" 4 ""vect"" { target vect_fold_extract_last } } } */
/* { dg-final { scan-tree-dump-not ""condition expression based on integer induction."" ""vect"" } } */
"
"/* PR c/64766 */
/* { dg-do compile } */

void
foo ()
{
}

void foo () = 0; /* { dg-error ""is initialized like a variable|invalid initializer"" } */
","/* PR c/64766 */
/* { dg-do compile } */

void
foo ()
{
}

void foo () = 0; /* { dg-error ""is initialized like a variable|invalid initializer"" } */
"
"/* Test that assignment of a read-only variable that gets const-ness
   from a read-only field is diagnosed.  */
/* Origin: Joseph Myers <joseph@codesourcery.com> */
/* { dg-do compile } */
/* { dg-options """" } */

struct s { const int a; } x;
typeof (x.a) b;
void
f (void)
{
  x.a = 1; /* { dg-error ""assignment of read-only member 'a'"" } */
  b = 1; /* { dg-error ""assignment of read-only variable 'b'"" } */
}
","/* Test that assignment of a read-only variable that gets const-ness
   from a read-only field is diagnosed.  */
/* Origin: Joseph Myers <joseph@codesourcery.com> */
/* { dg-do compile } */
/* { dg-options """" } */

struct s { const int a; } x;
typeof (x.a) b;
void
f (void)
{
  x.a = 1; /* { dg-error ""assignment of read-only member 'a'"" } */
  b = 1; /* { dg-error ""assignment of read-only variable 'b'"" } */
}
"
"x(){char*q;return(long)q>>8&0xff;}
","x(){char*q;return(long)q>>8&0xff;}
"
"/* { dg-do compile { target fpic } } */
/* { dg-require-effective-target lp64 } */
/* { dg-options ""-fPIC"" } */
char *ptr = 0;
char array[100];
void
f()
{
  ptr = &array[0x100000000ULL];	/* A 33-bit constant.  */
}
","/* { dg-do compile { target fpic } } */
/* { dg-require-effective-target lp64 } */
/* { dg-options ""-fPIC"" } */
char *ptr = 0;
char array[100];
void
f()
{
  ptr = &array[0x100000000ULL];	/* A 33-bit constant.  */
}
"
"/* Tree PRE is going to transform this so that it doesn't call cos on the 
   d = 0 path, and in doing so, it needs to regenerate the cos call.
   This was ICE'ing due to an overly strict check on what it knew how
   to regenerate.   */
/* { dg-do compile } */
/* { dg-options ""-O2 -ffast-math"" } */
double cos(double);
double f(double d, double i, int j) { if (j == 1) d = 0; return d * cos(i); }
","/* Tree PRE is going to transform this so that it doesn't call cos on the 
   d = 0 path, and in doing so, it needs to regenerate the cos call.
   This was ICE'ing due to an overly strict check on what it knew how
   to regenerate.   */
/* { dg-do compile } */
/* { dg-options ""-O2 -ffast-math"" } */
double cos(double);
double f(double d, double i, int j) { if (j == 1) d = 0; return d * cos(i); }
"
"/* PR middle-end/55130 */
/* { dg-do compile { target ia32 } } */
/* { dg-options ""-O1 -mregparm=3 -mpreferred-stack-boundary=2"" } */

extern void bar(long long);

int foo(long long a, char b, long long c, long long d)
{
  if (c == 0)
    c = d;

  bar(b + c);

  return a == d;
}
","/* PR middle-end/55130 */
/* { dg-do compile { target ia32 } } */
/* { dg-options ""-O1 -mregparm=3 -mpreferred-stack-boundary=2"" } */

extern void bar(long long);

int foo(long long a, char b, long long c, long long d)
{
  if (c == 0)
    c = d;

  bar(b + c);

  return a == d;
}
"
"/* { dg-do compile { target { ! ia32 } } } */
/* { dg-options ""-O3 -dp -mavx -mavx256-split-unaligned-load -mno-prefer-avx128"" } */

void
avx_test (char **cp, char **ep)
{
  int i;
  char **ap = __builtin_assume_aligned (ep, 32);
  for (i = 128; i > 0; i--)
    *ap++ = *cp++;
}

/* { dg-final { scan-assembler-not ""(avx_loaddqu256|vmovdqu\[^\n\r]*movv32qi_internal)"" } } */
/* { dg-final { scan-assembler ""(sse2_loaddqu|(vmovdqu|vmovups)\[^\n\r]*movv16qi_internal)"" } } */
/* { dg-final { scan-assembler ""vinsert.128"" } } */
","/* { dg-do compile { target { ! ia32 } } } */
/* { dg-options ""-O3 -dp -mavx -mavx256-split-unaligned-load -mno-prefer-avx128"" } */

void
avx_test (char **cp, char **ep)
{
  int i;
  char **ap = __builtin_assume_aligned (ep, 32);
  for (i = 128; i > 0; i--)
    *ap++ = *cp++;
}

/* { dg-final { scan-assembler-not ""(avx_loaddqu256|vmovdqu\[^\n\r]*movv32qi_internal)"" } } */
/* { dg-final { scan-assembler ""(sse2_loaddqu|(vmovdqu|vmovups)\[^\n\r]*movv16qi_internal)"" } } */
/* { dg-final { scan-assembler ""vinsert.128"" } } */
"
"/* { dg-do run } */
/* { dg-options ""-O2 -mavx512vl"" } */
/* { dg-require-effective-target avx512vl } */

#define AVX512VL
#define AVX512F_LEN 256
#define AVX512F_LEN_HALF 128
#include ""avx512f-vpermi2q-2.c""

#undef AVX512F_LEN
#undef AVX512F_LEN_HALF

#define AVX512F_LEN 128
#define AVX512F_LEN_HALF 128
#include ""avx512f-vpermi2q-2.c""
","/* { dg-do run } */
/* { dg-options ""-O2 -mavx512vl"" } */
/* { dg-require-effective-target avx512vl } */

#define AVX512VL
#define AVX512F_LEN 256
#define AVX512F_LEN_HALF 128
#include ""avx512f-vpermi2q-2.c""

#undef AVX512F_LEN
#undef AVX512F_LEN_HALF

#define AVX512F_LEN 128
#define AVX512F_LEN_HALF 128
#include ""avx512f-vpermi2q-2.c""
"
"/* { dg-do run } */
/* { dg-require-effective-target sse4 } */
/* { dg-options ""-O2 -msse4.2"" } */

#define CRC32 _mm_crc32_u16
#define DST_T unsigned int
#define SRC_T unsigned short

#include ""sse4_2-crc32.h""
","/* { dg-do run } */
/* { dg-require-effective-target sse4 } */
/* { dg-options ""-O2 -msse4.2"" } */

#define CRC32 _mm_crc32_u16
#define DST_T unsigned int
#define SRC_T unsigned short

#include ""sse4_2-crc32.h""
"
"struct A {};

struct A foo()
{
  return foo();
}

void bar()
{
  foo();
}
","struct A {};

struct A foo()
{
  return foo();
}

void bar()
{
  foo();
}
"
"/* { dg-do run } */
/* { dg-skip-if ""Stack alignment is too small"" { hppa*-*-hpux* } } */
/* { dg-skip-if ""Stack alignment causes use of alloca"" { nvptx-*-* } } */

#include ""check.h""

#ifndef ALIGNMENT
#define ALIGNMENT	64
#endif

typedef int aligned __attribute__((aligned(ALIGNMENT)));

int n;

void
g (void)
{
  __label__ lab;
  void h (void)
    {
      aligned t;
      if (check_int (&t,  __alignof__(t)) != t)
	abort ();
      if (n+t == 0) goto lab;
    }
  h();
lab:
  return;
}

int main()
{
  g();
  return 0;
}
","/* { dg-do run } */
/* { dg-skip-if ""Stack alignment is too small"" { hppa*-*-hpux* } } */
/* { dg-skip-if ""Stack alignment causes use of alloca"" { nvptx-*-* } } */

#include ""check.h""

#ifndef ALIGNMENT
#define ALIGNMENT	64
#endif

typedef int aligned __attribute__((aligned(ALIGNMENT)));

int n;

void
g (void)
{
  __label__ lab;
  void h (void)
    {
      aligned t;
      if (check_int (&t,  __alignof__(t)) != t)
	abort ();
      if (n+t == 0) goto lab;
    }
  h();
lab:
  return;
}

int main()
{
  g();
  return 0;
}
"
"/* PR rtl-optimization/79571 */
/* { dg-do compile } */
/* { dg-options ""-O -mno-sse -w"" } */

struct a
{
  int b;
  int *c
} h;
struct d
{
  struct a e
};
struct fd
{
  struct d *d
} i;
g;
j ()
{
  unsigned a = g;
  i = (struct fd){a & 3};
  struct fd f = i;
  h = f.d->e;
}
","/* PR rtl-optimization/79571 */
/* { dg-do compile } */
/* { dg-options ""-O -mno-sse -w"" } */

struct a
{
  int b;
  int *c
} h;
struct d
{
  struct a e
};
struct fd
{
  struct d *d
} i;
g;
j ()
{
  unsigned a = g;
  i = (struct fd){a & 3};
  struct fd f = i;
  h = f.d->e;
}
"
"/* { dg-do compile } */
/* { dg-options ""-mlarge -mcode-region=either -ffunction-sections"" } */
/* { dg-final { scan-assembler-not ""\\.either\\.lowtext"" } } */

void __attribute__ ((interrupt (2))) ir_1 (void)
{
  while (1);
}

int main (void)
{
  while (1);
}
","/* { dg-do compile } */
/* { dg-options ""-mlarge -mcode-region=either -ffunction-sections"" } */
/* { dg-final { scan-assembler-not ""\\.either\\.lowtext"" } } */

void __attribute__ ((interrupt (2))) ir_1 (void)
{
  while (1);
}

int main (void)
{
  while (1);
}
"
"/* { dg-do compile } */
/* { dg-options ""-mavx2 -O2"" } */
/* { dg-final { scan-assembler ""vpgatherqd\[ \\t\]+\[^\n\]*xmm\[0-9\]\[^\n\]*xmm\[0-9\]\[^\n\]*xmm\[0-9\]"" } } */

#include <immintrin.h>

__m128i x;
int *base;
__m128i idx;

void extern
avx2_test (void)
{
  x = _mm_i64gather_epi32 (base, idx, 1);
}
","/* { dg-do compile } */
/* { dg-options ""-mavx2 -O2"" } */
/* { dg-final { scan-assembler ""vpgatherqd\[ \\t\]+\[^\n\]*xmm\[0-9\]\[^\n\]*xmm\[0-9\]\[^\n\]*xmm\[0-9\]"" } } */

#include <immintrin.h>

__m128i x;
int *base;
__m128i idx;

void extern
avx2_test (void)
{
  x = _mm_i64gather_epi32 (base, idx, 1);
}
"
"/* Verify that we do not lose side effects on a MOD expression.  */

#include <stdlib.h>
#include <stdio.h>

int
foo (int a)
{
  int x = 0 % a++;
  return a;
}

main()
{
  if (foo (9) != 10)
    abort ();
  exit (0);
}
","/* Verify that we do not lose side effects on a MOD expression.  */

#include <stdlib.h>
#include <stdio.h>

int
foo (int a)
{
  int x = 0 % a++;
  return a;
}

main()
{
  if (foo (9) != 10)
    abort ();
  exit (0);
}
"
"/* { dg-do compile } */

int
div_and_round_double (lden_orig, hden_orig)
     int lden_orig, hden_orig;
{
  int quo[4];
  register int i;
  unsigned int  work;
  register unsigned int  carry = 0;
  int  lden = lden_orig;
  int  hden = hden_orig;
  neg_double (&lden, &hden);
  for (i = 4 - 1; i >= 0; i--)
    {
      quo[i] = work / (unsigned int ) lden;
      carry = work % (unsigned int ) lden;
    }
  return 0;
}
","/* { dg-do compile } */

int
div_and_round_double (lden_orig, hden_orig)
     int lden_orig, hden_orig;
{
  int quo[4];
  register int i;
  unsigned int  work;
  register unsigned int  carry = 0;
  int  lden = lden_orig;
  int  hden = hden_orig;
  neg_double (&lden, &hden);
  for (i = 4 - 1; i >= 0; i--)
    {
      quo[i] = work / (unsigned int ) lden;
      carry = work % (unsigned int ) lden;
    }
  return 0;
}
"
"/* { dg-do compile } */
/* { dg-options ""-O -fno-strict-aliasing -fdump-tree-lim2-details"" } */

void f(int * __restrict__ r,
       int a[__restrict__ 16][16],
       int b[__restrict__ 16][16],
       int i, int j)
{
  int x;
  *r = 0;
  for (x = 1; x < 16; ++x)
    *r = *r + a[i][x] * b[x][j];
}

/* We should apply store motion to the store to *r.  */

/* { dg-final { scan-tree-dump ""Executing store motion of \\\*r"" ""lim2"" } } */
","/* { dg-do compile } */
/* { dg-options ""-O -fno-strict-aliasing -fdump-tree-lim2-details"" } */

void f(int * __restrict__ r,
       int a[__restrict__ 16][16],
       int b[__restrict__ 16][16],
       int i, int j)
{
  int x;
  *r = 0;
  for (x = 1; x < 16; ++x)
    *r = *r + a[i][x] * b[x][j];
}

/* We should apply store motion to the store to *r.  */

/* { dg-final { scan-tree-dump ""Executing store motion of \\\*r"" ""lim2"" } } */
"
"/* { dg-additional-options ""-funroll-loops --param \""max-completely-peeled-insns=400\"""" } */

/* PR tree-optimization/63530 */
/* On armv7 hardware, following options cause run time failure  */
/*   -march=armv7-a -mfloat-abi=hard -mfpu=neon -marm -O2 -ftree-vectorize  */
/*   -funroll-loops --param ""max-completely-peeled-insns=400""  */

#include ""tree-vect.h""

#include <stdlib.h>

typedef struct {
  unsigned char map[256];
  int i;
} A, *AP;

AP __attribute__ ((noinline))
foo (int n)
{
  AP b = (AP)calloc (1, sizeof (A));
  int i;
  for (i = n; i < 256; i++)
    b->map[i] = i;
  return b;
}

int
main()
{
  AP p = foo(3);
  check_vect ();
  return p->map[30] - p->map[20] - p->map[10];
}
","/* { dg-additional-options ""-funroll-loops --param \""max-completely-peeled-insns=400\"""" } */

/* PR tree-optimization/63530 */
/* On armv7 hardware, following options cause run time failure  */
/*   -march=armv7-a -mfloat-abi=hard -mfpu=neon -marm -O2 -ftree-vectorize  */
/*   -funroll-loops --param ""max-completely-peeled-insns=400""  */

#include ""tree-vect.h""

#include <stdlib.h>

typedef struct {
  unsigned char map[256];
  int i;
} A, *AP;

AP __attribute__ ((noinline))
foo (int n)
{
  AP b = (AP)calloc (1, sizeof (A));
  int i;
  for (i = n; i < 256; i++)
    b->map[i] = i;
  return b;
}

int
main()
{
  AP p = foo(3);
  check_vect ();
  return p->map[30] - p->map[20] - p->map[10];
}
"
"/* { dg-do run } */
/* { dg-options ""-O2 -ftree-vectorize -ffast-math -mavx512bw -save-temps"" } */
/* { dg-require-effective-target avx512bw } */

#include ""avx512bw-check.h""

#define N 255
unsigned int yy[10000];

void
__attribute__ ((noinline)) foo (unsigned char s)
{
   unsigned char i;
   for (i = 0; i < s; i++)
     yy[i] = (unsigned int) i;
}

void
avx512bw_test ()
{
  unsigned char i;
  foo (N);
  for (i = 0; i < N; i++)
    if ( (unsigned int)i != yy [i] )
      abort ();
}

/* { dg-final { scan-assembler-times ""vpmovzxbw\[ \\t\]+\[^\n\]*%zmm"" 2 } } */
","/* { dg-do run } */
/* { dg-options ""-O2 -ftree-vectorize -ffast-math -mavx512bw -save-temps"" } */
/* { dg-require-effective-target avx512bw } */

#include ""avx512bw-check.h""

#define N 255
unsigned int yy[10000];

void
__attribute__ ((noinline)) foo (unsigned char s)
{
   unsigned char i;
   for (i = 0; i < s; i++)
     yy[i] = (unsigned int) i;
}

void
avx512bw_test ()
{
  unsigned char i;
  foo (N);
  for (i = 0; i < N; i++)
    if ( (unsigned int)i != yy [i] )
      abort ();
}

/* { dg-final { scan-assembler-times ""vpmovzxbw\[ \\t\]+\[^\n\]*%zmm"" 2 } } */
"
"/* PR tree-optimization/29581 */
/* Origin: gcc.dg/vect/vect-88.c */
/* { dg-do run } */
/* { dg-options ""-O2 -ftree-loop-linear"" } */

extern void abort (void);

#define N 16

int main1 (int n, int *a)
{
  int i, j, k;
  int b[N];

  for (i = 0; i < n; i++)
    {
      for (j = 0; j < n; j++)
	{
	  k = i + n;
	  a[j] = k;
	}
      b[i] = k;
    }


  for (j = 0; j < n; j++)
    if (a[j] != i + n - 1)
      abort();	

  for (j = 0; j < n; j++)
    if (b[j] != j + n)
      abort();	

  return 0;
}

int main (void)
{
  int a[N+1] __attribute__ ((__aligned__(16)));

  main1 (N, a+1);
  main1 (0, a+1);
  main1 (1, a+1);
  main1 (2, a+1);
  main1 (N-1, a+1);

  return 0;
}
","/* PR tree-optimization/29581 */
/* Origin: gcc.dg/vect/vect-88.c */
/* { dg-do run } */
/* { dg-options ""-O2 -ftree-loop-linear"" } */

extern void abort (void);

#define N 16

int main1 (int n, int *a)
{
  int i, j, k;
  int b[N];

  for (i = 0; i < n; i++)
    {
      for (j = 0; j < n; j++)
	{
	  k = i + n;
	  a[j] = k;
	}
      b[i] = k;
    }


  for (j = 0; j < n; j++)
    if (a[j] != i + n - 1)
      abort();	

  for (j = 0; j < n; j++)
    if (b[j] != j + n)
      abort();	

  return 0;
}

int main (void)
{
  int a[N+1] __attribute__ ((__aligned__(16)));

  main1 (N, a+1);
  main1 (0, a+1);
  main1 (1, a+1);
  main1 (2, a+1);
  main1 (N-1, a+1);

  return 0;
}
"
"int a;
void b(char *c)
{
  c += 4;
  for (int i = 0; i < 4; i++)
    a = *c++ = 2;
}
","int a;
void b(char *c)
{
  c += 4;
  for (int i = 0; i < 4; i++)
    a = *c++ = 2;
}
"
"/* PR target/50725 */
/* { dg-do run { target avx_runtime } } */
/* { dg-options ""-O2 -mavx"" } */

extern void abort (void);

typedef int __attribute__((vector_size (32))) m256i;

__attribute__((noinline, noclone)) void
foo (int *x, m256i *y)
{
  asm volatile ("""" : : ""r"" (x), ""r"" (y) : ""memory"");
}

__attribute__((noinline, noclone)) int
bar (int x)
{
  if (x > 20)
    return 24;
  m256i i;
  foo (__builtin_alloca (x), &i);
  return 128;
}

__attribute__((noinline, noclone)) int
baz (int d0, int d1, int d2, int d3, int d4, int d5, int x)
{
  if (x > 20)
    return 24;
  m256i i;
  d0 += d1 + d2 + d3 + d4 + d5; d1 += d0;
  foo (__builtin_alloca (x), &i);
  return 128;
}

int
main ()
{
  if (bar (22) != 24 || bar (20) != 128)
    abort ();
#ifdef __x86_64__
  register long long r10 __asm__ (""r10"") = 0xdeadbeefdeadbeefULL;
  asm volatile ("""" : ""+r"" (r10));
#endif
  if (baz (0, 0, 0, 0, 0, 0, 22) != 24 || baz (0, 0, 0, 0, 0, 0, 20) != 128)
    abort ();
  return 0;
}
","/* PR target/50725 */
/* { dg-do run { target avx_runtime } } */
/* { dg-options ""-O2 -mavx"" } */

extern void abort (void);

typedef int __attribute__((vector_size (32))) m256i;

__attribute__((noinline, noclone)) void
foo (int *x, m256i *y)
{
  asm volatile ("""" : : ""r"" (x), ""r"" (y) : ""memory"");
}

__attribute__((noinline, noclone)) int
bar (int x)
{
  if (x > 20)
    return 24;
  m256i i;
  foo (__builtin_alloca (x), &i);
  return 128;
}

__attribute__((noinline, noclone)) int
baz (int d0, int d1, int d2, int d3, int d4, int d5, int x)
{
  if (x > 20)
    return 24;
  m256i i;
  d0 += d1 + d2 + d3 + d4 + d5; d1 += d0;
  foo (__builtin_alloca (x), &i);
  return 128;
}

int
main ()
{
  if (bar (22) != 24 || bar (20) != 128)
    abort ();
#ifdef __x86_64__
  register long long r10 __asm__ (""r10"") = 0xdeadbeefdeadbeefULL;
  asm volatile ("""" : ""+r"" (r10));
#endif
  if (baz (0, 0, 0, 0, 0, 0, 22) != 24 || baz (0, 0, 0, 0, 0, 0, 20) != 128)
    abort ();
  return 0;
}
"
"/* Machine description pattern tests.  */

/* { dg-do compile } */
/* { dg-options ""-dP"" } */

__attribute__ ((noinline))
void test(char *dest, const char *src)
{
  __builtin_stpcpy (dest, src);
}

/* { dg-final { scan-assembler-times {{[*]movstr}|{vec_vfenesv16qi}} 1 } } */
","/* Machine description pattern tests.  */

/* { dg-do compile } */
/* { dg-options ""-dP"" } */

__attribute__ ((noinline))
void test(char *dest, const char *src)
{
  __builtin_stpcpy (dest, src);
}

/* { dg-final { scan-assembler-times {{[*]movstr}|{vec_vfenesv16qi}} 1 } } */
"
"/* { dg-do compile } */
/* { dg-options ""-fno-strict-overflow -O2 -fdump-tree-optimized"" } */

/* Source: Ian Lance Taylor.  Dual of strict-overflow-6.c.  */

/* We can only simplify the conditional when using strict overflow
   semantics.  */

int
foo (char* p)
{
  return p + 1000 < p;
}

/* { dg-final { scan-tree-dump ""\[+\]\[ \]*1000"" ""optimized"" } } */
","/* { dg-do compile } */
/* { dg-options ""-fno-strict-overflow -O2 -fdump-tree-optimized"" } */

/* Source: Ian Lance Taylor.  Dual of strict-overflow-6.c.  */

/* We can only simplify the conditional when using strict overflow
   semantics.  */

int
foo (char* p)
{
  return p + 1000 < p;
}

/* { dg-final { scan-tree-dump ""\[+\]\[ \]*1000"" ""optimized"" } } */
"
"/* { dg-do compile } */
/* { dg-require-effective-target arm_prefer_ldrd_strd } */
/* { dg-options ""-O2"" }  */
void foo(int a, int b, int* p)
{
  p[2] = a;
  p[3] = b;
}
/* { dg-final { scan-assembler ""strd\\t"" } } */
","/* { dg-do compile } */
/* { dg-require-effective-target arm_prefer_ldrd_strd } */
/* { dg-options ""-O2"" }  */
void foo(int a, int b, int* p)
{
  p[2] = a;
  p[3] = b;
}
/* { dg-final { scan-assembler ""strd\\t"" } } */
"
"/* PR rtl-optimization/83512 */
/* { dg-do compile } */
/* { dg-options ""-O2 -freorder-blocks-algorithm=simple"" } */

int a;

void
foo (int *x)
{
  for (;;)
    {
      for (*x = 0; *x < 1; *x++)
	;
      ++a;
    }
}
","/* PR rtl-optimization/83512 */
/* { dg-do compile } */
/* { dg-options ""-O2 -freorder-blocks-algorithm=simple"" } */

int a;

void
foo (int *x)
{
  for (;;)
    {
      for (*x = 0; *x < 1; *x++)
	;
      ++a;
    }
}
"
"/* { dg-do compile } */
/* { dg-options ""-fopenmp -fdump-tree-ompexp"" } */

extern void bar(int);

void foo (int n)
{
  int i;

  #pragma omp for schedule(guided)
  for (i = 0; i < n; ++i)
    bar(i);
}

/* { dg-final { scan-tree-dump-times ""GOMP_loop_guided_start"" 1 ""ompexp"" } } */
/* { dg-final { scan-tree-dump-times ""GOMP_loop_guided_next"" 1 ""ompexp"" } } */
","/* { dg-do compile } */
/* { dg-options ""-fopenmp -fdump-tree-ompexp"" } */

extern void bar(int);

void foo (int n)
{
  int i;

  #pragma omp for schedule(guided)
  for (i = 0; i < n; ++i)
    bar(i);
}

/* { dg-final { scan-tree-dump-times ""GOMP_loop_guided_start"" 1 ""ompexp"" } } */
/* { dg-final { scan-tree-dump-times ""GOMP_loop_guided_next"" 1 ""ompexp"" } } */
"
"/* { dg-do run } */
/* { dg-options ""-Wl,--defsym,test1=0"" } */

extern void test1 (void) __attribute__((weak));

__attribute__((noinline,noclone))
static void va_pseudo (int flag, ...)
{
  __asm (""nop"":);
}

__attribute__((noinline,noclone))
static void func (void)
{
  va_pseudo (0, 0, 0, 0);

  if (test1)
    __builtin_abort ();
}

int main (void)
{
  func();
  __builtin_exit (0);
  return 0;
}
","/* { dg-do run } */
/* { dg-options ""-Wl,--defsym,test1=0"" } */

extern void test1 (void) __attribute__((weak));

__attribute__((noinline,noclone))
static void va_pseudo (int flag, ...)
{
  __asm (""nop"":);
}

__attribute__((noinline,noclone))
static void func (void)
{
  va_pseudo (0, 0, 0, 0);

  if (test1)
    __builtin_abort ();
}

int main (void)
{
  func();
  __builtin_exit (0);
  return 0;
}
"
"/* { dg-do run } */
/* { dg-additional-options ""-mno-speculate-indirect-jumps"" } */
/* { dg-warning ""'-mno-speculate-indirect-jumps' is deprecated"" """" { target *-*-* } 0 } */

/* Test for deliberate misprediction of indirect calls for ELFv2.  */

int (*f)();

int __attribute__((noinline)) bar ()
{
  return (*f) ();
}

int g ()
{
  return 26;
}

int main ()
{
  f = &g;
  if (bar () != 26)
    __builtin_abort ();

  return 0;
}
","/* { dg-do run } */
/* { dg-additional-options ""-mno-speculate-indirect-jumps"" } */
/* { dg-warning ""'-mno-speculate-indirect-jumps' is deprecated"" """" { target *-*-* } 0 } */

/* Test for deliberate misprediction of indirect calls for ELFv2.  */

int (*f)();

int __attribute__((noinline)) bar ()
{
  return (*f) ();
}

int g ()
{
  return 26;
}

int main ()
{
  f = &g;
  if (bar () != 26)
    __builtin_abort ();

  return 0;
}
"
"/* PR tree-optimization/33856 */
/* Testcase by Martin Michlmayr <tbm@cyrius.com> */

typedef struct z_key
{
  int key;
  int mask;
} z_key;
typedef struct picture_size
{
  z_key key;
} picture_size;

void picture_size_new (picture_size *ps)
{
  z_key key;
  ps->key = key;
}

void picture_sizes_load_default (picture_size *ps)
{
  int i;
  for (i = 0; i < 5; ++i)
    picture_size_new (ps);
}
","/* PR tree-optimization/33856 */
/* Testcase by Martin Michlmayr <tbm@cyrius.com> */

typedef struct z_key
{
  int key;
  int mask;
} z_key;
typedef struct picture_size
{
  z_key key;
} picture_size;

void picture_size_new (picture_size *ps)
{
  z_key key;
  ps->key = key;
}

void picture_sizes_load_default (picture_size *ps)
{
  int i;
  for (i = 0; i < 5; ++i)
    picture_size_new (ps);
}
"
"/* { dg-do compile } */
/* { dg-options ""-O2 -mavx512f"" } */
/* { dg-final { scan-assembler-times ""vpsrld\[ \\t\]+\[^\{\n\]*%zmm\[0-9\]+(?:\n|\[ \\t\]+#)""  1 } } */
/* { dg-final { scan-assembler-times ""vpsrld\[ \\t\]+\[^\{\n\]*%zmm\[0-9\]+\{%k\[1-7\]\}(?:\n|\[ \\t\]+#)"" 1 } } */
/* { dg-final { scan-assembler-times ""vpsrld\[ \\t\]+\[^\{\n\]*%zmm\[0-9\]+\{%k\[1-7\]\}\{z\}(?:\n|\[ \\t\]+#)"" 1 } } */

#include <immintrin.h>

volatile __m512i x;
volatile __m128i y;
volatile __mmask16 m;

void extern
avx512f_test (void)
{
  x = _mm512_srl_epi32 (x, y);
  x = _mm512_mask_srl_epi32 (x, m, x, y);
  x = _mm512_maskz_srl_epi32 (m, x, y);
}
","/* { dg-do compile } */
/* { dg-options ""-O2 -mavx512f"" } */
/* { dg-final { scan-assembler-times ""vpsrld\[ \\t\]+\[^\{\n\]*%zmm\[0-9\]+(?:\n|\[ \\t\]+#)""  1 } } */
/* { dg-final { scan-assembler-times ""vpsrld\[ \\t\]+\[^\{\n\]*%zmm\[0-9\]+\{%k\[1-7\]\}(?:\n|\[ \\t\]+#)"" 1 } } */
/* { dg-final { scan-assembler-times ""vpsrld\[ \\t\]+\[^\{\n\]*%zmm\[0-9\]+\{%k\[1-7\]\}\{z\}(?:\n|\[ \\t\]+#)"" 1 } } */

#include <immintrin.h>

volatile __m512i x;
volatile __m128i y;
volatile __mmask16 m;

void extern
avx512f_test (void)
{
  x = _mm512_srl_epi32 (x, y);
  x = _mm512_mask_srl_epi32 (x, m, x, y);
  x = _mm512_maskz_srl_epi32 (m, x, y);
}
"
"/* PR target/81532 */
/* { dg-do compile { target int128 } } */
/* { dg-options ""-O2 -mavx512dq -mavx512vl -mno-avx512bw"" } */

typedef unsigned __int128 V __attribute__ ((vector_size (64)));

V
foo (V c)
{
  c >>= 0 != c;
  return c;
}
","/* PR target/81532 */
/* { dg-do compile { target int128 } } */
/* { dg-options ""-O2 -mavx512dq -mavx512vl -mno-avx512bw"" } */

typedef unsigned __int128 V __attribute__ ((vector_size (64)));

V
foo (V c)
{
  c >>= 0 != c;
  return c;
}
"
"int
sub1 (int i, int j)
{
  typedef struct
  {
   int  c[i+2];
  }c;
  int x[10], y[10];

  if (j == 2)
    {
      memcpy (x, y, 10 * sizeof (int));
      return sizeof (c);
    }
  else
    return sizeof (c) * 3;
}

int
main ()
{
  typedef struct
  {
   int  c[22];
  }c;
  if (sub1 (20, 3) != sizeof (c)*3)
    abort ();

  return 0;
}
","int
sub1 (int i, int j)
{
  typedef struct
  {
   int  c[i+2];
  }c;
  int x[10], y[10];

  if (j == 2)
    {
      memcpy (x, y, 10 * sizeof (int));
      return sizeof (c);
    }
  else
    return sizeof (c) * 3;
}

int
main ()
{
  typedef struct
  {
   int  c[22];
  }c;
  if (sub1 (20, 3) != sizeof (c)*3)
    abort ();

  return 0;
}
"
"/* { dg-require-effective-target indirect_jumps } */

f(int*x){goto*(char)*x;}
","/* { dg-require-effective-target indirect_jumps } */

f(int*x){goto*(char)*x;}
"
"/* { dg-do run } */
/* { dg-options ""-O -msse2"" } */
/* { dg-require-effective-target sse2 } */

#include ""isa-check.h""
#include ""sse-os-support.h""

typedef long long S;
typedef long long V __attribute__((vector_size(16)));
typedef long long IV __attribute__((vector_size(16)));
typedef union { S s[2]; V v; } U;

static U i[2], b, c;

extern int memcmp (const void *, const void *, __SIZE_TYPE__);
#define assert(T) ((T) || (__builtin_trap (), 0))

#define TEST(E0, E1) \
  b.v = __builtin_shuffle (i[0].v, i[1].v, (IV){E0, E1}); \
  c.s[0] = i[0].s[E0]; \
  c.s[1] = i[0].s[E1]; \
  __asm__("""" : : : ""memory""); \
  assert (memcmp (&b, &c, sizeof(c)) == 0);

#include ""vperm-2-2.inc""

int main()
{
  check_isa ();

  if (!sse_os_support ())
    exit (0);

  i[0].s[0] = 0;
  i[0].s[1] = 1;
  i[0].s[2] = 2;
  i[0].s[3] = 3;

  check();
  return 0;
}
","/* { dg-do run } */
/* { dg-options ""-O -msse2"" } */
/* { dg-require-effective-target sse2 } */

#include ""isa-check.h""
#include ""sse-os-support.h""

typedef long long S;
typedef long long V __attribute__((vector_size(16)));
typedef long long IV __attribute__((vector_size(16)));
typedef union { S s[2]; V v; } U;

static U i[2], b, c;

extern int memcmp (const void *, const void *, __SIZE_TYPE__);
#define assert(T) ((T) || (__builtin_trap (), 0))

#define TEST(E0, E1) \
  b.v = __builtin_shuffle (i[0].v, i[1].v, (IV){E0, E1}); \
  c.s[0] = i[0].s[E0]; \
  c.s[1] = i[0].s[E1]; \
  __asm__("""" : : : ""memory""); \
  assert (memcmp (&b, &c, sizeof(c)) == 0);

#include ""vperm-2-2.inc""

int main()
{
  check_isa ();

  if (!sse_os_support ())
    exit (0);

  i[0].s[0] = 0;
  i[0].s[1] = 1;
  i[0].s[2] = 2;
  i[0].s[3] = 3;

  check();
  return 0;
}
"
"/* { dg-do compile { target { *-*-linux* && { ! ia32 } } } } */
/* { dg-options ""-O2 -mgeneral-regs-only -mtune=generic"" } */

void
 __attribute__ ((interrupt))
fn1 (void *frame)
{
  char fxsave_region [512] __attribute__((aligned(16)));
  __builtin_ia32_fxsave64 (fxsave_region);
}

/* { dg-final { scan-assembler-times ""sub\[lq\]\[\t \]*\\\$400,\[\t \]*%\[re\]sp"" 1 } } */
/* { dg-final { scan-assembler-times ""fxsave64\[\t \]*-120\\(%\[re\]sp\\)"" 1 } } */
/* { dg-final { scan-assembler-times ""add\[lq\]\[\t \]*\\\$400,\[\t \]*%\[re\]sp"" 1 } } */
","/* { dg-do compile { target { *-*-linux* && { ! ia32 } } } } */
/* { dg-options ""-O2 -mgeneral-regs-only -mtune=generic"" } */

void
 __attribute__ ((interrupt))
fn1 (void *frame)
{
  char fxsave_region [512] __attribute__((aligned(16)));
  __builtin_ia32_fxsave64 (fxsave_region);
}

/* { dg-final { scan-assembler-times ""sub\[lq\]\[\t \]*\\\$400,\[\t \]*%\[re\]sp"" 1 } } */
/* { dg-final { scan-assembler-times ""fxsave64\[\t \]*-120\\(%\[re\]sp\\)"" 1 } } */
/* { dg-final { scan-assembler-times ""add\[lq\]\[\t \]*\\\$400,\[\t \]*%\[re\]sp"" 1 } } */
"
"/* { dg-do run } */
/* { dg-options ""-O2 -mavx512vl"" } */
/* { dg-require-effective-target avx512vl } */

#define AVX512VL
#define AVX512F_LEN 256
#define AVX512F_LEN_HALF 128
#include ""avx512f-vmovupd-2.c""

#undef AVX512F_LEN
#undef AVX512F_LEN_HALF

#define AVX512F_LEN 128
#define AVX512F_LEN_HALF 128
#include ""avx512f-vmovupd-2.c""
","/* { dg-do run } */
/* { dg-options ""-O2 -mavx512vl"" } */
/* { dg-require-effective-target avx512vl } */

#define AVX512VL
#define AVX512F_LEN 256
#define AVX512F_LEN_HALF 128
#include ""avx512f-vmovupd-2.c""

#undef AVX512F_LEN
#undef AVX512F_LEN_HALF

#define AVX512F_LEN 128
#define AVX512F_LEN_HALF 128
#include ""avx512f-vmovupd-2.c""
"
"/* PR rtl-optimization/83986 */
/* { dg-do compile } */
/* { dg-options ""-g -O2 -fsched2-use-superblocks -funwind-tables --param max-pending-list-length=1"" } */

int v;

int
foo (int x)
{
  v &= !!v && !!x;
  if (v != 0)
    foo (0);
  return 0;
}
","/* PR rtl-optimization/83986 */
/* { dg-do compile } */
/* { dg-options ""-g -O2 -fsched2-use-superblocks -funwind-tables --param max-pending-list-length=1"" } */

int v;

int
foo (int x)
{
  v &= !!v && !!x;
  if (v != 0)
    foo (0);
  return 0;
}
"
"/* Test for warnings for non-string-literal formats.  */
/* Origin: Joseph Myers <jsm28@cam.ac.uk> */
/* { dg-do compile } */
/* { dg-options ""-std=gnu99 -Wformat -Wformat-nonliteral"" } */

#include ""format.h""

void
foo (char *s, size_t i)
{
  printf ((const char *)i, i); /* { dg-warning ""argument types"" ""non-literal"" } */
  printf (s, i); /* { dg-warning ""argument types"" ""non-literal"" } */
}
","/* Test for warnings for non-string-literal formats.  */
/* Origin: Joseph Myers <jsm28@cam.ac.uk> */
/* { dg-do compile } */
/* { dg-options ""-std=gnu99 -Wformat -Wformat-nonliteral"" } */

#include ""format.h""

void
foo (char *s, size_t i)
{
  printf ((const char *)i, i); /* { dg-warning ""argument types"" ""non-literal"" } */
  printf (s, i); /* { dg-warning ""argument types"" ""non-literal"" } */
}
"
"/* { dg-do compile { target *-*-linux* } } */
/* { dg-options ""-O2 -fno-pic -fno-plt"" } */

extern void bar (void) __attribute__ ((visibility (""hidden"")));

void *
foo (void)
{
  return &bar;
}

/* { dg-final { scan-assembler ""mov\(l|q\)\[ \t\]*\\\$bar,"" } } */
/* { dg-final { scan-assembler-not ""mov\(l|q\)\[ \t\]*bar@GOTPCREL"" { target { ! ia32 } } } } */
/* { dg-final { scan-assembler-not ""movl\[ \t\]*bar@GOT,"" { target { ia32 && got32x_reloc } } } } */
","/* { dg-do compile { target *-*-linux* } } */
/* { dg-options ""-O2 -fno-pic -fno-plt"" } */

extern void bar (void) __attribute__ ((visibility (""hidden"")));

void *
foo (void)
{
  return &bar;
}

/* { dg-final { scan-assembler ""mov\(l|q\)\[ \t\]*\\\$bar,"" } } */
/* { dg-final { scan-assembler-not ""mov\(l|q\)\[ \t\]*bar@GOTPCREL"" { target { ! ia32 } } } } */
/* { dg-final { scan-assembler-not ""movl\[ \t\]*bar@GOT,"" { target { ia32 && got32x_reloc } } } } */
"
"/* { dg-options ""-mabi=eabi -mgp32 -mlong64"" } */
#include ""abi-main.h""
","/* { dg-options ""-mabi=eabi -mgp32 -mlong64"" } */
#include ""abi-main.h""
"
"/* { dg-do compile { target int128 } } */
/* { dg-options ""-O2 -msse2 -mtune=generic -dp"" } */

struct foo
{
  __int128 i;
}__attribute__ ((packed));

extern struct foo x;

void
foo (void)
{
  x.i = 0;
}

/* { dg-final { scan-assembler-times ""movv1ti_internal"" 2 } } */
/* { dg-final { scan-assembler-not ""\\*movdi_internal"" { target nonpic } } } */
","/* { dg-do compile { target int128 } } */
/* { dg-options ""-O2 -msse2 -mtune=generic -dp"" } */

struct foo
{
  __int128 i;
}__attribute__ ((packed));

extern struct foo x;

void
foo (void)
{
  x.i = 0;
}

/* { dg-final { scan-assembler-times ""movv1ti_internal"" 2 } } */
/* { dg-final { scan-assembler-not ""\\*movdi_internal"" { target nonpic } } } */
"
"/* { dg-do run } */
/* { dg-options ""-O2 -mavx512vl"" } */
/* { dg-require-effective-target avx512vl } */

#define AVX512VL
#define AVX512F_LEN 256
#define AVX512F_LEN_HALF 128
#include ""avx512f-vcvtps2dq-2.c""

#undef AVX512F_LEN
#undef AVX512F_LEN_HALF

#define AVX512F_LEN 128
#define AVX512F_LEN_HALF 128
#include ""avx512f-vcvtps2dq-2.c""
","/* { dg-do run } */
/* { dg-options ""-O2 -mavx512vl"" } */
/* { dg-require-effective-target avx512vl } */

#define AVX512VL
#define AVX512F_LEN 256
#define AVX512F_LEN_HALF 128
#include ""avx512f-vcvtps2dq-2.c""

#undef AVX512F_LEN
#undef AVX512F_LEN_HALF

#define AVX512F_LEN 128
#define AVX512F_LEN_HALF 128
#include ""avx512f-vcvtps2dq-2.c""
"
"/* { dg-do compile } */
/* { dg-options ""-O1 -funroll-loops -ftree-vectorize -fcompare-debug"" } */
/* { dg-xfail-if """" { powerpc-ibm-aix* } } */

int seed;

static inline int hash(const char *str)
{
  int h = seed++;
  int i = 12;
  while (i--)
    h += (h << 3) ^ *str++;
  return h;
}

void f(const char *str, int *h)
{
  int i = 6;
  while (i--)
    *h++ = hash(str);
}
","/* { dg-do compile } */
/* { dg-options ""-O1 -funroll-loops -ftree-vectorize -fcompare-debug"" } */
/* { dg-xfail-if """" { powerpc-ibm-aix* } } */

int seed;

static inline int hash(const char *str)
{
  int h = seed++;
  int i = 12;
  while (i--)
    h += (h << 3) ^ *str++;
  return h;
}

void f(const char *str, int *h)
{
  int i = 6;
  while (i--)
    *h++ = hash(str);
}
"
"/* Verify that we offer suggestions for misspelled sanitizer options
   (PR driver/78877).  */

/* { dg-do compile } */
/* { dg-options ""-fsanitize=addres,nul,this-is-not-a-sanitizer-option"" } */
/* { dg-error ""unrecognized argument to -fsanitize= option: .addres.; did you mean .address."" """" { target *-*-* } 0 } */
/* { dg-error ""unrecognized argument to -fsanitize= option: .nul.; did you mean .null."" """" { target *-*-* } 0 } */
/* { dg-error ""unrecognized argument to -fsanitize= option: .this-is-not-a-sanitizer-option."" """" { target *-*-* } 0 } */
","/* Verify that we offer suggestions for misspelled sanitizer options
   (PR driver/78877).  */

/* { dg-do compile } */
/* { dg-options ""-fsanitize=addres,nul,this-is-not-a-sanitizer-option"" } */
/* { dg-error ""unrecognized argument to -fsanitize= option: .addres.; did you mean .address."" """" { target *-*-* } 0 } */
/* { dg-error ""unrecognized argument to -fsanitize= option: .nul.; did you mean .null."" """" { target *-*-* } 0 } */
/* { dg-error ""unrecognized argument to -fsanitize= option: .this-is-not-a-sanitizer-option."" """" { target *-*-* } 0 } */
"
"/* { dg-require-effective-target untyped_assembly } */
extern void abort(void);
			 
typedef struct
{
  unsigned int unchanging : 1;
} struc, *rtx;

rtx dummy ( int *a, rtx *b)
{
  *a = 1;
  *b = (rtx)7;
  return (rtx)1;
}

void bogus (insn, thread, delay_list)
     rtx insn;
     rtx thread;
     rtx delay_list;
{
  rtx new_thread;
  int must_annul;

  delay_list = dummy ( &must_annul, &new_thread);
  if (delay_list == 0 &&  new_thread )
    {
      thread = new_thread;
    }
  if (delay_list && must_annul)
    insn->unchanging = 1;
  if (new_thread != thread )
    abort();
}

int main()
{
  struc baz;
  bogus (&baz, (rtx)7, 0);
  exit(0);
  return 0;
}
","/* { dg-require-effective-target untyped_assembly } */
extern void abort(void);
			 
typedef struct
{
  unsigned int unchanging : 1;
} struc, *rtx;

rtx dummy ( int *a, rtx *b)
{
  *a = 1;
  *b = (rtx)7;
  return (rtx)1;
}

void bogus (insn, thread, delay_list)
     rtx insn;
     rtx thread;
     rtx delay_list;
{
  rtx new_thread;
  int must_annul;

  delay_list = dummy ( &must_annul, &new_thread);
  if (delay_list == 0 &&  new_thread )
    {
      thread = new_thread;
    }
  if (delay_list && must_annul)
    insn->unchanging = 1;
  if (new_thread != thread )
    abort();
}

int main()
{
  struc baz;
  bogus (&baz, (rtx)7, 0);
  exit(0);
  return 0;
}
"
"/* { dg-do run } */
/* { dg-options ""-mavx2 -O2"" } */
/* { dg-require-effective-target avx2 } */

#include ""avx2-check.h""

static void
compute_movsxbd (char *s, int *r)
{
  int i;

  for (i = 0; i < 8; i++)
    r[i] = s[i];
}

static void
avx2_test (void)
{
  union128i_b s;
  union256i_d res;
  int res_ref[8];

  s.x = _mm_set_epi8 (1, 2, 3, 4, 20, -50, 6, 8, 1, 2, 3, 4, -20, 5, 6, 8);

  res.x = _mm256_cvtepi8_epi32 (s.x);

  compute_movsxbd (s.a, res_ref);

  if (check_union256i_d (res, res_ref))
    abort ();
}
","/* { dg-do run } */
/* { dg-options ""-mavx2 -O2"" } */
/* { dg-require-effective-target avx2 } */

#include ""avx2-check.h""

static void
compute_movsxbd (char *s, int *r)
{
  int i;

  for (i = 0; i < 8; i++)
    r[i] = s[i];
}

static void
avx2_test (void)
{
  union128i_b s;
  union256i_d res;
  int res_ref[8];

  s.x = _mm_set_epi8 (1, 2, 3, 4, 20, -50, 6, 8, 1, 2, 3, 4, -20, 5, 6, 8);

  res.x = _mm256_cvtepi8_epi32 (s.x);

  compute_movsxbd (s.a, res_ref);

  if (check_union256i_d (res, res_ref))
    abort ();
}
"
"#include <arm_neon.h>

/* { dg-do compile } */
/* { dg-skip-if """" { *-*-* } { ""-fno-fat-lto-objects"" } } */

void
f_vst4_lane_f32 (float32_t * p, float32x2x4_t v)
{
  /* { dg-error ""lane 2 out of range 0 - 1"" """" { target *-*-* } 0 } */
  vst4_lane_f32 (p, v, 2);
  /* { dg-error ""lane -1 out of range 0 - 1"" """" { target *-*-* } 0 } */
  vst4_lane_f32 (p, v, -1);
  return;
}
","#include <arm_neon.h>

/* { dg-do compile } */
/* { dg-skip-if """" { *-*-* } { ""-fno-fat-lto-objects"" } } */

void
f_vst4_lane_f32 (float32_t * p, float32x2x4_t v)
{
  /* { dg-error ""lane 2 out of range 0 - 1"" """" { target *-*-* } 0 } */
  vst4_lane_f32 (p, v, 2);
  /* { dg-error ""lane -1 out of range 0 - 1"" """" { target *-*-* } 0 } */
  vst4_lane_f32 (p, v, -1);
  return;
}
"
"/* PR tree-optimization/56899 */

#if __SIZEOF_INT__ == 4 && __CHAR_BIT__ == 8
__attribute__((noinline, noclone)) void
f1 (int v)
{
  int x = -214748365 * (v - 1);
  if (x != -1932735285)
    __builtin_abort ();
}

__attribute__((noinline, noclone)) void
f2 (int v)
{
  int x = 214748365 * (v + 1);
  if (x != -1932735285)
    __builtin_abort ();
}

__attribute__((noinline, noclone)) void
f3 (unsigned int v)
{
  unsigned int x = -214748365U * (v - 1);
  if (x != -1932735285U)
    __builtin_abort ();
}

__attribute__((noinline, noclone)) void
f4 (unsigned int v)
{
  unsigned int x = 214748365U * (v + 1);
  if (x != -1932735285U)
    __builtin_abort ();
}
#endif

int
main ()
{
#if __SIZEOF_INT__ == 4 && __CHAR_BIT__ == 8
  f1 (10);
  f2 (-10);
  f3 (10);
  f4 (-10U);
#endif
  return 0;
}
","/* PR tree-optimization/56899 */

#if __SIZEOF_INT__ == 4 && __CHAR_BIT__ == 8
__attribute__((noinline, noclone)) void
f1 (int v)
{
  int x = -214748365 * (v - 1);
  if (x != -1932735285)
    __builtin_abort ();
}

__attribute__((noinline, noclone)) void
f2 (int v)
{
  int x = 214748365 * (v + 1);
  if (x != -1932735285)
    __builtin_abort ();
}

__attribute__((noinline, noclone)) void
f3 (unsigned int v)
{
  unsigned int x = -214748365U * (v - 1);
  if (x != -1932735285U)
    __builtin_abort ();
}

__attribute__((noinline, noclone)) void
f4 (unsigned int v)
{
  unsigned int x = 214748365U * (v + 1);
  if (x != -1932735285U)
    __builtin_abort ();
}
#endif

int
main ()
{
#if __SIZEOF_INT__ == 4 && __CHAR_BIT__ == 8
  f1 (10);
  f2 (-10);
  f3 (10);
  f4 (-10U);
#endif
  return 0;
}
"
"/* { dg-lto-do link } */
/* { dg-lto-options {{-flto -r -O}} } */
/* { dg-extra-ld-options ""-flinker-output=nolto-rel"" } */

extern void baz (void);

static void __attribute__ ((constructor))
bar (void)
{
  baz ();
}

void
foo (void)
{
  bar ();
}
","/* { dg-lto-do link } */
/* { dg-lto-options {{-flto -r -O}} } */
/* { dg-extra-ld-options ""-flinker-output=nolto-rel"" } */

extern void baz (void);

static void __attribute__ ((constructor))
bar (void)
{
  baz ();
}

void
foo (void)
{
  bar ();
}
"
"/* { dg-options ""-mabi=o64 -mlong64 -mabicalls -mno-shared -mno-plt"" } */
/* { dg-error ""is incompatible with"" """" { target *-*-* } 0 } */
#include ""abi-main.h""
","/* { dg-options ""-mabi=o64 -mlong64 -mabicalls -mno-shared -mno-plt"" } */
/* { dg-error ""is incompatible with"" """" { target *-*-* } 0 } */
#include ""abi-main.h""
"
"/* { dg-do run } */

/* This testcase checks that allocas and VLAs inside loop are correctly unpoisoned.  */

#include <assert.h>
#include <stdint.h>
#include <stdlib.h>
#include <stdio.h>
#include ""sanitizer/asan_interface.h""

void *top, *bot;
volatile int thirty_two = 32;

__attribute__((noinline)) void foo(int len) {
  char x;
  top = &x;
  volatile char array[len];
  assert(!((uintptr_t) array & 31L));
  alloca(len);
  for (int i = 0; i < thirty_two; ++i) {
    char array[i];
    bot = array;
    /* Just to prevent optimization.  */
    printf(""%p\n"", bot);
    assert(!((uintptr_t) bot & 31L));
  }
}

int main(int argc, char **argv) {
  foo(thirty_two);
  void *q = __asan_region_is_poisoned(bot, (char *)top - (char *)bot);
  assert(!q);
  return 0;
}
","/* { dg-do run } */

/* This testcase checks that allocas and VLAs inside loop are correctly unpoisoned.  */

#include <assert.h>
#include <stdint.h>
#include <stdlib.h>
#include <stdio.h>
#include ""sanitizer/asan_interface.h""

void *top, *bot;
volatile int thirty_two = 32;

__attribute__((noinline)) void foo(int len) {
  char x;
  top = &x;
  volatile char array[len];
  assert(!((uintptr_t) array & 31L));
  alloca(len);
  for (int i = 0; i < thirty_two; ++i) {
    char array[i];
    bot = array;
    /* Just to prevent optimization.  */
    printf(""%p\n"", bot);
    assert(!((uintptr_t) bot & 31L));
  }
}

int main(int argc, char **argv) {
  foo(thirty_two);
  void *q = __asan_region_is_poisoned(bot, (char *)top - (char *)bot);
  assert(!q);
  return 0;
}
"
"/* Test declaration specifiers.  Test cases that used to be handled in
   a loop in grokdeclarator.  Pedantic cases.  */
/* Origin: Joseph Myers <jsm@polyomino.org.uk> */
/* { dg-do compile } */
/* { dg-options ""-std=gnu89 -pedantic"" } */

/* These should all be diagnosed, but only once, not for every
   identifier declared.  */

const const int x0, /* { dg-warning ""duplicate"" } */
x1;

long long x2, /* { dg-warning ""long long"" } */
x3;
","/* Test declaration specifiers.  Test cases that used to be handled in
   a loop in grokdeclarator.  Pedantic cases.  */
/* Origin: Joseph Myers <jsm@polyomino.org.uk> */
/* { dg-do compile } */
/* { dg-options ""-std=gnu89 -pedantic"" } */

/* These should all be diagnosed, but only once, not for every
   identifier declared.  */

const const int x0, /* { dg-warning ""duplicate"" } */
x1;

long long x2, /* { dg-warning ""long long"" } */
x3;
"
"#include ""lib/strrchr.c""
#ifdef __vxworks
/* The RTP C library uses bzero, bfill and bcopy, all of which are defined
   in the same file as rindex.  */
#include ""lib/bzero.c""
#include ""lib/bfill.c""
#include ""lib/memmove.c""
#endif
","#include ""lib/strrchr.c""
#ifdef __vxworks
/* The RTP C library uses bzero, bfill and bcopy, all of which are defined
   in the same file as rindex.  */
#include ""lib/bzero.c""
#include ""lib/bfill.c""
#include ""lib/memmove.c""
#endif
"
"#include <arm_neon.h>

/* { dg-do compile } */
/* { dg-skip-if """" { *-*-* } { ""-fno-fat-lto-objects"" } } */
/* { dg-skip-if """" { arm*-*-* } } */

uint64x2x3_t
f_vld3q_lane_u64 (uint64_t * p, uint64x2x3_t v)
{
  uint64x2x3_t res;
  /* { dg-error ""lane 2 out of range 0 - 1"" """" { target *-*-* } 0 } */
  res = vld3q_lane_u64 (p, v, 2);
  /* { dg-error ""lane -1 out of range 0 - 1"" """" { target *-*-* } 0 } */
  res = vld3q_lane_u64 (p, v, -1);
  return res;
}
","#include <arm_neon.h>

/* { dg-do compile } */
/* { dg-skip-if """" { *-*-* } { ""-fno-fat-lto-objects"" } } */
/* { dg-skip-if """" { arm*-*-* } } */

uint64x2x3_t
f_vld3q_lane_u64 (uint64_t * p, uint64x2x3_t v)
{
  uint64x2x3_t res;
  /* { dg-error ""lane 2 out of range 0 - 1"" """" { target *-*-* } 0 } */
  res = vld3q_lane_u64 (p, v, 2);
  /* { dg-error ""lane -1 out of range 0 - 1"" """" { target *-*-* } 0 } */
  res = vld3q_lane_u64 (p, v, -1);
  return res;
}
"
"/* { dg-do assemble } */
/* { dg-options ""-O2 -masm=intel"" } */
/* { dg-require-effective-target lp64 } */
/* { dg-require-effective-target masm_intel } */

long
foo2 (void)
{
  return *(volatile int *) 0xFEE00000;
}
","/* { dg-do assemble } */
/* { dg-options ""-O2 -masm=intel"" } */
/* { dg-require-effective-target lp64 } */
/* { dg-require-effective-target masm_intel } */

long
foo2 (void)
{
  return *(volatile int *) 0xFEE00000;
}
"
"/* PR c/77423 */
/* { dg-do compile } */
/* { dg-options ""-Wlogical-not-parentheses"" } */

#ifndef __cplusplus
# define bool _Bool
#endif

int
f (int a, bool b, bool c)
{
  int r = 0;

  r += !a == (b | c);
  r += !a == (b ^ c);
  r += !a == (b & c);
  r += !a == ~b;
  r += !a == ~(int) b;
  r += !a == ((b & c) | c);
  r += !a == ((b & c) | (b ^ c));
  r += !a == (int) (b ^ c);
  r += !a == (int) ~b;
  r += !a == ~~b;
  r += !a == ~(b | c);
  r += !a == ~(b | (a == 1));
  r += !a == ~(a == 1);

  r += !a == ((b & c) | (b ^ a)); /* { dg-warning ""logical not is only applied to the left hand side of comparison"" } */

  return r;
}
","/* PR c/77423 */
/* { dg-do compile } */
/* { dg-options ""-Wlogical-not-parentheses"" } */

#ifndef __cplusplus
# define bool _Bool
#endif

int
f (int a, bool b, bool c)
{
  int r = 0;

  r += !a == (b | c);
  r += !a == (b ^ c);
  r += !a == (b & c);
  r += !a == ~b;
  r += !a == ~(int) b;
  r += !a == ((b & c) | c);
  r += !a == ((b & c) | (b ^ c));
  r += !a == (int) (b ^ c);
  r += !a == (int) ~b;
  r += !a == ~~b;
  r += !a == ~(b | c);
  r += !a == ~(b | (a == 1));
  r += !a == ~(a == 1);

  r += !a == ((b & c) | (b ^ a)); /* { dg-warning ""logical not is only applied to the left hand side of comparison"" } */

  return r;
}
"
"/* PR target/77476 */
/* { dg-do run } */
/* { dg-options ""-O2 -mavx512bw"" } */
/* { dg-require-effective-target avx512bw } */

#include ""avx512bw-check.h""
#define PR77476_TEST avx512bw_test

#include ""avx512f-pr77476.c""
","/* PR target/77476 */
/* { dg-do run } */
/* { dg-options ""-O2 -mavx512bw"" } */
/* { dg-require-effective-target avx512bw } */

#include ""avx512bw-check.h""
#define PR77476_TEST avx512bw_test

#include ""avx512f-pr77476.c""
"
"/* PR tree-optimization/42078 */
/* { dg-do compile } */
/* { dg-options ""-g -O -ffast-math"" } */

double sqrt (double x);

float
foo (float x)
{
  float y = sqrt (x);
  return x / y;
}

inline float
bar (float x)
{
  float y = sqrt (x);
  float a = y;
  float b = y;
  float c = y;
  return x / y;
}
","/* PR tree-optimization/42078 */
/* { dg-do compile } */
/* { dg-options ""-g -O -ffast-math"" } */

double sqrt (double x);

float
foo (float x)
{
  float y = sqrt (x);
  return x / y;
}

inline float
bar (float x)
{
  float y = sqrt (x);
  float a = y;
  float b = y;
  float c = y;
  return x / y;
}
"
"/* { dg-do compile } */
/* { dg-options ""-pg -mmcount-ra-address -mabi=64 -mno-abicalls"" } */
/* { dg-skip-if ""requiring a specific frame layout makes this a code quality test"" { *-*-* } { ""-O0"" } { """" } } */
/* { dg-final { scan-assembler ""\tdla\t\\\$12,200008\\(\\\$sp\\)"" } } */
int foo (int *);
NOMIPS16 int bar(int i)
{
  int big[50000];
  return foo (big) + 2;
}
","/* { dg-do compile } */
/* { dg-options ""-pg -mmcount-ra-address -mabi=64 -mno-abicalls"" } */
/* { dg-skip-if ""requiring a specific frame layout makes this a code quality test"" { *-*-* } { ""-O0"" } { """" } } */
/* { dg-final { scan-assembler ""\tdla\t\\\$12,200008\\(\\\$sp\\)"" } } */
int foo (int *);
NOMIPS16 int bar(int i)
{
  int big[50000];
  return foo (big) + 2;
}
"
"/* { dg-do run } */
/* { dg-options ""-falign-labels=8"" } */

/* On ARMv7-A CPUs, this test resulted in incorrect code generation.
   The code generated for the switch statement expected the jump table
   to immediately follow the jump instruction, but -falign-labels
   caused the label preceding the table to be aligned.  */
/* M68K and fido only support -falign-labels argument <= 2.  */

volatile int x;

int main(void)
{
  int y;

  x = 0;

  switch(x)
    {
    case 0:
      y = 2 * x;
      break;
    case 1:
      y = -3 * x;
      break;
    case 2:
      y = x + 5;
      break;
    case 3:
      y = x - 7;
      break;
    default:
      break;
    }

  x = y;

  return 0;
}
","/* { dg-do run } */
/* { dg-options ""-falign-labels=8"" } */

/* On ARMv7-A CPUs, this test resulted in incorrect code generation.
   The code generated for the switch statement expected the jump table
   to immediately follow the jump instruction, but -falign-labels
   caused the label preceding the table to be aligned.  */
/* M68K and fido only support -falign-labels argument <= 2.  */

volatile int x;

int main(void)
{
  int y;

  x = 0;

  switch(x)
    {
    case 0:
      y = 2 * x;
      break;
    case 1:
      y = -3 * x;
      break;
    case 2:
      y = x + 5;
      break;
    case 3:
      y = x - 7;
      break;
    default:
      break;
    }

  x = y;

  return 0;
}
"
"/* PR middle-end/48389 */
/* { dg-do compile } */
/* { dg-options ""-O -mtune=pentiumpro -Wno-abi"" } */
/* { dg-require-effective-target ia32 } */
typedef float V2SF __attribute__ ((vector_size (128)));
V2SF foo (int x, V2SF a)
{
  V2SF b = {};
  if (x & 42)
    b = a;
  a += b;
  return a;
}
","/* PR middle-end/48389 */
/* { dg-do compile } */
/* { dg-options ""-O -mtune=pentiumpro -Wno-abi"" } */
/* { dg-require-effective-target ia32 } */
typedef float V2SF __attribute__ ((vector_size (128)));
V2SF foo (int x, V2SF a)
{
  V2SF b = {};
  if (x & 42)
    b = a;
  a += b;
  return a;
}
"
"/* Simplified from PR target/5309.  */

/* { dg-do compile } */
/* { dg-options ""-O2 -mcpu=ultrasparc"" } */

extern long bar (unsigned int);

long
foo (long x, unsigned int y)
{
  return *(((long *) (bar (y) - 1)) + 1 + (x >> 2) % 359);
}
","/* Simplified from PR target/5309.  */

/* { dg-do compile } */
/* { dg-options ""-O2 -mcpu=ultrasparc"" } */

extern long bar (unsigned int);

long
foo (long x, unsigned int y)
{
  return *(((long *) (bar (y) - 1)) + 1 + (x >> 2) % 359);
}
"
"/* { dg-do compile } */
/* { dg-skip-if ""avoid conflicting multilib options"" { *-*-* } { ""-march=*"" } { ""-march=armv6z"" } } */
/* { dg-skip-if ""avoid conflicting multilib options"" { *-*-* } { ""-mthumb"" } { """" } } */
/* { dg-options ""-marm"" } */
/* { dg-add-options arm_arch_v6z } */

#define NEED_ARM_ARCH
#define VALUE_ARM_ARCH 6

#define NEED_ARM_ARCH_ISA_ARM
#define VALUE_ARM_ARCH_ISA_ARM 1

#define NEED_ARM_ARCH_ISA_THUMB
#define VALUE_ARM_ARCH_ISA_THUMB 1

#define NEED_ARM_FEATURE_UNALIGNED
#define VALUE_ARM_FEATURE_UNALIGNED 1

#define NEED_ARM_FEATURE_LDREX
#define VALUE_ARM_FEATURE_LDREX 4

#define NEED_ARM_FEATURE_CLZ
#define VALUE_ARM_FEATURE_CLZ 1

#define NEED_ARM_FEATURE_DSP
#define VALUE_ARM_FEATURE_DSP 1

#define NEED_ARM_FEATURE_SIMD32
#define VALUE_ARM_FEATURE_SIMD32 1

#define NEED_ARM_FEATURE_QBIT
#define VALUE_ARM_FEATURE_QBIT 1

#define NEED_ARM_FEATURE_SAT
#define VALUE_ARM_FEATURE_SAT 1

#include ""ftest-support.h""
","/* { dg-do compile } */
/* { dg-skip-if ""avoid conflicting multilib options"" { *-*-* } { ""-march=*"" } { ""-march=armv6z"" } } */
/* { dg-skip-if ""avoid conflicting multilib options"" { *-*-* } { ""-mthumb"" } { """" } } */
/* { dg-options ""-marm"" } */
/* { dg-add-options arm_arch_v6z } */

#define NEED_ARM_ARCH
#define VALUE_ARM_ARCH 6

#define NEED_ARM_ARCH_ISA_ARM
#define VALUE_ARM_ARCH_ISA_ARM 1

#define NEED_ARM_ARCH_ISA_THUMB
#define VALUE_ARM_ARCH_ISA_THUMB 1

#define NEED_ARM_FEATURE_UNALIGNED
#define VALUE_ARM_FEATURE_UNALIGNED 1

#define NEED_ARM_FEATURE_LDREX
#define VALUE_ARM_FEATURE_LDREX 4

#define NEED_ARM_FEATURE_CLZ
#define VALUE_ARM_FEATURE_CLZ 1

#define NEED_ARM_FEATURE_DSP
#define VALUE_ARM_FEATURE_DSP 1

#define NEED_ARM_FEATURE_SIMD32
#define VALUE_ARM_FEATURE_SIMD32 1

#define NEED_ARM_FEATURE_QBIT
#define VALUE_ARM_FEATURE_QBIT 1

#define NEED_ARM_FEATURE_SAT
#define VALUE_ARM_FEATURE_SAT 1

#include ""ftest-support.h""
"
"/* PR c/64279 */
/* { dg-do compile } */
/* { dg-options ""-Wduplicated-branches"" } */

#define DEBUG(msg) ;

void
f (int i)
{
  if (i > 9)
    {
      DEBUG (""foo"");
    }
  else
    {
      DEBUG (""bar"");
    }
}
","/* PR c/64279 */
/* { dg-do compile } */
/* { dg-options ""-Wduplicated-branches"" } */

#define DEBUG(msg) ;

void
f (int i)
{
  if (i > 9)
    {
      DEBUG (""foo"");
    }
  else
    {
      DEBUG (""bar"");
    }
}
"
"/* Origin: Joseph Myers <jsm28@cam.ac.uk>.  */
/* As an extension, GCC allows a struct or union to be cast to its own
   type, but failed to allow this when a typedef was involved.
   Reported as PR c/2735 by <cowan@ccil.org>.  */
union u { int i; };
typedef union u uu;
union u a;
uu b;

void
foo (void)
{
  a = (union u) b;
  a = (uu) b;
  b = (union u) a;
  b = (uu) a;
}
","/* Origin: Joseph Myers <jsm28@cam.ac.uk>.  */
/* As an extension, GCC allows a struct or union to be cast to its own
   type, but failed to allow this when a typedef was involved.
   Reported as PR c/2735 by <cowan@ccil.org>.  */
union u { int i; };
typedef union u uu;
union u a;
uu b;

void
foo (void)
{
  a = (union u) b;
  a = (uu) b;
  b = (union u) a;
  b = (uu) a;
}
"
"/* { dg-additional-options ""-msse4"" { target sse4_runtime } } */

#include ""tree-vect.h""

#define N 128

static inline void
vfoo64 (unsigned long long* a)
{
  int i = 0;
  for (i = 0; i < N; ++i)
    a[i] = __builtin_bswap64 (a[i]);
}

int
main (void)
{
  unsigned long long arr[N];
  unsigned long long expect[N];
  int i;

  check_vect ();

  for (i = 0; i < N; ++i)
    {
      arr[i] = i;
      expect[i] = __builtin_bswap64 (i);
      asm volatile ("""" ::: ""memory"");
    }

  vfoo64 (arr);

  for (i = 0; i < N; ++i)
    {
      if (arr[i] != expect[i])
        abort ();
    }

  return 0;
}

/* { dg-final { scan-tree-dump-times ""vectorized 1 loops"" 1 ""vect"" { target { vect_bswap || sse4_runtime } } } } */
","/* { dg-additional-options ""-msse4"" { target sse4_runtime } } */

#include ""tree-vect.h""

#define N 128

static inline void
vfoo64 (unsigned long long* a)
{
  int i = 0;
  for (i = 0; i < N; ++i)
    a[i] = __builtin_bswap64 (a[i]);
}

int
main (void)
{
  unsigned long long arr[N];
  unsigned long long expect[N];
  int i;

  check_vect ();

  for (i = 0; i < N; ++i)
    {
      arr[i] = i;
      expect[i] = __builtin_bswap64 (i);
      asm volatile ("""" ::: ""memory"");
    }

  vfoo64 (arr);

  for (i = 0; i < N; ++i)
    {
      if (arr[i] != expect[i])
        abort ();
    }

  return 0;
}

/* { dg-final { scan-tree-dump-times ""vectorized 1 loops"" 1 ""vect"" { target { vect_bswap || sse4_runtime } } } } */
"
"/* { dg-do compile } */
/* { dg-options ""-fgnu-tm -O -fdump-tree-tmmark"" } */

struct large { int x[100]; };
struct large large_global;
extern struct large function (void) __attribute__((transaction_safe));

void f()
{
  __transaction_atomic {
      large_global = function();
  }
}

/* { dg-final { scan-tree-dump-times ""memcpyRnWt \\\(&large_global,"" 1 ""tmmark"" } } */
","/* { dg-do compile } */
/* { dg-options ""-fgnu-tm -O -fdump-tree-tmmark"" } */

struct large { int x[100]; };
struct large large_global;
extern struct large function (void) __attribute__((transaction_safe));

void f()
{
  __transaction_atomic {
      large_global = function();
  }
}

/* { dg-final { scan-tree-dump-times ""memcpyRnWt \\\(&large_global,"" 1 ""tmmark"" } } */
"
"void * memcpy (void *, void *, __SIZE_TYPE__);
void bar (void *p, void *q, unsigned s)
{
  memcpy (p, q, s);
}
","void * memcpy (void *, void *, __SIZE_TYPE__);
void bar (void *p, void *q, unsigned s)
{
  memcpy (p, q, s);
}
"
"/* { dg-do compile } */
/* { dg-require-effective-target arm_neon_ok } */
/* { dg-options ""-O2 -ftree-vectorize"" } */
/* { dg-add-options arm_neon } */
/* { dg-final { scan-assembler ""vshr\.s32.*#3"" } } */

/* Verify that VSHR immediate is used.  */
void f1(int n, int x[], int y[]) {
  int i;
  for (i = 0; i < n; ++i)
    y[i] = x[i] >> 3;
}
","/* { dg-do compile } */
/* { dg-require-effective-target arm_neon_ok } */
/* { dg-options ""-O2 -ftree-vectorize"" } */
/* { dg-add-options arm_neon } */
/* { dg-final { scan-assembler ""vshr\.s32.*#3"" } } */

/* Verify that VSHR immediate is used.  */
void f1(int n, int x[], int y[]) {
  int i;
  for (i = 0; i < n; ++i)
    y[i] = x[i] >> 3;
}
"
"/* PR 10201 */

extern struct _zend_compiler_globals compiler_globals;
typedef struct _zend_executor_globals zend_executor_globals;
extern zend_executor_globals executor_globals;

typedef struct _zend_ptr_stack {
        int top;
        void **top_element;
} zend_ptr_stack;
struct _zend_compiler_globals {
};
struct _zend_executor_globals {
        int *uninitialized_zval_ptr;
        zend_ptr_stack argument_stack;
};

static inline void safe_free_zval_ptr(int *p)
{
        if (p!=(executor_globals.uninitialized_zval_ptr)) {
        }
}
zend_executor_globals executor_globals;
static inline void zend_ptr_stack_clear_multiple(void)
{
        executor_globals.argument_stack.top -= 2;
}
","/* PR 10201 */

extern struct _zend_compiler_globals compiler_globals;
typedef struct _zend_executor_globals zend_executor_globals;
extern zend_executor_globals executor_globals;

typedef struct _zend_ptr_stack {
        int top;
        void **top_element;
} zend_ptr_stack;
struct _zend_compiler_globals {
};
struct _zend_executor_globals {
        int *uninitialized_zval_ptr;
        zend_ptr_stack argument_stack;
};

static inline void safe_free_zval_ptr(int *p)
{
        if (p!=(executor_globals.uninitialized_zval_ptr)) {
        }
}
zend_executor_globals executor_globals;
static inline void zend_ptr_stack_clear_multiple(void)
{
        executor_globals.argument_stack.top -= 2;
}
"
"/* { dg-options ""-mshared -mabi=64"" } */
/* { dg-final { scan-assembler-not ""(\\\$28|%gp_rel|%got)"" } } */
/* { dg-final { scan-assembler-not ""\tjrc?\t\\\$1\n"" } } */

#include ""branch-helper.h""

NOCOMPRESSION void
foo (int (*bar) (void), int *x)
{
  *x = bar ();
  if (__builtin_expect (*x == 0, 1))
    OCCUPY_0x1fff8;
}
","/* { dg-options ""-mshared -mabi=64"" } */
/* { dg-final { scan-assembler-not ""(\\\$28|%gp_rel|%got)"" } } */
/* { dg-final { scan-assembler-not ""\tjrc?\t\\\$1\n"" } } */

#include ""branch-helper.h""

NOCOMPRESSION void
foo (int (*bar) (void), int *x)
{
  *x = bar ();
  if (__builtin_expect (*x == 0, 1))
    OCCUPY_0x1fff8;
}
"
"/* { dg-do run } */
/* { dg-options ""-O2"" } */
/* { dg-require-effective-target tls_runtime } */
/* { dg-add-options tls } */

__thread double thrtest[81];
int main ()
{
  double *p, *e;
  e = &thrtest[81];
  for (p = &thrtest[0]; p < e; ++p)
    *p = 1.0;
  return 0;
}
","/* { dg-do run } */
/* { dg-options ""-O2"" } */
/* { dg-require-effective-target tls_runtime } */
/* { dg-add-options tls } */

__thread double thrtest[81];
int main ()
{
  double *p, *e;
  e = &thrtest[81];
  for (p = &thrtest[0]; p < e; ++p)
    *p = 1.0;
  return 0;
}
"
"/* { dg-do run } */
/* { dg-require-effective-target avx } */
/* { dg-options ""-O2 -mavx"" } */

#define CHECK_H ""avx-check.h""
#define TEST avx_test

#include ""sse4_1-pextrd.c""
","/* { dg-do run } */
/* { dg-require-effective-target avx } */
/* { dg-options ""-O2 -mavx"" } */

#define CHECK_H ""avx-check.h""
#define TEST avx_test

#include ""sse4_1-pextrd.c""
"
"/* { dg-do compile } */ 
/* { dg-options ""-O2 -fdump-tree-pre-stats -fno-tree-loop-im"" } */
unsigned foo1 (unsigned a, unsigned b, unsigned j, unsigned k)
{
  unsigned i;
  for (i = 0; i != a; i++)
    {
      j += 4*b;
      k += 4*a;
    }
  return j + k;
}
/* We should eliminate both 4*b and 4*a from the main body of the loop */
/* { dg-final { scan-tree-dump-times ""Eliminated: 2"" 1 ""pre""} } */
","/* { dg-do compile } */ 
/* { dg-options ""-O2 -fdump-tree-pre-stats -fno-tree-loop-im"" } */
unsigned foo1 (unsigned a, unsigned b, unsigned j, unsigned k)
{
  unsigned i;
  for (i = 0; i != a; i++)
    {
      j += 4*b;
      k += 4*a;
    }
  return j + k;
}
/* We should eliminate both 4*b and 4*a from the main body of the loop */
/* { dg-final { scan-tree-dump-times ""Eliminated: 2"" 1 ""pre""} } */
"
"/* PR tree-optimization/58472 */
/* { dg-do compile } */
/* { dg-options ""-O2 -Wall -fopenmp"" } */

float a[1024], b[1024];

float
foo ()
{
  float s = 0.f;
  unsigned int i;
#pragma omp simd reduction(+:s)
  for (i = 0; i < 1024; ++i)
    s += a[i] * b[i];
  return s;
}
","/* PR tree-optimization/58472 */
/* { dg-do compile } */
/* { dg-options ""-O2 -Wall -fopenmp"" } */

float a[1024], b[1024];

float
foo ()
{
  float s = 0.f;
  unsigned int i;
#pragma omp simd reduction(+:s)
  for (i = 0; i < 1024; ++i)
    s += a[i] * b[i];
  return s;
}
"
"/* Extracted from boehm-gc/os_dep.c on Darwin.  It caused an ICE when
   trying to merge alias information from two pointers that had
   different type memory tags.  */
typedef int thread_state_flavor_t;
typedef int exception_behavior_t;
typedef unsigned int exception_mask_t;
typedef unsigned int exception_handler_t;
typedef unsigned int mach_msg_type_number_t;
static struct {
   mach_msg_type_number_t count;
   exception_mask_t masks[16];
   exception_handler_t ports[16];
   thread_state_flavor_t flavors[16];
} GC_old_exc_ports;

typedef exception_handler_t *exception_handler_array_t;
typedef thread_state_flavor_t *exception_flavor_array_t;


int task_get_exception_ports
(
  mach_msg_type_number_t *masksCnt,
  exception_handler_array_t old_handlers,
  exception_flavor_array_t old_flavors
);

void GC_dirty_init()
{
   task_get_exception_ports(GC_old_exc_ports.masks,
                           GC_old_exc_ports.ports,
                           GC_old_exc_ports.flavors);
}
","/* Extracted from boehm-gc/os_dep.c on Darwin.  It caused an ICE when
   trying to merge alias information from two pointers that had
   different type memory tags.  */
typedef int thread_state_flavor_t;
typedef int exception_behavior_t;
typedef unsigned int exception_mask_t;
typedef unsigned int exception_handler_t;
typedef unsigned int mach_msg_type_number_t;
static struct {
   mach_msg_type_number_t count;
   exception_mask_t masks[16];
   exception_handler_t ports[16];
   thread_state_flavor_t flavors[16];
} GC_old_exc_ports;

typedef exception_handler_t *exception_handler_array_t;
typedef thread_state_flavor_t *exception_flavor_array_t;


int task_get_exception_ports
(
  mach_msg_type_number_t *masksCnt,
  exception_handler_array_t old_handlers,
  exception_flavor_array_t old_flavors
);

void GC_dirty_init()
{
   task_get_exception_ports(GC_old_exc_ports.masks,
                           GC_old_exc_ports.ports,
                           GC_old_exc_ports.flavors);
}
"
"/* { dg-do preprocess } */

/* Tests for line numbering around function-like macro calls.
   Bug found by Mark Mitchell.  */

#define f(x) x
#define g f

f (3);
#error here	/* { dg-error ""here"" ""case 0"" } */

f
  (3);
#error here	/* { dg-error ""here"" ""case 1"" } */

(f
  )(3);
#error here	/* { dg-error ""here"" ""case 2"" } */

g
  (3);
#error here	/* { dg-error ""here"" ""case 3"" } */

(g
  )(3);
#error here	/* { dg-error ""here"" ""case 4"" } */

f /* some
     text */  (3);
#error here	/* { dg-error ""here"" ""case 5"" } */

(g /* some
      text */ )(3);
#error here	/* { dg-error ""here"" ""case 6"" } */
","/* { dg-do preprocess } */

/* Tests for line numbering around function-like macro calls.
   Bug found by Mark Mitchell.  */

#define f(x) x
#define g f

f (3);
#error here	/* { dg-error ""here"" ""case 0"" } */

f
  (3);
#error here	/* { dg-error ""here"" ""case 1"" } */

(f
  )(3);
#error here	/* { dg-error ""here"" ""case 2"" } */

g
  (3);
#error here	/* { dg-error ""here"" ""case 3"" } */

(g
  )(3);
#error here	/* { dg-error ""here"" ""case 4"" } */

f /* some
     text */  (3);
#error here	/* { dg-error ""here"" ""case 5"" } */

(g /* some
      text */ )(3);
#error here	/* { dg-error ""here"" ""case 6"" } */
"
"/* { dg-do compile { target { powerpc*-*-* } } } */
/* { dg-skip-if """" { powerpc*-*-darwin* } } */
/* { dg-skip-if ""do not override -mcpu"" { powerpc*-*-* } { ""-mcpu=*"" } { ""-mcpu=power6"" } } */
/* { dg-options ""-O2 -mcpu=power6 -msched-groups"" } */
/* { dg-final { scan-assembler ""ori 1,1,0"" } } */

/* Test generation of group ending nop in load hit store situation.  */
typedef union {
  double val;
  struct {
    unsigned int w1;
    unsigned int w2;
  };
} words;

unsigned int f (double d)
{
  words u;
  u.val = d;
  return u.w2;
}

","/* { dg-do compile { target { powerpc*-*-* } } } */
/* { dg-skip-if """" { powerpc*-*-darwin* } } */
/* { dg-skip-if ""do not override -mcpu"" { powerpc*-*-* } { ""-mcpu=*"" } { ""-mcpu=power6"" } } */
/* { dg-options ""-O2 -mcpu=power6 -msched-groups"" } */
/* { dg-final { scan-assembler ""ori 1,1,0"" } } */

/* Test generation of group ending nop in load hit store situation.  */
typedef union {
  double val;
  struct {
    unsigned int w1;
    unsigned int w2;
  };
} words;

unsigned int f (double d)
{
  words u;
  u.val = d;
  return u.w2;
}

"
"#include <stdarg.h>

#include ""compat-common.h""

#ifdef SKIP_VA
const int test_va = 0;
#else
const int test_va = 1;
#endif

#include ""fp-struct-defs.h""
#include ""fp-struct-init.h""
#include ""fp-struct-test-by-value-y.h""

#ifndef SKIP_COMPLEX
DEFS(cld,_Complex long double)
INITS(cld, _Complex long double)

TEST(Scld1, _Complex long double)
TEST(Scld2, _Complex long double)
TEST(Scld3, _Complex long double)
TEST(Scld4, _Complex long double)
TEST(Scld5, _Complex long double)
TEST(Scld6, _Complex long double)
TEST(Scld7, _Complex long double)
TEST(Scld8, _Complex long double)
TEST(Scld9, _Complex long double)
TEST(Scld10, _Complex long double)
TEST(Scld11, _Complex long double)
TEST(Scld12, _Complex long double)
#endif
","#include <stdarg.h>

#include ""compat-common.h""

#ifdef SKIP_VA
const int test_va = 0;
#else
const int test_va = 1;
#endif

#include ""fp-struct-defs.h""
#include ""fp-struct-init.h""
#include ""fp-struct-test-by-value-y.h""

#ifndef SKIP_COMPLEX
DEFS(cld,_Complex long double)
INITS(cld, _Complex long double)

TEST(Scld1, _Complex long double)
TEST(Scld2, _Complex long double)
TEST(Scld3, _Complex long double)
TEST(Scld4, _Complex long double)
TEST(Scld5, _Complex long double)
TEST(Scld6, _Complex long double)
TEST(Scld7, _Complex long double)
TEST(Scld8, _Complex long double)
TEST(Scld9, _Complex long double)
TEST(Scld10, _Complex long double)
TEST(Scld11, _Complex long double)
TEST(Scld12, _Complex long double)
#endif
"
"/* { dg-do compile } */
/* { dg-options ""-fopenmp -fdump-tree-ompexp"" } */

extern void bar(int);

void foo (int n)
{
  int i;

  #pragma omp for schedule(dynamic) ordered
  for (i = 0; i < n; ++i)
    bar(i);
}

/* { dg-final { scan-tree-dump-times ""GOMP_loop_ordered_dynamic_start"" 1 ""ompexp"" } } */
/* { dg-final { scan-tree-dump-times ""GOMP_loop_ordered_dynamic_next"" 1 ""ompexp"" } } */
","/* { dg-do compile } */
/* { dg-options ""-fopenmp -fdump-tree-ompexp"" } */

extern void bar(int);

void foo (int n)
{
  int i;

  #pragma omp for schedule(dynamic) ordered
  for (i = 0; i < n; ++i)
    bar(i);
}

/* { dg-final { scan-tree-dump-times ""GOMP_loop_ordered_dynamic_start"" 1 ""ompexp"" } } */
/* { dg-final { scan-tree-dump-times ""GOMP_loop_ordered_dynamic_next"" 1 ""ompexp"" } } */
"
"/* { dg-options ""-O2 -fgraphite-identity"" } */

void copy_data()
{
  int ****source;
  int ****dest;

  int i, j, k, l;
  for (i = 0; i < 10; i++)
      for (k = 0; k < 2; k++)
        for (l = 0; l < 65; l++)
          source[i][j][k][l] = dest[i][j][k][l];
}

","/* { dg-options ""-O2 -fgraphite-identity"" } */

void copy_data()
{
  int ****source;
  int ****dest;

  int i, j, k, l;
  for (i = 0; i < 10; i++)
      for (k = 0; k < 2; k++)
        for (l = 0; l < 65; l++)
          source[i][j][k][l] = dest[i][j][k][l];
}

"
"/* PR target/63594 */
/* { dg-do compile } */
/* { dg-options ""-O2 -mavx2 -mno-mmx -Wno-psabi"" } */

#include ""../../gcc.dg/pr63594-1.c""
","/* PR target/63594 */
/* { dg-do compile } */
/* { dg-options ""-O2 -mavx2 -mno-mmx -Wno-psabi"" } */

#include ""../../gcc.dg/pr63594-1.c""
"
"#include <arm_neon.h>

/* { dg-do compile } */
/* { dg-skip-if """" { *-*-* } { ""-fno-fat-lto-objects"" } } */

void
f_vst3q_lane_u16 (uint16_t * p, uint16x8x3_t v)
{
  /* { dg-error ""lane 8 out of range 0 - 7"" """" { target *-*-* } 0 } */
  vst3q_lane_u16 (p, v, 8);
  /* { dg-error ""lane -1 out of range 0 - 7"" """" { target *-*-* } 0 } */
  vst3q_lane_u16 (p, v, -1);
  return;
}
","#include <arm_neon.h>

/* { dg-do compile } */
/* { dg-skip-if """" { *-*-* } { ""-fno-fat-lto-objects"" } } */

void
f_vst3q_lane_u16 (uint16_t * p, uint16x8x3_t v)
{
  /* { dg-error ""lane 8 out of range 0 - 7"" """" { target *-*-* } 0 } */
  vst3q_lane_u16 (p, v, 8);
  /* { dg-error ""lane -1 out of range 0 - 7"" """" { target *-*-* } 0 } */
  vst3q_lane_u16 (p, v, -1);
  return;
}
"
"/* { dg-do compile } */
/* { dg-options ""-mavx2 -O2"" } */
/* { dg-final { scan-assembler ""vpsrlq\[ \\t\]+\[^\n\]*%ymm\[0-9\]"" } } */

#include <immintrin.h>

volatile __m256i x;
__m128i y;

void extern
avx2_test (void)
{
  x = _mm256_srl_epi64 (x, y);
}
","/* { dg-do compile } */
/* { dg-options ""-mavx2 -O2"" } */
/* { dg-final { scan-assembler ""vpsrlq\[ \\t\]+\[^\n\]*%ymm\[0-9\]"" } } */

#include <immintrin.h>

volatile __m256i x;
__m128i y;

void extern
avx2_test (void)
{
  x = _mm256_srl_epi64 (x, y);
}
"
"/* { dg-do compile } */

void foo()
{
  switch (,) { } /* { dg-error ""expected expression before"" } */
}

","/* { dg-do compile } */

void foo()
{
  switch (,) { } /* { dg-error ""expected expression before"" } */
}

"
"/* { dg-do compile } */
/* { dg-final { scan-assembler ""and.w "" } } */
/* { dg-final { scan-assembler ""and.b "" } } */
/* { dg-final { scan-assembler-not ""and.d"" } } */
/* { dg-options ""-O2"" } */

/* Test the ""asrandb"", ""asrandw"", ""lsrandb"" and ""lsrandw"" peephole2:s
   trivially.  */

unsigned int
andwlsr (unsigned int x)
{
  return (x >> 17) & 0x7ff;
}

unsigned int
andblsr (unsigned int x)
{
  return (x >> 25) & 0x5f;
}

int
andwasr (int x)
{
  return (x >> 17) & 0x7ff;
}

int
andbasr (int x)
{
  return (x >> 25) & 0x5f;
}
","/* { dg-do compile } */
/* { dg-final { scan-assembler ""and.w "" } } */
/* { dg-final { scan-assembler ""and.b "" } } */
/* { dg-final { scan-assembler-not ""and.d"" } } */
/* { dg-options ""-O2"" } */

/* Test the ""asrandb"", ""asrandw"", ""lsrandb"" and ""lsrandw"" peephole2:s
   trivially.  */

unsigned int
andwlsr (unsigned int x)
{
  return (x >> 17) & 0x7ff;
}

unsigned int
andblsr (unsigned int x)
{
  return (x >> 25) & 0x5f;
}

int
andwasr (int x)
{
  return (x >> 17) & 0x7ff;
}

int
andbasr (int x)
{
  return (x >> 25) & 0x5f;
}
"
"/* { dg-do compile } */
/* { dg-options ""-O2 -Wall"" } */

typedef int T __attribute__((may_alias));

extern T *p;
extern int *p;

extern int *p2;
extern T *p2;

void fn1 (T);
void fn1 (int);

void fn2 (int);
void fn2 (T);

/* Ensure that the composite types have may_alias.  */
void
f (long *i)
{
  *i = *(__typeof (*p) *) &p;
  asm ("""" : : ""r"" (*p));
  *i = *(__typeof (*p2) *) &p2;
  asm ("""" : : ""r"" (*p2));
}
","/* { dg-do compile } */
/* { dg-options ""-O2 -Wall"" } */

typedef int T __attribute__((may_alias));

extern T *p;
extern int *p;

extern int *p2;
extern T *p2;

void fn1 (T);
void fn1 (int);

void fn2 (int);
void fn2 (T);

/* Ensure that the composite types have may_alias.  */
void
f (long *i)
{
  *i = *(__typeof (*p) *) &p;
  asm ("""" : : ""r"" (*p));
  *i = *(__typeof (*p2) *) &p2;
  asm ("""" : : ""r"" (*p2));
}
"
"/* { dg-do compile } */
/* { dg-options ""-fsanitize=undefined"" } */

/* Test that we don't instrument functions marked with
   no_sanitize_undefined attribute.  */

__attribute__((no_sanitize_undefined, returns_nonnull))
char *
foo (char *x)
{
  return x;
}

__attribute__((nonnull)) void bar (char *, int, char *);

__attribute__((no_sanitize_undefined))
void
baz (char *x, int y, char *z)
{
  bar (x, y, z);
}

/* { dg-final { scan-assembler-not ""__ubsan_handle"" } } */
","/* { dg-do compile } */
/* { dg-options ""-fsanitize=undefined"" } */

/* Test that we don't instrument functions marked with
   no_sanitize_undefined attribute.  */

__attribute__((no_sanitize_undefined, returns_nonnull))
char *
foo (char *x)
{
  return x;
}

__attribute__((nonnull)) void bar (char *, int, char *);

__attribute__((no_sanitize_undefined))
void
baz (char *x, int y, char *z)
{
  bar (x, y, z);
}

/* { dg-final { scan-assembler-not ""__ubsan_handle"" } } */
"
"/* { dg-require-effective-target arm_thumb2_ok } */
/* { dg-require-effective-target arm_neon_ok } */
/* { dg-options ""-fno-inline -mthumb -O1 -mfpu=neon -w"" } */

extern void abort (void);

register long long x asm (""r1"");

long long f (void)
{
  return x << 5;
}

int main ()
{
  x = 0x0100000001;
  if (f () != 0x2000000020)
    abort ();
  return 0;
}
","/* { dg-require-effective-target arm_thumb2_ok } */
/* { dg-require-effective-target arm_neon_ok } */
/* { dg-options ""-fno-inline -mthumb -O1 -mfpu=neon -w"" } */

extern void abort (void);

register long long x asm (""r1"");

long long f (void)
{
  return x << 5;
}

int main ()
{
  x = 0x0100000001;
  if (f () != 0x2000000020)
    abort ();
  return 0;
}
"
"/* PR middle-end/16790.  */

extern void abort ();

static void test1(unsigned int u1)
{
  unsigned int y_final_1;
  signed short y_middle;
  unsigned int y_final_2;

  y_final_1 = (unsigned int)( (signed short)(u1 * 2) * 3 );
  y_middle  =                 (signed short)(u1 * 2);
  y_final_2 = (unsigned int)( y_middle * 3 );

  if (y_final_1 != y_final_2)
    abort ();
}


static void test2(unsigned int u1)
{
  unsigned int y_final_1;
  signed short y_middle;
  unsigned int y_final_2;

  y_final_1 = (unsigned int)( (signed short)(u1 << 1) * 3 );
  y_middle  =                 (signed short)(u1 << 1);
  y_final_2 = (unsigned int)( y_middle * 3 );

  if (y_final_1 != y_final_2)
    abort ();
}


int main()
{
  test1(0x4000U);
  test2(0x4000U);
  return 0;
}

","/* PR middle-end/16790.  */

extern void abort ();

static void test1(unsigned int u1)
{
  unsigned int y_final_1;
  signed short y_middle;
  unsigned int y_final_2;

  y_final_1 = (unsigned int)( (signed short)(u1 * 2) * 3 );
  y_middle  =                 (signed short)(u1 * 2);
  y_final_2 = (unsigned int)( y_middle * 3 );

  if (y_final_1 != y_final_2)
    abort ();
}


static void test2(unsigned int u1)
{
  unsigned int y_final_1;
  signed short y_middle;
  unsigned int y_final_2;

  y_final_1 = (unsigned int)( (signed short)(u1 << 1) * 3 );
  y_middle  =                 (signed short)(u1 << 1);
  y_final_2 = (unsigned int)( y_middle * 3 );

  if (y_final_1 != y_final_2)
    abort ();
}


int main()
{
  test1(0x4000U);
  test2(0x4000U);
  return 0;
}

"
"/* { dg-do compile } */
/* { dg-options ""-O3 -fdump-tree-local-pure-const1 -fdump-tree-optimized"" } */
static __attribute__ ((noinline, noclone))
int i_am_pure(char *c, int n)
{
  char *d=__builtin_alloca (n);
  int i;
  int sum = 0;
  for (i=0;i<n;i++)
    d[i] = c[i];
  for (i=0;i<n;i++)
    d[i] *= c[n-i];
  for (i=0;i<n;i++)
    sum+=d[i];
  if (sum)
    __builtin_unreachable ();
  return sum;
}
char array[11];
int
main(void)
{
  i_am_pure (array,5);
  i_am_pure (array,11);
  return 0;
}
/* { dg-final { scan-tree-dump ""found to be pure: i_am_pure"" ""local-pure-const1""} } */
/* { dg-final { scan-tree-dump-not ""i_am_pure"" ""optimized""} } */
","/* { dg-do compile } */
/* { dg-options ""-O3 -fdump-tree-local-pure-const1 -fdump-tree-optimized"" } */
static __attribute__ ((noinline, noclone))
int i_am_pure(char *c, int n)
{
  char *d=__builtin_alloca (n);
  int i;
  int sum = 0;
  for (i=0;i<n;i++)
    d[i] = c[i];
  for (i=0;i<n;i++)
    d[i] *= c[n-i];
  for (i=0;i<n;i++)
    sum+=d[i];
  if (sum)
    __builtin_unreachable ();
  return sum;
}
char array[11];
int
main(void)
{
  i_am_pure (array,5);
  i_am_pure (array,11);
  return 0;
}
/* { dg-final { scan-tree-dump ""found to be pure: i_am_pure"" ""local-pure-const1""} } */
/* { dg-final { scan-tree-dump-not ""i_am_pure"" ""optimized""} } */
"
"/* Inlined inline function must have abstract DIE  */
/* { dg-do compile } */
/* { dg-options ""-O2 -gdwarf -dA -fpreprocessed"" } */
/* { dg-final { scan-assembler ""3.*DW_AT_inline"" } } */
#1 ""test.h""
inline int t()
{
}
int q()
{
  t();
}
","/* Inlined inline function must have abstract DIE  */
/* { dg-do compile } */
/* { dg-options ""-O2 -gdwarf -dA -fpreprocessed"" } */
/* { dg-final { scan-assembler ""3.*DW_AT_inline"" } } */
#1 ""test.h""
inline int t()
{
}
int q()
{
  t();
}
"
"/* { dg-do assemble } */
/* { dg-options ""-march=armv8-a+crypto -mcpu=generic -save-temps"" } */

/* Check that ""+nothing"" clears the ISA flags.  */

__attribute__ ((target (""+nothing"")))
int
foo (int a)
{
  return a + 1;
}

/* { dg-final { scan-assembler-times ""\\.arch armv8-a\\+nofp\\+nosimd\n"" 1 } } */
","/* { dg-do assemble } */
/* { dg-options ""-march=armv8-a+crypto -mcpu=generic -save-temps"" } */

/* Check that ""+nothing"" clears the ISA flags.  */

__attribute__ ((target (""+nothing"")))
int
foo (int a)
{
  return a + 1;
}

/* { dg-final { scan-assembler-times ""\\.arch armv8-a\\+nofp\\+nosimd\n"" 1 } } */
"
"/* { dg-do compile } */
/* { dg-options ""-Os"" } */

float dhistory[10];
float test;

float getSlope(float history[]) {
  float sumx = 0;
  float sumy = 0;
  float sumxy = 0;
  float sumxsq = 0;
  float rate = 0;
  int n = 10;

  int i;
  for (i=1; i< 11; i++) {
    sumx = sumx + i;
    sumy = sumy + history[i-1];
    sumy = sumy + history[i-1];
    sumxsq = sumxsq + (i*i);
  }

  rate = sumy+sumx+sumxsq;
  return rate;
}

void loop() {
  test = getSlope(dhistory);
}
","/* { dg-do compile } */
/* { dg-options ""-Os"" } */

float dhistory[10];
float test;

float getSlope(float history[]) {
  float sumx = 0;
  float sumy = 0;
  float sumxy = 0;
  float sumxsq = 0;
  float rate = 0;
  int n = 10;

  int i;
  for (i=1; i< 11; i++) {
    sumx = sumx + i;
    sumy = sumy + history[i-1];
    sumy = sumy + history[i-1];
    sumxsq = sumxsq + (i*i);
  }

  rate = sumy+sumx+sumxsq;
  return rate;
}

void loop() {
  test = getSlope(dhistory);
}
"
"/* { dg-do compile } */
/* { dg-options ""-fsanitize-recover=return"" } */

int i;

/* { dg-error "".-fsanitize-recover=return. is not supported"" """" { target *-*-* } 0 } */
","/* { dg-do compile } */
/* { dg-options ""-fsanitize-recover=return"" } */

int i;

/* { dg-error "".-fsanitize-recover=return. is not supported"" """" { target *-*-* } 0 } */
"
"/* { dg-do compile } */
/* { dg-options ""-O2 -mavx512f"" } */
/* { dg-final { scan-assembler-times ""vpcmpd\[ \\t\]+\[^\{\n\]*%zmm\[0-9\]+\[^\n^k\]*%k\[1-7\](?:\n|\[ \\t\]+#)"" 1 } } */
/* { dg-final { scan-assembler-times ""vpcmpd\[ \\t\]+\[^\{\n\]*%zmm\[0-9\]+\[^\n^k\]*%k\[1-7\]\{%k\[0-7\]\}(?:\n|\[ \\t\]+#)"" 1 } } */

#include <immintrin.h>

volatile __m512i x;
volatile __mmask16 m;

void extern
avx512f_test (void)
{
  m = _mm512_cmp_epi32_mask (x, x, _MM_CMPINT_GE);
  m = _mm512_mask_cmp_epi32_mask (m, x, x, _MM_CMPINT_NLE);
}
","/* { dg-do compile } */
/* { dg-options ""-O2 -mavx512f"" } */
/* { dg-final { scan-assembler-times ""vpcmpd\[ \\t\]+\[^\{\n\]*%zmm\[0-9\]+\[^\n^k\]*%k\[1-7\](?:\n|\[ \\t\]+#)"" 1 } } */
/* { dg-final { scan-assembler-times ""vpcmpd\[ \\t\]+\[^\{\n\]*%zmm\[0-9\]+\[^\n^k\]*%k\[1-7\]\{%k\[0-7\]\}(?:\n|\[ \\t\]+#)"" 1 } } */

#include <immintrin.h>

volatile __m512i x;
volatile __mmask16 m;

void extern
avx512f_test (void)
{
  m = _mm512_cmp_epi32_mask (x, x, _MM_CMPINT_GE);
  m = _mm512_mask_cmp_epi32_mask (m, x, x, _MM_CMPINT_NLE);
}
"
"/* { dg-do compile } */
/* { dg-additional-options ""-fno-tree-ccp -fno-tree-forwprop"" } */

void
iw (int gu, int mq, int r2)
{
  int yn = 0;

  while (gu < 1)
    {
      for (;;)
        ;

 bb:;
      int ay = 0;

      while (ay < 1)
        ++mq;
    }

  if (yn != 0)
    goto up;

  if (0)
    {
 up:
      if (r2 == 0)
        goto bb;
    }

  goto up;
}
","/* { dg-do compile } */
/* { dg-additional-options ""-fno-tree-ccp -fno-tree-forwprop"" } */

void
iw (int gu, int mq, int r2)
{
  int yn = 0;

  while (gu < 1)
    {
      for (;;)
        ;

 bb:;
      int ay = 0;

      while (ay < 1)
        ++mq;
    }

  if (yn != 0)
    goto up;

  if (0)
    {
 up:
      if (r2 == 0)
        goto bb;
    }

  goto up;
}
"
"#define DEFINED_VALUE_2 3

#include ""macro-2.h""

int main(void) 
{
  return DEFINED_VALUE - DEFINED_VALUE_2;
}
","#define DEFINED_VALUE_2 3

#include ""macro-2.h""

int main(void) 
{
  return DEFINED_VALUE - DEFINED_VALUE_2;
}
"
"/* { dg-do run } */
/* { dg-options ""-mavx2 -O2"" } */
/* { dg-require-effective-target avx2 } */

#include ""avx2-check.h""

static void
compute_pminuw256 (unsigned short *s1, unsigned short *s2, unsigned short *r)
{
  int i;

  for (i = 0; i < 16; i++)
    r[i] = s1[i] < s2[i] ? s1[i] : s2[i];
}

static void
avx2_test (void)
{
  union256i_w s1, s2, res;
  unsigned short res_ref[16];
  int i, j;
  int fail = 0;

  for (i = 0; i < 10; i++)
    {
      for (j = 0; j < 16; j++)
	{
	  s1.a[j] = j * i;
	  s2.a[j] = i + 2000;
	}

      res.x = _mm256_min_epu16 (s1.x, s2.x);

      compute_pminuw256 ((unsigned short *) s1.a,
			 (unsigned short *) s2.a, (unsigned short *) res_ref);

      fail += check_union256i_w (res, res_ref);
    }

  if (fail != 0)
    abort ();
}
","/* { dg-do run } */
/* { dg-options ""-mavx2 -O2"" } */
/* { dg-require-effective-target avx2 } */

#include ""avx2-check.h""

static void
compute_pminuw256 (unsigned short *s1, unsigned short *s2, unsigned short *r)
{
  int i;

  for (i = 0; i < 16; i++)
    r[i] = s1[i] < s2[i] ? s1[i] : s2[i];
}

static void
avx2_test (void)
{
  union256i_w s1, s2, res;
  unsigned short res_ref[16];
  int i, j;
  int fail = 0;

  for (i = 0; i < 10; i++)
    {
      for (j = 0; j < 16; j++)
	{
	  s1.a[j] = j * i;
	  s2.a[j] = i + 2000;
	}

      res.x = _mm256_min_epu16 (s1.x, s2.x);

      compute_pminuw256 ((unsigned short *) s1.a,
			 (unsigned short *) s2.a, (unsigned short *) res_ref);

      fail += check_union256i_w (res, res_ref);
    }

  if (fail != 0)
    abort ();
}
"
"int pid_count = 0;

unsigned int getopt (int, const char**, const char*);
unsigned long long atoll (const char*);
int fork (void);
void kill (int, int);

int
main (int argc, const char *argv[])
{
  unsigned int c;
  unsigned long long maxbytes = 0;
  extern const char *optarg;
  int i;
  int pid_cntr;
  int pid;
  int pid_list[1000];
  while ((c = getopt (argc, argv, ""c:b:p:wvh"")) != (-1))
    {
      switch ((char) c)
	{
	case 'b':
	  maxbytes = atoll (optarg);
	}
    }
  pid = fork ();
  while ((pid != 0) && (maxbytes > 1024 * 1024 * 1024))
    {
      maxbytes = maxbytes - (1024 * 1024 * 1024);
      pid = fork ();
      if (pid != 0)
	pid_cntr++;
      pid_list[i] = pid;
    }
  while ((pid_count < pid_cntr))
    {
    }
  kill (pid_list[i], 9);
}
","int pid_count = 0;

unsigned int getopt (int, const char**, const char*);
unsigned long long atoll (const char*);
int fork (void);
void kill (int, int);

int
main (int argc, const char *argv[])
{
  unsigned int c;
  unsigned long long maxbytes = 0;
  extern const char *optarg;
  int i;
  int pid_cntr;
  int pid;
  int pid_list[1000];
  while ((c = getopt (argc, argv, ""c:b:p:wvh"")) != (-1))
    {
      switch ((char) c)
	{
	case 'b':
	  maxbytes = atoll (optarg);
	}
    }
  pid = fork ();
  while ((pid != 0) && (maxbytes > 1024 * 1024 * 1024))
    {
      maxbytes = maxbytes - (1024 * 1024 * 1024);
      pid = fork ();
      if (pid != 0)
	pid_cntr++;
      pid_list[i] = pid;
    }
  while ((pid_count < pid_cntr))
    {
    }
  kill (pid_list[i], 9);
}
"
"/* { dg-do run } */
/* { dg-require-effective-target avx } */
/* { dg-options ""-O2 -mavx"" } */

#define CHECK_H ""avx-check.h""
#define TEST avx_test

#include ""sse-xorps-1.c""
","/* { dg-do run } */
/* { dg-require-effective-target avx } */
/* { dg-options ""-O2 -mavx"" } */

#define CHECK_H ""avx-check.h""
#define TEST avx_test

#include ""sse-xorps-1.c""
"
"/* { dg-do compile } */
/* { dg-options ""-O2 -mlong-double-128"" } */

long double
foo (long double x)
{
  return x * x;
}

/* { dg-final { scan-assembler-not ""fldt"" } } */
/* { dg-final { scan-assembler ""call\[\\t \]*_?__multf3"" } } */
","/* { dg-do compile } */
/* { dg-options ""-O2 -mlong-double-128"" } */

long double
foo (long double x)
{
  return x * x;
}

/* { dg-final { scan-assembler-not ""fldt"" } } */
/* { dg-final { scan-assembler ""call\[\\t \]*_?__multf3"" } } */
"
"/* PR tree-optimization/34648 */

/* { dg-options ""-fexceptions"" } */

extern const unsigned short int **bar (void) __attribute__ ((const));
const char *a;
int b;
char c;

char
foo (int *x)
{
  char r;

  c = '\0';
  if (!b)
    {
      while (((*bar ())[a[*x]] & 0x2000) != 0)
        (*x)++;
      if (a[++(*x)] == '-')
        {
          (*x)++;
          if (a[*x] && !((*bar ())[a[*x]] & 0x2000))
            return '?';
        }
      if (!a[*x] || ((*bar ())[a[*x]] & 0x2000))
        {
          while (((*bar ())[a[*x]] & 0x2000))
            ++(*x);
          return '\0';
        }
    }

  r = a[*x];
  b = a[*x] && !((*bar ())[a[*x]] & 0x2000);
  return r;
}

","/* PR tree-optimization/34648 */

/* { dg-options ""-fexceptions"" } */

extern const unsigned short int **bar (void) __attribute__ ((const));
const char *a;
int b;
char c;

char
foo (int *x)
{
  char r;

  c = '\0';
  if (!b)
    {
      while (((*bar ())[a[*x]] & 0x2000) != 0)
        (*x)++;
      if (a[++(*x)] == '-')
        {
          (*x)++;
          if (a[*x] && !((*bar ())[a[*x]] & 0x2000))
            return '?';
        }
      if (!a[*x] || ((*bar ())[a[*x]] & 0x2000))
        {
          while (((*bar ())[a[*x]] & 0x2000))
            ++(*x);
          return '\0';
        }
    }

  r = a[*x];
  b = a[*x] && !((*bar ())[a[*x]] & 0x2000);
  return r;
}

"
"/* PR middle-end/31490 */
/* { dg-do compile } */
/* { dg-require-named-sections """" } */
/* { dg-require-effective-target ptr32plus } */

__extension__ typedef __UINTPTR_TYPE__ uintptr_t;

int cpu (void *attr) {}
const uintptr_t x __attribute__((section(""foo""))) =  (uintptr_t)&cpu;
const uintptr_t g __attribute__((section(""foo""))) = 0;
","/* PR middle-end/31490 */
/* { dg-do compile } */
/* { dg-require-named-sections """" } */
/* { dg-require-effective-target ptr32plus } */

__extension__ typedef __UINTPTR_TYPE__ uintptr_t;

int cpu (void *attr) {}
const uintptr_t x __attribute__((section(""foo""))) =  (uintptr_t)&cpu;
const uintptr_t g __attribute__((section(""foo""))) = 0;
"
"/* { dg-do compile } */

unsigned b;
void f()
{
  for(;;)
    if(!b?:(b=0))
      ;
    else if(b%0<b?:b) /* { dg-warning ""division by zero"" } */
      for(;;)
	;
}
","/* { dg-do compile } */

unsigned b;
void f()
{
  for(;;)
    if(!b?:(b=0))
      ;
    else if(b%0<b?:b) /* { dg-warning ""division by zero"" } */
      for(;;)
	;
}
"
"/* { dg-do compile } */
/* { dg-options ""-mavx512f -O2 -mtune=knl"" } */
/* { dg-final { scan-assembler-times ""vpgatherdd\[ \\t\]+\[^\{\n\]*zmm\[0-9\]\[^\n\]*zmm\[0-9\]{%k\[1-7\]}(?:\n|\[ \\t\]+#)"" 2 } } */

#include <immintrin.h>

volatile __m512i x, idx;
volatile __mmask16 m16;
int *base;

void extern
avx512f_test (void)
{
  x = _mm512_i32gather_epi32 (idx, base, 8);
  x = _mm512_mask_i32gather_epi32 (x, m16, idx, base, 8);
}
","/* { dg-do compile } */
/* { dg-options ""-mavx512f -O2 -mtune=knl"" } */
/* { dg-final { scan-assembler-times ""vpgatherdd\[ \\t\]+\[^\{\n\]*zmm\[0-9\]\[^\n\]*zmm\[0-9\]{%k\[1-7\]}(?:\n|\[ \\t\]+#)"" 2 } } */

#include <immintrin.h>

volatile __m512i x, idx;
volatile __mmask16 m16;
int *base;

void extern
avx512f_test (void)
{
  x = _mm512_i32gather_epi32 (idx, base, 8);
  x = _mm512_mask_i32gather_epi32 (x, m16, idx, base, 8);
}
"
"typedef struct {
        short   a;
        short   b;
} s1;

extern void g(unsigned char *b);

void f(void)
{
        s1        a;
	unsigned char *b;

        a.a = 0;
	b = (unsigned char *)&a;	
        g(b);           
}
","typedef struct {
        short   a;
        short   b;
} s1;

extern void g(unsigned char *b);

void f(void)
{
        s1        a;
	unsigned char *b;

        a.a = 0;
	b = (unsigned char *)&a;	
        g(b);           
}
"
"/* PR middle-end/50865 */

#define INT64_MIN (-__LONG_LONG_MAX__ - 1)

int
main ()
{
  volatile long long l1 = 1;
  volatile long long l2 = -1;
  volatile long long l3 = -1;

  if ((INT64_MIN % 1LL) != 0)
    __builtin_abort ();
  if ((INT64_MIN % l1) != 0)
    __builtin_abort ();
  if (l2 == -1)
    {
      if ((INT64_MIN % 1LL) != 0)
	__builtin_abort ();
    }
  else if ((INT64_MIN % -l2) != 0)
    __builtin_abort ();
  if ((INT64_MIN % -l3) != 0)
    __builtin_abort ();

  return 0;
}
","/* PR middle-end/50865 */

#define INT64_MIN (-__LONG_LONG_MAX__ - 1)

int
main ()
{
  volatile long long l1 = 1;
  volatile long long l2 = -1;
  volatile long long l3 = -1;

  if ((INT64_MIN % 1LL) != 0)
    __builtin_abort ();
  if ((INT64_MIN % l1) != 0)
    __builtin_abort ();
  if (l2 == -1)
    {
      if ((INT64_MIN % 1LL) != 0)
	__builtin_abort ();
    }
  else if ((INT64_MIN % -l2) != 0)
    __builtin_abort ();
  if ((INT64_MIN % -l3) != 0)
    __builtin_abort ();

  return 0;
}
"
"/* Verify that overloaded built-ins for vec_mul with int
   inputs produce the right results.  */

/* { dg-do compile } */
/* { dg-require-effective-target powerpc_p8vector_ok } */
/* { dg-options ""-mpower8-vector"" } */

#include <altivec.h>

vector signed int
test3 (vector signed int x, vector signed int y)
{
  return vec_mul (x, y);
}

vector unsigned int
test6 (vector unsigned int x, vector unsigned int y)
{
  return vec_mul (x, y);
}

/* { dg-final { scan-assembler-times ""\[ \t\]vmuluwm"" 2 } } */

","/* Verify that overloaded built-ins for vec_mul with int
   inputs produce the right results.  */

/* { dg-do compile } */
/* { dg-require-effective-target powerpc_p8vector_ok } */
/* { dg-options ""-mpower8-vector"" } */

#include <altivec.h>

vector signed int
test3 (vector signed int x, vector signed int y)
{
  return vec_mul (x, y);
}

vector unsigned int
test6 (vector unsigned int x, vector unsigned int y)
{
  return vec_mul (x, y);
}

/* { dg-final { scan-assembler-times ""\[ \t\]vmuluwm"" 2 } } */

"
"/* { dg-do run } */
/* { dg-options ""-fsanitize=undefined -fno-sanitize-recover=undefined"" } */

int
foo (int x, int y)
{
  const int z = 2;
  if (z & 1)
    return x << y;
  return 0;
}

int
bar (int x, int y)
{
  return x + y;
}

int
main (void)
{
  foo (3, 2);
  bar (12, 42);
  return 0;
}
","/* { dg-do run } */
/* { dg-options ""-fsanitize=undefined -fno-sanitize-recover=undefined"" } */

int
foo (int x, int y)
{
  const int z = 2;
  if (z & 1)
    return x << y;
  return 0;
}

int
bar (int x, int y)
{
  return x + y;
}

int
main (void)
{
  foo (3, 2);
  bar (12, 42);
  return 0;
}
"
"/* { dg-do compile } */
/* { dg-options ""-O -fgcse"" } */

extern void fe ();

extern int i;

static inline void
FX (void (*f) ())
{
  fe ();
  (*f) ();
}

static inline void
f4 ()
{
  for (;;)
    switch (i)
      {
      case 306:
      FX (&fe);
      break;
      default:
      return;
      }
}

static inline void
f3 ()
{
  f4 ();
  for (;;)
    switch (i)
      {
      case 267:
      FX (&f4);
      break;
      default:
      return;
      }
}

static inline void
f2 ()
{
  f3 ();
  while (i)
    FX (&f3);
}

void
f1 ()
{
  f2 ();
  while (1)
    FX (&f2);
}
","/* { dg-do compile } */
/* { dg-options ""-O -fgcse"" } */

extern void fe ();

extern int i;

static inline void
FX (void (*f) ())
{
  fe ();
  (*f) ();
}

static inline void
f4 ()
{
  for (;;)
    switch (i)
      {
      case 306:
      FX (&fe);
      break;
      default:
      return;
      }
}

static inline void
f3 ()
{
  f4 ();
  for (;;)
    switch (i)
      {
      case 267:
      FX (&f4);
      break;
      default:
      return;
      }
}

static inline void
f2 ()
{
  f3 ();
  while (i)
    FX (&f3);
}

void
f1 ()
{
  f2 ();
  while (1)
    FX (&f2);
}
"
"struct foo {
  unsigned : 12;
  unsigned field : 4;
} foo;
unsigned oldfoo;

int
bar (unsigned k)
{
  oldfoo = foo.field;
  foo.field = k;
  if (k)
    return 1;
  return 2;
}

main ()
{
  if (bar (1U) != 1)
    abort ();
  exit (0);
}
","struct foo {
  unsigned : 12;
  unsigned field : 4;
} foo;
unsigned oldfoo;

int
bar (unsigned k)
{
  oldfoo = foo.field;
  foo.field = k;
  if (k)
    return 1;
  return 2;
}

main ()
{
  if (bar (1U) != 1)
    abort ();
  exit (0);
}
"
"/* { dg-do compile } */
/* { dg-options ""-O3 -fno-ipa-sra -fdump-ipa-cp-details -fdump-tree-optimized-slim""  } */
/* { dg-add-options bind_pic_locally } */

struct S
{
  int a, b, c;
};

void *blah(int, void *);

static void __attribute__ ((noinline))
foo (struct S *p)
{
  int i, c = p->c;
  int b = p->b;
  void *v = (void *) p;

  for (i= 0; i< c; i++)
    v = blah(b + i, v);
}

void
entry (int c)
{
  struct S s;
  int i;

  for (i = 0; i<c; i++)
    {
      s.a = 1;
      s.b = 64;
      s.c = 32;
      foo (&s);
    }
  s.c = 2;
  foo (&s);
}
/* { dg-final { scan-ipa-dump-times ""Creating a specialized node of foo/\[0-9\]*\\."" 2 ""cp"" } } */
/* { dg-final { scan-ipa-dump-times ""Aggregate replacements:"" 4 ""cp"" } } */
/* { dg-final { scan-tree-dump-not ""->c;"" ""optimized"" } } */
","/* { dg-do compile } */
/* { dg-options ""-O3 -fno-ipa-sra -fdump-ipa-cp-details -fdump-tree-optimized-slim""  } */
/* { dg-add-options bind_pic_locally } */

struct S
{
  int a, b, c;
};

void *blah(int, void *);

static void __attribute__ ((noinline))
foo (struct S *p)
{
  int i, c = p->c;
  int b = p->b;
  void *v = (void *) p;

  for (i= 0; i< c; i++)
    v = blah(b + i, v);
}

void
entry (int c)
{
  struct S s;
  int i;

  for (i = 0; i<c; i++)
    {
      s.a = 1;
      s.b = 64;
      s.c = 32;
      foo (&s);
    }
  s.c = 2;
  foo (&s);
}
/* { dg-final { scan-ipa-dump-times ""Creating a specialized node of foo/\[0-9\]*\\."" 2 ""cp"" } } */
/* { dg-final { scan-ipa-dump-times ""Aggregate replacements:"" 4 ""cp"" } } */
/* { dg-final { scan-tree-dump-not ""->c;"" ""optimized"" } } */
"
"/* PR middle-end/85090 */
/* { dg-do compile } */
/* { dg-options ""-O2 -mavx512f -mno-avx512bw -mtune=intel -masm=att"" } */

typedef signed char V __attribute__((vector_size (64)));

V
f1 (V x, int y)
{
  x[0] = y;
  return x;
}

V
f2 (V x, int y)
{
  x[15] = y;
  return x;
}

V
f3 (V x, int y)
{
  x[22] = y;
  return x;
}

V
f4 (V x, int y)
{
  x[59] = y;
  return x;
}

/* { dg-final { scan-assembler-times ""vpinsrb\t"" 4 } } */
/* { dg-final { scan-assembler-times ""vextracti32x4\t"" 2 } } */
/* { dg-final { scan-assembler-times ""vinserti32x4\t"" 4 } } */
","/* PR middle-end/85090 */
/* { dg-do compile } */
/* { dg-options ""-O2 -mavx512f -mno-avx512bw -mtune=intel -masm=att"" } */

typedef signed char V __attribute__((vector_size (64)));

V
f1 (V x, int y)
{
  x[0] = y;
  return x;
}

V
f2 (V x, int y)
{
  x[15] = y;
  return x;
}

V
f3 (V x, int y)
{
  x[22] = y;
  return x;
}

V
f4 (V x, int y)
{
  x[59] = y;
  return x;
}

/* { dg-final { scan-assembler-times ""vpinsrb\t"" 4 } } */
/* { dg-final { scan-assembler-times ""vextracti32x4\t"" 2 } } */
/* { dg-final { scan-assembler-times ""vinserti32x4\t"" 4 } } */
"
"/* { dg-do compile } */
/* { dg-options ""-O -fdump-tree-gimple -fdump-tree-optimized"" } */

int f(int a){
  int b = -__INT_MAX__-1;
  a &= b;
  return a == b;
}
int g(int x){
    x = x < 0 ? -x : x;
    return x == 0;
}

/* This should work even if int is not 32 bits, it is just not meaningful in
   that case.  */
/* { dg-final { scan-tree-dump-not ""-2147483648"" ""optimized""} } */
/* { dg-final { scan-tree-dump "" < 0"" ""optimized""} } */
/* { dg-final { scan-tree-dump ""ABS_EXPR"" ""gimple""} } */
/* { dg-final { scan-tree-dump-not ""ABS_EXPR"" ""optimized""} } */
","/* { dg-do compile } */
/* { dg-options ""-O -fdump-tree-gimple -fdump-tree-optimized"" } */

int f(int a){
  int b = -__INT_MAX__-1;
  a &= b;
  return a == b;
}
int g(int x){
    x = x < 0 ? -x : x;
    return x == 0;
}

/* This should work even if int is not 32 bits, it is just not meaningful in
   that case.  */
/* { dg-final { scan-tree-dump-not ""-2147483648"" ""optimized""} } */
/* { dg-final { scan-tree-dump "" < 0"" ""optimized""} } */
/* { dg-final { scan-tree-dump ""ABS_EXPR"" ""gimple""} } */
/* { dg-final { scan-tree-dump-not ""ABS_EXPR"" ""optimized""} } */
"
"/* { dg-do compile } */
/* { dg-options ""-mavx512vl -O2"" } */
/* { dg-final { scan-assembler-times ""vunpckhpd\[ \\t\]+\[^\{\n\]*%ymm\[0-9\]+\{%k\[1-7\]\}\{z\}(?:\n|\[ \\t\]+#)"" 1 } } */
/* { dg-final { scan-assembler-times ""vunpckhpd\[ \\t\]+\[^\{\n\]*%xmm\[0-9\]+\{%k\[1-7\]\}\{z\}(?:\n|\[ \\t\]+#)"" 1 } } */
/* { dg-final { scan-assembler-times ""vunpckhpd\[ \\t\]+\[^\{\n\]*%ymm\[0-9\]+\{%k\[1-7\]\}(?:\n|\[ \\t\]+#)"" 1 } } */
/* { dg-final { scan-assembler-times ""vunpckhpd\[ \\t\]+\[^\{\n\]*%xmm\[0-9\]+\{%k\[1-7\]\}(?:\n|\[ \\t\]+#)"" 1 } } */

#include <immintrin.h>

volatile __m256d yy, y2, y3;
volatile __m128d xx, x2, x3;
volatile __mmask8 m;

void extern
avx512vl_test (void)
{
  yy = _mm256_mask_unpackhi_pd (yy, m, y2, y3);
  xx = _mm_mask_unpackhi_pd (xx, m, x2, x3);

  yy = _mm256_maskz_unpackhi_pd (m, y2, y3);
  xx = _mm_maskz_unpackhi_pd (m, x2, x3);
}
","/* { dg-do compile } */
/* { dg-options ""-mavx512vl -O2"" } */
/* { dg-final { scan-assembler-times ""vunpckhpd\[ \\t\]+\[^\{\n\]*%ymm\[0-9\]+\{%k\[1-7\]\}\{z\}(?:\n|\[ \\t\]+#)"" 1 } } */
/* { dg-final { scan-assembler-times ""vunpckhpd\[ \\t\]+\[^\{\n\]*%xmm\[0-9\]+\{%k\[1-7\]\}\{z\}(?:\n|\[ \\t\]+#)"" 1 } } */
/* { dg-final { scan-assembler-times ""vunpckhpd\[ \\t\]+\[^\{\n\]*%ymm\[0-9\]+\{%k\[1-7\]\}(?:\n|\[ \\t\]+#)"" 1 } } */
/* { dg-final { scan-assembler-times ""vunpckhpd\[ \\t\]+\[^\{\n\]*%xmm\[0-9\]+\{%k\[1-7\]\}(?:\n|\[ \\t\]+#)"" 1 } } */

#include <immintrin.h>

volatile __m256d yy, y2, y3;
volatile __m128d xx, x2, x3;
volatile __mmask8 m;

void extern
avx512vl_test (void)
{
  yy = _mm256_mask_unpackhi_pd (yy, m, y2, y3);
  xx = _mm_mask_unpackhi_pd (xx, m, x2, x3);

  yy = _mm256_maskz_unpackhi_pd (m, y2, y3);
  xx = _mm_maskz_unpackhi_pd (m, x2, x3);
}
"
"/* { dg-do compile } */
/* { dg-options ""-O2 -fdump-tree-vrp1"" } */

void bar (void);

void
foo (int a)
{
  switch (a)
    {
    case 4:
      if (a >= 3)
        if (a <= 5)
          bar ();
    }
}

/* Both ifs should be optimized (and switch statement will be the only if
   in the function).  */
/* { dg-final { scan-tree-dump-times ""if \\\("" 1 ""vrp1"" } } */
","/* { dg-do compile } */
/* { dg-options ""-O2 -fdump-tree-vrp1"" } */

void bar (void);

void
foo (int a)
{
  switch (a)
    {
    case 4:
      if (a >= 3)
        if (a <= 5)
          bar ();
    }
}

/* Both ifs should be optimized (and switch statement will be the only if
   in the function).  */
/* { dg-final { scan-tree-dump-times ""if \\\("" 1 ""vrp1"" } } */
"
"/* { dg-do compile } */ 
/* { dg-options ""-O2 -fdump-tree-sink-stats"" } */
int
foo (int a, int b, int c)
{
  int x = a * b;
  return c ? x : a;
}
/* We should sink the x = a * b calculation into the branch that returns x. */
/* { dg-final { scan-tree-dump-times ""Sunk statements: 1"" 1 ""sink"" } } */
","/* { dg-do compile } */ 
/* { dg-options ""-O2 -fdump-tree-sink-stats"" } */
int
foo (int a, int b, int c)
{
  int x = a * b;
  return c ? x : a;
}
/* We should sink the x = a * b calculation into the branch that returns x. */
/* { dg-final { scan-tree-dump-times ""Sunk statements: 1"" 1 ""sink"" } } */
"
"/* PR middle-end/26379 */
/* { dg-do compile } */
/* { dg-options ""-O2 -mmmx"" } */

#include <mmintrin.h>

void
foo (__m64 *p)
{
  __m64 m;

  m = p[0];
  m = _mm_srli_pi16(m, 2);
  m = _mm_slli_pi16(m, 8);

  p[0] = m;
  _mm_empty();
}
","/* PR middle-end/26379 */
/* { dg-do compile } */
/* { dg-options ""-O2 -mmmx"" } */

#include <mmintrin.h>

void
foo (__m64 *p)
{
  __m64 m;

  m = p[0];
  m = _mm_srli_pi16(m, 2);
  m = _mm_slli_pi16(m, 8);

  p[0] = m;
  _mm_empty();
}
"
"#include <limits.h>

extern void abort (void);

static __attribute__((noinline)) void foo (int a)
{
  int b = (a - 1) + INT_MIN;

  if (b != INT_MIN)
    abort ();
}

int main (void)
{
  foo (1);
  return 0;
}
","#include <limits.h>

extern void abort (void);

static __attribute__((noinline)) void foo (int a)
{
  int b = (a - 1) + INT_MIN;

  if (b != INT_MIN)
    abort ();
}

int main (void)
{
  foo (1);
  return 0;
}
"
"/* { dg-do run } */
/* { dg-options ""-O2 -mtune=core2 -msse2"" } */
/* { dg-require-effective-target sse2 } */

#define CHECK_H ""sse2-check.h""
#define TEST sse2_test

#include ""set-v8hi-2.h""
","/* { dg-do run } */
/* { dg-options ""-O2 -mtune=core2 -msse2"" } */
/* { dg-require-effective-target sse2 } */

#define CHECK_H ""sse2-check.h""
#define TEST sse2_test

#include ""set-v8hi-2.h""
"
"/* { dg-do run } */
/* { dg-options ""-O3 -fno-inline"" } */
/* { dg-require-effective-target lp64 } */
/* { dg-require-effective-target ppc_cpu_supports_hw } */

#define NO_WARN_X86_INTRINSICS 1
#include <x86intrin.h>
#include ""bmi-check.h""

int calc_blsr_u32 (int src1, int src2)
{
  return (src1-1) & (src2);
}

static void
bmi_test ()
{
  unsigned i;
  int src = 0xfacec0ff;
  int res, res_ref;

  for (i=0; i<5; ++i) {
    src = (i + src) << i;

    res_ref = calc_blsr_u32 (src, src);
    res = __blsr_u32 (src);

    if (res != res_ref)
      abort();
  }
}
","/* { dg-do run } */
/* { dg-options ""-O3 -fno-inline"" } */
/* { dg-require-effective-target lp64 } */
/* { dg-require-effective-target ppc_cpu_supports_hw } */

#define NO_WARN_X86_INTRINSICS 1
#include <x86intrin.h>
#include ""bmi-check.h""

int calc_blsr_u32 (int src1, int src2)
{
  return (src1-1) & (src2);
}

static void
bmi_test ()
{
  unsigned i;
  int src = 0xfacec0ff;
  int res, res_ref;

  for (i=0; i<5; ++i) {
    src = (i + src) << i;

    res_ref = calc_blsr_u32 (src, src);
    res = __blsr_u32 (src);

    if (res != res_ref)
      abort();
  }
}
"
"/* Check that Asan correctly instruments bitfields with non-round size.  */

/* { dg-do run } */
/* { dg-shouldfail ""asan"" } */

struct A
{
  char base;
  int : 4;
  long x : 7;
};

int __attribute__ ((noinline, noclone))
f (void *p) {
  return ((struct A *)p)->x;
}

int
main ()
{
  char a = 0;
  return f (&a);
}

/* { dg-output ""ERROR: AddressSanitizer: stack-buffer-overflow"" } */
","/* Check that Asan correctly instruments bitfields with non-round size.  */

/* { dg-do run } */
/* { dg-shouldfail ""asan"" } */

struct A
{
  char base;
  int : 4;
  long x : 7;
};

int __attribute__ ((noinline, noclone))
f (void *p) {
  return ((struct A *)p)->x;
}

int
main ()
{
  char a = 0;
  return f (&a);
}

/* { dg-output ""ERROR: AddressSanitizer: stack-buffer-overflow"" } */
"
"/* PR rtl-optimization/58726 */

int a, c;
union { int f1; int f2 : 1; } b;

short
foo (short p)
{
  return p < 0 ? p : a;
}

int
main ()
{
  if (sizeof (short) * __CHAR_BIT__ != 16
      || sizeof (int) * __CHAR_BIT__ != 32)
    return 0;
  b.f1 = 56374;
  unsigned short d;
  int e = b.f2;
  d = e == 0 ? b.f1 : 0;
  c = foo (d);
  if (c != (short) 56374)
    __builtin_abort ();
  return 0;
}
","/* PR rtl-optimization/58726 */

int a, c;
union { int f1; int f2 : 1; } b;

short
foo (short p)
{
  return p < 0 ? p : a;
}

int
main ()
{
  if (sizeof (short) * __CHAR_BIT__ != 16
      || sizeof (int) * __CHAR_BIT__ != 32)
    return 0;
  b.f1 = 56374;
  unsigned short d;
  int e = b.f2;
  d = e == 0 ? b.f1 : 0;
  c = foo (d);
  if (c != (short) 56374)
    __builtin_abort ();
  return 0;
}
"
"extern void abort (void);

typedef long fract32;

fract32 foo (fract32 f, short n)
{
  return __builtin_bfin_shl_fr1x32 (f, n);
}

int main ()
{
  fract32 t;

  t = foo (0x7feff4ff, 4);
  if (t != 0x7fffffff)
    abort ();

  return 0;
}

","extern void abort (void);

typedef long fract32;

fract32 foo (fract32 f, short n)
{
  return __builtin_bfin_shl_fr1x32 (f, n);
}

int main ()
{
  fract32 t;

  t = foo (0x7feff4ff, 4);
  if (t != 0x7fffffff)
    abort ();

  return 0;
}

"
"/* { dg-do compile } */
/* { dg-options ""-O2 -msse3"" } */

void
_mm_monitor (void const * __P, unsigned int __E, unsigned int __H)
{
   __builtin_ia32_monitor (__P, __E, __H);
}
","/* { dg-do compile } */
/* { dg-options ""-O2 -msse3"" } */

void
_mm_monitor (void const * __P, unsigned int __E, unsigned int __H)
{
   __builtin_ia32_monitor (__P, __E, __H);
}
"
"
/* { dg-do compile } */
/* { dg-options ""-Wuninitialized -O2"" } */

int g;
void bar();
void blah(int);

int foo (int n, int l, int m, int r)
{
  int v;

  if ( (n < 10) && (m == l)  && (r < 20) )
    v = r;

  if (m) g++; 
  else  bar();

  if ( (n <= 8) &&  (m == l)  && (r < 19) )
      blah(v); /* { dg-bogus ""uninitialized"" ""bogus warning"" } */

  return 0;
}
","
/* { dg-do compile } */
/* { dg-options ""-Wuninitialized -O2"" } */

int g;
void bar();
void blah(int);

int foo (int n, int l, int m, int r)
{
  int v;

  if ( (n < 10) && (m == l)  && (r < 20) )
    v = r;

  if (m) g++; 
  else  bar();

  if ( (n <= 8) &&  (m == l)  && (r < 19) )
      blah(v); /* { dg-bogus ""uninitialized"" ""bogus warning"" } */

  return 0;
}
"
"/* { dg-do run } */
/* { dg-require-effective-target avx } */
/* { dg-options ""-O2 -mavx"" } */

#define CHECK_H ""avx-check.h""
#define TEST avx_test

#include ""sse2-maskmovdqu.c""
","/* { dg-do run } */
/* { dg-require-effective-target avx } */
/* { dg-options ""-O2 -mavx"" } */

#define CHECK_H ""avx-check.h""
#define TEST avx_test

#include ""sse2-maskmovdqu.c""
"
"/* PR tree-optimization/61158 */
/* { dg-do compile } */
/* { dg-options ""-O2 -fdump-tree-original"" } */

unsigned long long
foo (unsigned int x)
{
  return ((unsigned long long) x & 0x00ff000000000000ULL) >> 40;
}

/* { dg-final { scan-tree-dump ""return 0;"" ""original"" { target { ilp32 || lp64 } } } } */
","/* PR tree-optimization/61158 */
/* { dg-do compile } */
/* { dg-options ""-O2 -fdump-tree-original"" } */

unsigned long long
foo (unsigned int x)
{
  return ((unsigned long long) x & 0x00ff000000000000ULL) >> 40;
}

/* { dg-final { scan-tree-dump ""return 0;"" ""original"" { target { ilp32 || lp64 } } } } */
"
"/* { dg-do compile } */

#define N 256
signed short image[N][N] __attribute__ ((__aligned__(__BIGGEST_ALIGNMENT__)));
signed short block[N][N] __attribute__ ((__aligned__(__BIGGEST_ALIGNMENT__)));
signed short out[N] __attribute__ ((__aligned__(__BIGGEST_ALIGNMENT__)));

/* Can't do outer-loop vectorization because of non-consecutive access.  */

void
foo (){
  int i,j;
  int diff;

  for (i = 0; i < N; i++) {
    diff = 0;
    for (j = 0; j < N; j+=8) {
      diff += (image[i][j] - block[i][j]);
    }
    out[i]=diff;
  }
}

/* { dg-final { scan-tree-dump-times ""OUTER LOOP VECTORIZED"" 1 ""vect"" { xfail *-*-* } } } */
/* { dg-final { scan-tree-dump-times ""grouped access in outer loop"" 1 ""vect"" } } */
","/* { dg-do compile } */

#define N 256
signed short image[N][N] __attribute__ ((__aligned__(__BIGGEST_ALIGNMENT__)));
signed short block[N][N] __attribute__ ((__aligned__(__BIGGEST_ALIGNMENT__)));
signed short out[N] __attribute__ ((__aligned__(__BIGGEST_ALIGNMENT__)));

/* Can't do outer-loop vectorization because of non-consecutive access.  */

void
foo (){
  int i,j;
  int diff;

  for (i = 0; i < N; i++) {
    diff = 0;
    for (j = 0; j < N; j+=8) {
      diff += (image[i][j] - block[i][j]);
    }
    out[i]=diff;
  }
}

/* { dg-final { scan-tree-dump-times ""OUTER LOOP VECTORIZED"" 1 ""vect"" { xfail *-*-* } } } */
/* { dg-final { scan-tree-dump-times ""grouped access in outer loop"" 1 ""vect"" } } */
"
"/* { dg-do run { target aarch64_sve_hw } } */
/* { dg-options ""-O2 -ftree-vectorize"" } */

#include ""vec_init_1.c""

#define TEST_INIT_VECTOR(TYPE, VAL)		\
  {						\
  TYPE r[NUM_ELEMS (TYPE)];			\
  dup_##TYPE (r, VAL);				\
  for (int i = 0; i < NUM_ELEMS (TYPE); i++)	\
    if (r[i] != VAL)				\
      __builtin_abort ();			\
  }

int __attribute__ ((optimize (1)))
main (void)
{
  TEST_INIT_VECTOR (int8_t, 0x2a);
  TEST_INIT_VECTOR (int16_t, 0x3976);
  TEST_INIT_VECTOR (int32_t, 0x31232976);
  TEST_INIT_VECTOR (int64_t, 0x9489363731232976LL);

  TEST_INIT_VECTOR (_Float16, -0x1.fp10);
  TEST_INIT_VECTOR (float, -0x1.fe02p10);
  TEST_INIT_VECTOR (double, 0x1.fe02eeeee1p10);

  return 0;
}
","/* { dg-do run { target aarch64_sve_hw } } */
/* { dg-options ""-O2 -ftree-vectorize"" } */

#include ""vec_init_1.c""

#define TEST_INIT_VECTOR(TYPE, VAL)		\
  {						\
  TYPE r[NUM_ELEMS (TYPE)];			\
  dup_##TYPE (r, VAL);				\
  for (int i = 0; i < NUM_ELEMS (TYPE); i++)	\
    if (r[i] != VAL)				\
      __builtin_abort ();			\
  }

int __attribute__ ((optimize (1)))
main (void)
{
  TEST_INIT_VECTOR (int8_t, 0x2a);
  TEST_INIT_VECTOR (int16_t, 0x3976);
  TEST_INIT_VECTOR (int32_t, 0x31232976);
  TEST_INIT_VECTOR (int64_t, 0x9489363731232976LL);

  TEST_INIT_VECTOR (_Float16, -0x1.fp10);
  TEST_INIT_VECTOR (float, -0x1.fe02p10);
  TEST_INIT_VECTOR (double, 0x1.fe02eeeee1p10);

  return 0;
}
"
"/* PR tree-optimization/55236 */
/* { dg-do run } */
/* { dg-options ""-O2 -fwrapv"" } */

extern void abort ();

__attribute__((noinline, noclone)) void
foo (int i)
{
  if (i > 0)
    abort ();
  i = -i;
  if (i < 0)
    return;
  abort ();
}

__attribute__((noinline, noclone)) void
bar (int i)
{
  if (i > 0 || (-i) >= 0)
    abort ();
}

int
main ()
{
  foo (-__INT_MAX__ - 1);
  bar (-__INT_MAX__ - 1);
  return 0;
}
","/* PR tree-optimization/55236 */
/* { dg-do run } */
/* { dg-options ""-O2 -fwrapv"" } */

extern void abort ();

__attribute__((noinline, noclone)) void
foo (int i)
{
  if (i > 0)
    abort ();
  i = -i;
  if (i < 0)
    return;
  abort ();
}

__attribute__((noinline, noclone)) void
bar (int i)
{
  if (i > 0 || (-i) >= 0)
    abort ();
}

int
main ()
{
  foo (-__INT_MAX__ - 1);
  bar (-__INT_MAX__ - 1);
  return 0;
}
"
"/* { dg-do compile } */
/* { dg-options ""-O2 -fdump-tree-pre"" } */
struct a {int a,b;};
struct a ret(int val)
{
   return val? (struct a){} : (struct a){};
}
/* { dg-final { scan-tree-dump-not ""if "" ""pre""} } */
","/* { dg-do compile } */
/* { dg-options ""-O2 -fdump-tree-pre"" } */
struct a {int a,b;};
struct a ret(int val)
{
   return val? (struct a){} : (struct a){};
}
/* { dg-final { scan-tree-dump-not ""if "" ""pre""} } */
"
"/* { dg-do run } */
/* { dg-options ""-O2 -mavx512vl"" } */
/* { dg-require-effective-target avx512vl } */

#define AVX512VL
#define AVX512F_LEN 256
#define AVX512F_LEN_HALF 128
#include ""avx512f-vcmppd-2.c""

#undef AVX512F_LEN
#undef AVX512F_LEN_HALF

#define AVX512F_LEN 128
#define AVX512F_LEN_HALF 128
#include ""avx512f-vcmppd-2.c""
","/* { dg-do run } */
/* { dg-options ""-O2 -mavx512vl"" } */
/* { dg-require-effective-target avx512vl } */

#define AVX512VL
#define AVX512F_LEN 256
#define AVX512F_LEN_HALF 128
#include ""avx512f-vcmppd-2.c""

#undef AVX512F_LEN
#undef AVX512F_LEN_HALF

#define AVX512F_LEN 128
#define AVX512F_LEN_HALF 128
#include ""avx512f-vcmppd-2.c""
"
"/* PR tree-optimization/70152 */
/* { dg-do compile } */
/* { dg-options ""-O2"" } */

int a;
int foo (void);
int setjmp (char *);
char buf[64];

static int
bar (int x)
{
  x = 0;
  setjmp (buf);
  for (;;)
    {
    switch (x)
      case 5:
	x = foo ();
    }
}

void
baz (void)
{
  bar (a);
}
","/* PR tree-optimization/70152 */
/* { dg-do compile } */
/* { dg-options ""-O2"" } */

int a;
int foo (void);
int setjmp (char *);
char buf[64];

static int
bar (int x)
{
  x = 0;
  setjmp (buf);
  for (;;)
    {
    switch (x)
      case 5:
	x = foo ();
    }
}

void
baz (void)
{
  bar (a);
}
"
"/* { dg-do compile }  */
/* { dg-options ""-O2"" }  */
/* { dg-final { scan-assembler-times ""sh.add"" 1 } }  */

typedef struct
{
  unsigned long int __val[(1024 / (8 * sizeof (unsigned long int)))];
}
__sigset_t;
int
__sigaddset (__sigset_t * __set, int __sig, int __stuff)
{
  unsigned long int __word =
    (((__sig) - 1) / (8 * sizeof (unsigned long int)));
  return __set->__val[__word] = __stuff;
}
","/* { dg-do compile }  */
/* { dg-options ""-O2"" }  */
/* { dg-final { scan-assembler-times ""sh.add"" 1 } }  */

typedef struct
{
  unsigned long int __val[(1024 / (8 * sizeof (unsigned long int)))];
}
__sigset_t;
int
__sigaddset (__sigset_t * __set, int __sig, int __stuff)
{
  unsigned long int __word =
    (((__sig) - 1) / (8 * sizeof (unsigned long int)));
  return __set->__val[__word] = __stuff;
}
"
"/* { dg-do compile } */
/* { dg-options ""-O3 -msse2"" } */

#include <emmintrin.h>

__m128d f()
{
  __m128d r={3,4};
  r[0]=1;
  r[1]=2;
  return r;
}

/* We want to ""vectorize"" this to a aligned vector load from the
   constant pool.  */

/* { dg-final { scan-assembler ""movapd"" } } */
","/* { dg-do compile } */
/* { dg-options ""-O3 -msse2"" } */

#include <emmintrin.h>

__m128d f()
{
  __m128d r={3,4};
  r[0]=1;
  r[1]=2;
  return r;
}

/* We want to ""vectorize"" this to a aligned vector load from the
   constant pool.  */

/* { dg-final { scan-assembler ""movapd"" } } */
"
"/* { dg-do compile } */

int main (void) { return 0; }

/* { dg-final { output-exists } } */
","/* { dg-do compile } */

int main (void) { return 0; }

/* { dg-final { output-exists } } */
"
"f(char*c){extern char a[],b[];return a+(b-c);}
","f(char*c){extern char a[],b[];return a+(b-c);}
"
"typedef struct VEC_constructor_elt_gcx { } VEC_constructor_elt_gc;
#include ""20091016-1_a.h""
struct gcc_target {
    void (* builtin_vec_perm) (tree*);
};
extern struct gcc_target targetm;
void dwarf2out_begin_prologue (tree t)
{
    (*targetm.builtin_vec_perm) (&t);
}
struct die_arg_entry_struct {
    tree arg;
};
void *gt_pch_p_20VEC_die_arg_entry_gc (struct die_arg_entry_struct *vec)
{
    return &(vec->arg);
}

","typedef struct VEC_constructor_elt_gcx { } VEC_constructor_elt_gc;
#include ""20091016-1_a.h""
struct gcc_target {
    void (* builtin_vec_perm) (tree*);
};
extern struct gcc_target targetm;
void dwarf2out_begin_prologue (tree t)
{
    (*targetm.builtin_vec_perm) (&t);
}
struct die_arg_entry_struct {
    tree arg;
};
void *gt_pch_p_20VEC_die_arg_entry_gc (struct die_arg_entry_struct *vec)
{
    return &(vec->arg);
}

"
"/* PR middle-end/40172 */
/* { dg-do compile */
/* { dg-xfail-if """" { ""*-*-*"" } } */
/* { dg-options ""-Wall -W -Werror -Wlogical-op"" } */

extern int xxx;

#define XXX xxx

int
test (void)
{
  if (!XXX && xxx)
    return 4;
  else
    return 0;
}
","/* PR middle-end/40172 */
/* { dg-do compile */
/* { dg-xfail-if """" { ""*-*-*"" } } */
/* { dg-options ""-Wall -W -Werror -Wlogical-op"" } */

extern int xxx;

#define XXX xxx

int
test (void)
{
  if (!XXX && xxx)
    return 4;
  else
    return 0;
}
"
"/* { dg-do compile } */
/* { dg-options ""-O2 -fdump-tree-optimized"" } */

int
foo (char a, unsigned short b)
{
  return (a & !a) | (b & !b);
}

/* As long as comparisons aren't boolified and casts from boolean-types
   aren't preserved, the folding of  X & !X to zero fails.  */
/* { dg-final { scan-tree-dump-times ""return 0"" 1 ""optimized"" { xfail *-*-* } } } */
","/* { dg-do compile } */
/* { dg-options ""-O2 -fdump-tree-optimized"" } */

int
foo (char a, unsigned short b)
{
  return (a & !a) | (b & !b);
}

/* As long as comparisons aren't boolified and casts from boolean-types
   aren't preserved, the folding of  X & !X to zero fails.  */
/* { dg-final { scan-tree-dump-times ""return 0"" 1 ""optimized"" { xfail *-*-* } } } */
"
"/* { dg-do compile } */
/* { dg-require-effective-target vect_float } */
/* { dg-require-effective-target vect_call_nearbyintf } */

#define N 32

void
foo (float *output, float *input)
{
  int i = 0;
  /* Vectorizable.  */
  for (i = 0; i < N; i++)
    output[i] = __builtin_nearbyintf (input[i]);
}

/* { dg-final { scan-tree-dump-times ""vectorized 1 loops"" 1 ""vect"" { target vect_call_nearbyintf } } } */
","/* { dg-do compile } */
/* { dg-require-effective-target vect_float } */
/* { dg-require-effective-target vect_call_nearbyintf } */

#define N 32

void
foo (float *output, float *input)
{
  int i = 0;
  /* Vectorizable.  */
  for (i = 0; i < N; i++)
    output[i] = __builtin_nearbyintf (input[i]);
}

/* { dg-final { scan-tree-dump-times ""vectorized 1 loops"" 1 ""vect"" { target vect_call_nearbyintf } } } */
"
"/* { dg-do compile } */
/* { dg-options ""-mavx2 -O2"" } */
/* { dg-final { scan-assembler ""vpabsw\[ \\t\]+\[^\n\]*%ymm\[0-9\]"" } } */

#include <immintrin.h>

volatile __m256i x;

void extern
avx2_test (void)
{
  x = _mm256_abs_epi16 (x);
}
","/* { dg-do compile } */
/* { dg-options ""-mavx2 -O2"" } */
/* { dg-final { scan-assembler ""vpabsw\[ \\t\]+\[^\n\]*%ymm\[0-9\]"" } } */

#include <immintrin.h>

volatile __m256i x;

void extern
avx2_test (void)
{
  x = _mm256_abs_epi16 (x);
}
"
"/* Test that accessed external variables are marked. */
/* { dg-do compile } */
/* { dg-skip-if """" { *-*-darwin* } } */
/* { dg-require-visibility """" } */
/* { dg-final { scan-hidden ""foo"" { xfail *-*-aix* } } } */

extern int foo __attribute__ ((visibility (""hidden"")));
int f () {
  return foo;
}
","/* Test that accessed external variables are marked. */
/* { dg-do compile } */
/* { dg-skip-if """" { *-*-darwin* } } */
/* { dg-require-visibility """" } */
/* { dg-final { scan-hidden ""foo"" { xfail *-*-aix* } } } */

extern int foo __attribute__ ((visibility (""hidden"")));
int f () {
  return foo;
}
"
"/* { dg-do run } */
/* { dg-options ""-O2 -mavx512vl"" } */
/* { dg-require-effective-target avx512vl } */

#define AVX512VL
#define AVX512F_LEN 256
#define AVX512F_LEN_HALF 128
#include ""avx512f-vcvtpd2ps-2.c""

#undef AVX512F_LEN
#undef AVX512F_LEN_HALF

#define AVX512F_LEN 128
#define AVX512F_LEN_HALF 128
#include ""avx512f-vcvtpd2ps-2.c""
","/* { dg-do run } */
/* { dg-options ""-O2 -mavx512vl"" } */
/* { dg-require-effective-target avx512vl } */

#define AVX512VL
#define AVX512F_LEN 256
#define AVX512F_LEN_HALF 128
#include ""avx512f-vcvtpd2ps-2.c""

#undef AVX512F_LEN
#undef AVX512F_LEN_HALF

#define AVX512F_LEN 128
#define AVX512F_LEN_HALF 128
#include ""avx512f-vcvtpd2ps-2.c""
"
"/* { dg-do compile { target { powerpc*-*-* } } } */
/* { dg-skip-if ""do not override -mcpu"" { powerpc*-*-* } { ""-mcpu=*"" } { ""-mcpu=power9"" } } */
/* { dg-require-effective-target powerpc_p9vector_ok } */
/* { dg-options ""-mcpu=power9"" } */

#include <altivec.h>

vector bool int
fetch_data (vector float *arg1_p, vector float *arg2_p)
{
  vector float arg_1 = *arg1_p;
  vector float arg_2 = *arg2_p;

  return vec_cmpne (arg_1, arg_2);
}

/* { dg-final { scan-assembler ""xvcmpeqsp"" } } */
","/* { dg-do compile { target { powerpc*-*-* } } } */
/* { dg-skip-if ""do not override -mcpu"" { powerpc*-*-* } { ""-mcpu=*"" } { ""-mcpu=power9"" } } */
/* { dg-require-effective-target powerpc_p9vector_ok } */
/* { dg-options ""-mcpu=power9"" } */

#include <altivec.h>

vector bool int
fetch_data (vector float *arg1_p, vector float *arg2_p)
{
  vector float arg_1 = *arg1_p;
  vector float arg_2 = *arg2_p;

  return vec_cmpne (arg_1, arg_2);
}

/* { dg-final { scan-assembler ""xvcmpeqsp"" } } */
"
"/* { dg-do run } */
/* { dg-require-effective-target arm_neon_hw } */
/* { dg-options ""-O2 -fno-common -ftree-vectorize -mno-unaligned-access"" }  */
/* { dg-add-options arm_neon } */


/* Test for-mno-unaligned-access and -ftree-vectorize  and results bus error. */
#define N 128

char ia[N];
char ib[N+1];

int main() {
  int i;
  for(i = 0; i < N; ++i) {
    ia[i] = ib[i + 1];
  }

  return 0;
}

","/* { dg-do run } */
/* { dg-require-effective-target arm_neon_hw } */
/* { dg-options ""-O2 -fno-common -ftree-vectorize -mno-unaligned-access"" }  */
/* { dg-add-options arm_neon } */


/* Test for-mno-unaligned-access and -ftree-vectorize  and results bus error. */
#define N 128

char ia[N];
char ib[N+1];

int main() {
  int i;
  for(i = 0; i < N; ++i) {
    ia[i] = ib[i + 1];
  }

  return 0;
}

"
"/* { dg-do run } */
/* { dg-options ""-O2 -msse2"" } */
/* { dg-require-effective-target sse2 } */

#include ""sse2-check.h""

#ifdef DEBUG
#include <stdio.h>
#endif

#include <emmintrin.h>

static void
__attribute__((noinline))
test (unsigned long long *v)
{
  union
    {
      __m128i x;
      unsigned long long i[2];
    } u;
  unsigned int i;
  
  u.x = _mm_set_epi64x (v[1], v[0]);

  for (i = 0; i < sizeof (u) / sizeof (v[0]); i++)
    if (v[i] != u.i[i])
      {
#ifdef DEBUG
	printf (""%i: 0x%llx != 0x%llx\n"", i, v[i], u.i[i]);
#endif
	abort ();
      }
}

static void
sse2_test (void)
{
  unsigned long long v[2]
    = { 0x7B5B546573745665LL, 0x63746F725D53475DLL };
  test (v);
}
","/* { dg-do run } */
/* { dg-options ""-O2 -msse2"" } */
/* { dg-require-effective-target sse2 } */

#include ""sse2-check.h""

#ifdef DEBUG
#include <stdio.h>
#endif

#include <emmintrin.h>

static void
__attribute__((noinline))
test (unsigned long long *v)
{
  union
    {
      __m128i x;
      unsigned long long i[2];
    } u;
  unsigned int i;
  
  u.x = _mm_set_epi64x (v[1], v[0]);

  for (i = 0; i < sizeof (u) / sizeof (v[0]); i++)
    if (v[i] != u.i[i])
      {
#ifdef DEBUG
	printf (""%i: 0x%llx != 0x%llx\n"", i, v[i], u.i[i]);
#endif
	abort ();
      }
}

static void
sse2_test (void)
{
  unsigned long long v[2]
    = { 0x7B5B546573745665LL, 0x63746F725D53475DLL };
  test (v);
}
"
"/* PR middle-end/48722 */
/* { dg-do compile } */
/* { dg-options ""-Os -mno-push-args"" } */

extern long long a;
extern int b;
void bar (int, long long);

void
foo (void)
{
  bar (a > 0x85, b);
}
","/* PR middle-end/48722 */
/* { dg-do compile } */
/* { dg-options ""-Os -mno-push-args"" } */

extern long long a;
extern int b;
void bar (int, long long);

void
foo (void)
{
  bar (a > 0x85, b);
}
"
"/* This used to ICE on s390 due to bug in the definition of the 'R'
   constraint which replaced the 'm' constraint (together with 'T')
   while adding z10 support.  */

/* { dg-do compile } */
/* { dg-options ""-O"" } */

int boo()
{
  struct {
    unsigned char pad[4096];
    unsigned long bar;
  } *foo;
  asm volatile( """" : ""=m"" (*(unsigned long long*)(foo->bar))
		: ""a"" (&foo->bar));
}
","/* This used to ICE on s390 due to bug in the definition of the 'R'
   constraint which replaced the 'm' constraint (together with 'T')
   while adding z10 support.  */

/* { dg-do compile } */
/* { dg-options ""-O"" } */

int boo()
{
  struct {
    unsigned char pad[4096];
    unsigned long bar;
  } *foo;
  asm volatile( """" : ""=m"" (*(unsigned long long*)(foo->bar))
		: ""a"" (&foo->bar));
}
"
"/* Test diagnostics for old-style definition not matching prior
   prototype are present and give correct location for that prototype
   (bug 15698).  Prototype not last declaration.  */
/* Origin: Joseph Myers <joseph@codesourcery.com> */
/* { dg-do compile } */
/* { dg-options ""-std=gnu99"" } */

void f();
void f(int); /* { dg-error ""prototype declaration"" } */
void f();
void f(a) long a; {} /* { dg-error ""argument 'a' doesn't match prototype"" } */
","/* Test diagnostics for old-style definition not matching prior
   prototype are present and give correct location for that prototype
   (bug 15698).  Prototype not last declaration.  */
/* Origin: Joseph Myers <joseph@codesourcery.com> */
/* { dg-do compile } */
/* { dg-options ""-std=gnu99"" } */

void f();
void f(int); /* { dg-error ""prototype declaration"" } */
void f();
void f(a) long a; {} /* { dg-error ""argument 'a' doesn't match prototype"" } */
"
"int
foo (char *a, char *b)
{
  int x;
  *a = *b;
  x = *b;
  if ((char) x)
    return 1;
  else
    return 0;
}
","int
foo (char *a, char *b)
{
  int x;
  *a = *b;
  x = *b;
  if ((char) x)
    return 1;
  else
    return 0;
}
"
"/* { dg-do run } */
/* { dg-options ""-O2 -mavx512vl"" } */
/* { dg-require-effective-target avx512vl } */

#define AVX512VL
#define AVX512F_LEN 256
#define AVX512F_LEN_HALF 128
#include ""avx512f-vfnmaddXXXps-2.c""

#undef AVX512F_LEN
#undef AVX512F_LEN_HALF

#define AVX512F_LEN 128
#define AVX512F_LEN_HALF 128
#include ""avx512f-vfnmaddXXXps-2.c""
","/* { dg-do run } */
/* { dg-options ""-O2 -mavx512vl"" } */
/* { dg-require-effective-target avx512vl } */

#define AVX512VL
#define AVX512F_LEN 256
#define AVX512F_LEN_HALF 128
#include ""avx512f-vfnmaddXXXps-2.c""

#undef AVX512F_LEN
#undef AVX512F_LEN_HALF

#define AVX512F_LEN 128
#define AVX512F_LEN_HALF 128
#include ""avx512f-vfnmaddXXXps-2.c""
"
"/* Check that we handle call-clobbered FPRs correctly.  */
/* { dg-skip-if ""code quality test"" { *-*-* } { ""-O0"" } { """" } } */
/* { dg-options ""-mabi=32 -modd-spreg -mfp32 -ffixed-f0 -ffixed-f1 -ffixed-f2 -ffixed-f3 -ffixed-f4 -ffixed-f5 -ffixed-f6 -ffixed-f7 -ffixed-f8 -ffixed-f9 -ffixed-f10 -ffixed-f11 -ffixed-f12 -ffixed-f13 -ffixed-f14 -ffixed-f15 -ffixed-f16 -ffixed-f17 -ffixed-f18 -ffixed-f19 -ffixed-f20 -ffixed-f22 -ffixed-f24 -ffixed-f26 -ffixed-f28 -ffixed-f30"" } */

void bar (void);
float a;
float
foo ()
{
  float b = a + 1.0f;
  bar();
  return b;
}
/* { dg-final { scan-assembler-times ""lwc1"" 4 } } */
/* { dg-final { scan-assembler-times ""swc1"" 2 } } */
/* { dg-final { scan-assembler-not ""mtc"" } } */
/* { dg-final { scan-assembler-not ""mfc"" } } */
/* { dg-final { scan-assembler-not ""mthc"" } } */
/* { dg-final { scan-assembler-not ""mfhc"" } } */
/* { dg-final { scan-assembler-not ""sdc1"" } } */
/* { dg-final { scan-assembler-not ""ldc1"" } } */
","/* Check that we handle call-clobbered FPRs correctly.  */
/* { dg-skip-if ""code quality test"" { *-*-* } { ""-O0"" } { """" } } */
/* { dg-options ""-mabi=32 -modd-spreg -mfp32 -ffixed-f0 -ffixed-f1 -ffixed-f2 -ffixed-f3 -ffixed-f4 -ffixed-f5 -ffixed-f6 -ffixed-f7 -ffixed-f8 -ffixed-f9 -ffixed-f10 -ffixed-f11 -ffixed-f12 -ffixed-f13 -ffixed-f14 -ffixed-f15 -ffixed-f16 -ffixed-f17 -ffixed-f18 -ffixed-f19 -ffixed-f20 -ffixed-f22 -ffixed-f24 -ffixed-f26 -ffixed-f28 -ffixed-f30"" } */

void bar (void);
float a;
float
foo ()
{
  float b = a + 1.0f;
  bar();
  return b;
}
/* { dg-final { scan-assembler-times ""lwc1"" 4 } } */
/* { dg-final { scan-assembler-times ""swc1"" 2 } } */
/* { dg-final { scan-assembler-not ""mtc"" } } */
/* { dg-final { scan-assembler-not ""mfc"" } } */
/* { dg-final { scan-assembler-not ""mthc"" } } */
/* { dg-final { scan-assembler-not ""mfhc"" } } */
/* { dg-final { scan-assembler-not ""sdc1"" } } */
/* { dg-final { scan-assembler-not ""ldc1"" } } */
"
"/* PR tree-optimization/65216 */

int a, b = 62, e;
volatile int c, d;

int
main ()
{
  int f = 0;
  for (a = 0; a < 2; a++)
    {
      b &= (8 ^ f) & 1;
      for (e = 0; e < 6; e++)
	if (c)
	  f = d;
    }
  if (b != 0)
    __builtin_abort ();
  return 0;
}
","/* PR tree-optimization/65216 */

int a, b = 62, e;
volatile int c, d;

int
main ()
{
  int f = 0;
  for (a = 0; a < 2; a++)
    {
      b &= (8 ^ f) & 1;
      for (e = 0; e < 6; e++)
	if (c)
	  f = d;
    }
  if (b != 0)
    __builtin_abort ();
  return 0;
}
"
"/* { dg-do compile } */
/* { dg-options ""-mavx2 -O2"" } */
/* { dg-final { scan-assembler ""vpackusdw\[ \\t\]+\[^\n\]*%ymm\[0-9\]"" } } */

#include <immintrin.h>

volatile __m256i x;

void extern
avx2_test (void)
{
  x = _mm256_packus_epi32 (x, x);
}
","/* { dg-do compile } */
/* { dg-options ""-mavx2 -O2"" } */
/* { dg-final { scan-assembler ""vpackusdw\[ \\t\]+\[^\n\]*%ymm\[0-9\]"" } } */

#include <immintrin.h>

volatile __m256i x;

void extern
avx2_test (void)
{
  x = _mm256_packus_epi32 (x, x);
}
"
"/* { dg-do assemble { target aarch64_asm_sve_ok } } */
/* { dg-options ""-O2 -ftree-vectorize -msve-vector-bits=scalable --save-temps"" } */

#include ""strided_store_5.c""

/* { dg-final { scan-assembler-not {\[x[0-9]+, z[0-9]+\.s} } } */
/* { dg-final { scan-assembler-times {\tst1d\tz[0-9]+\.d, p[0-7], \[x[0-9]+, z[0-9]+.d\]\n} 15 } } */
","/* { dg-do assemble { target aarch64_asm_sve_ok } } */
/* { dg-options ""-O2 -ftree-vectorize -msve-vector-bits=scalable --save-temps"" } */

#include ""strided_store_5.c""

/* { dg-final { scan-assembler-not {\[x[0-9]+, z[0-9]+\.s} } } */
/* { dg-final { scan-assembler-times {\tst1d\tz[0-9]+\.d, p[0-7], \[x[0-9]+, z[0-9]+.d\]\n} 15 } } */
"
"/* { dg-do run } */
/* { dg-options ""-O2 -mavx512vl"" } */
/* { dg-require-effective-target avx512vl } */

#define AVX512VL
#define AVX512F_LEN 256
#define AVX512F_LEN_HALF 128
#include ""avx512f-vpxorq-2.c""

#undef AVX512F_LEN
#undef AVX512F_LEN_HALF

#define AVX512F_LEN 128
#define AVX512F_LEN_HALF 128
#include ""avx512f-vpxorq-2.c""
","/* { dg-do run } */
/* { dg-options ""-O2 -mavx512vl"" } */
/* { dg-require-effective-target avx512vl } */

#define AVX512VL
#define AVX512F_LEN 256
#define AVX512F_LEN_HALF 128
#include ""avx512f-vpxorq-2.c""

#undef AVX512F_LEN
#undef AVX512F_LEN_HALF

#define AVX512F_LEN 128
#define AVX512F_LEN_HALF 128
#include ""avx512f-vpxorq-2.c""
"
"bar (foo, a)
     int (**foo) ();
{

  (foo)[1] = bar;

  foo[a] (1);
}
","bar (foo, a)
     int (**foo) ();
{

  (foo)[1] = bar;

  foo[a] (1);
}
"
"/* Copyright (C) 2003 Free Software Foundation.

   Test that the -fno-wrapv command line option is accepted and enables
   ""unsafe"" optimizations that rely on undefined arithmetic overflow.

   Written by Roger Sayle, 31st May 2003.  */

/* { dg-do run } */
/* { dg-options ""-O2 -fno-wrapv"" } */

#include <limits.h>

extern void abort ();

int test(int x)
{
  return (2*x)/2;
}

int
main()
{
  int x = INT_MAX;

  if (test(x) != x)
    abort ();
  return 0;
}

","/* Copyright (C) 2003 Free Software Foundation.

   Test that the -fno-wrapv command line option is accepted and enables
   ""unsafe"" optimizations that rely on undefined arithmetic overflow.

   Written by Roger Sayle, 31st May 2003.  */

/* { dg-do run } */
/* { dg-options ""-O2 -fno-wrapv"" } */

#include <limits.h>

extern void abort ();

int test(int x)
{
  return (2*x)/2;
}

int
main()
{
  int x = INT_MAX;

  if (test(x) != x)
    abort ();
  return 0;
}

"
"/* { dg-do compile } */
/* { dg-options ""-mhle"" } */
/* { dg-final { scan-assembler ""lock;?\[ \n\t\]+\(xacquire\|\.byte\[ \t\]+0xf2\)\[ \t\n\]+and"" } } */

void
hle_and (int *p, int v)
{
  __atomic_fetch_and (p, v, __ATOMIC_ACQUIRE | __ATOMIC_HLE_ACQUIRE);
}
","/* { dg-do compile } */
/* { dg-options ""-mhle"" } */
/* { dg-final { scan-assembler ""lock;?\[ \n\t\]+\(xacquire\|\.byte\[ \t\]+0xf2\)\[ \t\n\]+and"" } } */

void
hle_and (int *p, int v)
{
  __atomic_fetch_and (p, v, __ATOMIC_ACQUIRE | __ATOMIC_HLE_ACQUIRE);
}
"
"/* { dg-do compile } */

typedef struct
{
  unsigned long bits[4];
} nodemask_t;

struct cpuset
{
  long flags;
  nodemask_t mems_allowed;
  struct cpuset *parent;
} b;

void func1(unsigned long *p1, int p2)
{
  p1[p2 - 1] = 0;
}

void func2(nodemask_t *p1, int p2)
{
  func1(p1->bits, p2);
}

void func3(void)
{
  /* This accesses b.flags.  */
  func2(&b.mems_allowed, 0);
}
","/* { dg-do compile } */

typedef struct
{
  unsigned long bits[4];
} nodemask_t;

struct cpuset
{
  long flags;
  nodemask_t mems_allowed;
  struct cpuset *parent;
} b;

void func1(unsigned long *p1, int p2)
{
  p1[p2 - 1] = 0;
}

void func2(nodemask_t *p1, int p2)
{
  func1(p1->bits, p2);
}

void func3(void)
{
  /* This accesses b.flags.  */
  func2(&b.mems_allowed, 0);
}
"
"
foo(unsigned int x)
{
  return (x << 1) | (x >> 31);
}
","
foo(unsigned int x)
{
  return (x << 1) | (x >> 31);
}
"
"/* { dg-do compile } */
/* { dg-options ""-O1 -fdump-tree-optimized"" } */

_Bool f1(_Bool x)
{
  return !!x;
}

/* There should be no != 0 which is produced by the front-end as
   bool_var != 0 is the same as bool_var. */
/* { dg-final { scan-tree-dump-times ""!= 0"" 0 ""optimized""} } */

/* There should be no subfe for powerpc.  Check if we actually optimized
   away the comparison.  */
/* { dg-final { scan-assembler-times ""subfe"" 0 { target powerpc*-*-* } } } */

","/* { dg-do compile } */
/* { dg-options ""-O1 -fdump-tree-optimized"" } */

_Bool f1(_Bool x)
{
  return !!x;
}

/* There should be no != 0 which is produced by the front-end as
   bool_var != 0 is the same as bool_var. */
/* { dg-final { scan-tree-dump-times ""!= 0"" 0 ""optimized""} } */

/* There should be no subfe for powerpc.  Check if we actually optimized
   away the comparison.  */
/* { dg-final { scan-assembler-times ""subfe"" 0 { target powerpc*-*-* } } } */

"
"/* { dg-do compile } */
/* { dg-options ""-O2 -fdump-tree-optimized"" } */

int
foo (_Bool a, _Bool b)
{
  return (a | (a == 0)) | ((b ^ 1) | b);
}

/* { dg-final { scan-tree-dump-times ""return 1"" 1 ""optimized"" } } */
","/* { dg-do compile } */
/* { dg-options ""-O2 -fdump-tree-optimized"" } */

int
foo (_Bool a, _Bool b)
{
  return (a | (a == 0)) | ((b ^ 1) | b);
}

/* { dg-final { scan-tree-dump-times ""return 1"" 1 ""optimized"" } } */
"
"/* { dg-do run } */
/* { dg-options ""-O2"" } */

int __attribute__((noinline))
foo(char c)
{
  unsigned short a = (unsigned short)c;
  if (a >= -32000 && a <= 32000)
    return c == 0;
  return -1;
}

extern void abort (void);

int main()
{
  if (foo(1) == 1)
    abort ();
  return 0;
}

","/* { dg-do run } */
/* { dg-options ""-O2"" } */

int __attribute__((noinline))
foo(char c)
{
  unsigned short a = (unsigned short)c;
  if (a >= -32000 && a <= 32000)
    return c == 0;
  return -1;
}

extern void abort (void);

int main()
{
  if (foo(1) == 1)
    abort ();
  return 0;
}

"
"/* { dg-do compile } */
/* { dg-options ""-Wtype-limits"" } */

struct A
{
  struct A *p;
};

int foo(const struct A *q)
{
  return q->p == q;
}

void bar(int);

void baz()
{
  struct A a;

  while (foo(&a))
    bar(foo(&a));
}
","/* { dg-do compile } */
/* { dg-options ""-Wtype-limits"" } */

struct A
{
  struct A *p;
};

int foo(const struct A *q)
{
  return q->p == q;
}

void bar(int);

void baz()
{
  struct A a;

  while (foo(&a))
    bar(foo(&a));
}
"
"/* { dg-do compile } */
/* { dg-options ""-Os -fno-tree-fre -fdump-tree-dom2-details"" } */

void foo(int *);
void f2(int dst[3], int R)
{
  int i, inter[2];
  _Bool inter0p = 0;
  _Bool inter1p = 0;
  for (i = 1; i < R; i++)
    {
      inter0p = 1;
      inter1p = 1;
    }
  if (inter0p)
    inter[0] = 1;
  if (inter1p)
    inter[1] = 1;
  foo(inter);
}

/* { dg-final { scan-tree-dump ""Threaded jump"" ""dom2"" } } */
","/* { dg-do compile } */
/* { dg-options ""-Os -fno-tree-fre -fdump-tree-dom2-details"" } */

void foo(int *);
void f2(int dst[3], int R)
{
  int i, inter[2];
  _Bool inter0p = 0;
  _Bool inter1p = 0;
  for (i = 1; i < R; i++)
    {
      inter0p = 1;
      inter1p = 1;
    }
  if (inter0p)
    inter[0] = 1;
  if (inter1p)
    inter[1] = 1;
  foo(inter);
}

/* { dg-final { scan-tree-dump ""Threaded jump"" ""dom2"" } } */
"
"/* { dg-do compile } */
/* { dg-options ""-mcmse"" } */

#include ""../cmse-13.x""

/* Checks for saving and clearing prior to function call.  */
/* { dg-final { scan-assembler ""lsrs\tr4, r4, #1"" } } */
/* { dg-final { scan-assembler ""lsls\tr4, r4, #1"" } } */
/* { dg-final { scan-assembler-not ""movs\tr0, r4"" } } */
/* { dg-final { scan-assembler ""\n\tmovs\tr1, r4"" } } */
/* { dg-final { scan-assembler-not ""\n\tmovs\tr2, r4\n\tmovs\tr3, r4"" } } */
/* { dg-final { scan-assembler-not ""vmov"" } } */
/* { dg-final { scan-assembler-not ""vmsr"" } } */

/* Now we check that we use the correct intrinsic to call.  */
/* { dg-final { scan-assembler ""bl\t__gnu_cmse_nonsecure_call"" } } */

","/* { dg-do compile } */
/* { dg-options ""-mcmse"" } */

#include ""../cmse-13.x""

/* Checks for saving and clearing prior to function call.  */
/* { dg-final { scan-assembler ""lsrs\tr4, r4, #1"" } } */
/* { dg-final { scan-assembler ""lsls\tr4, r4, #1"" } } */
/* { dg-final { scan-assembler-not ""movs\tr0, r4"" } } */
/* { dg-final { scan-assembler ""\n\tmovs\tr1, r4"" } } */
/* { dg-final { scan-assembler-not ""\n\tmovs\tr2, r4\n\tmovs\tr3, r4"" } } */
/* { dg-final { scan-assembler-not ""vmov"" } } */
/* { dg-final { scan-assembler-not ""vmsr"" } } */

/* Now we check that we use the correct intrinsic to call.  */
/* { dg-final { scan-assembler ""bl\t__gnu_cmse_nonsecure_call"" } } */

"
"/* { dg-do run } */
/* { dg-options ""-O2 -mavx512bw -mavx512vl"" } */
/* { dg-require-effective-target avx512vl } */
/* { dg-require-effective-target avx512bw } */

#define AVX512VL
#define AVX512F_LEN 256
#define AVX512F_LEN_HALF 128
#include ""avx512bw-vpshufhw-2.c""

#undef AVX512F_LEN
#undef AVX512F_LEN_HALF

#define AVX512F_LEN 128
#define AVX512F_LEN_HALF 128
#include ""avx512bw-vpshufhw-2.c""
","/* { dg-do run } */
/* { dg-options ""-O2 -mavx512bw -mavx512vl"" } */
/* { dg-require-effective-target avx512vl } */
/* { dg-require-effective-target avx512bw } */

#define AVX512VL
#define AVX512F_LEN 256
#define AVX512F_LEN_HALF 128
#include ""avx512bw-vpshufhw-2.c""

#undef AVX512F_LEN
#undef AVX512F_LEN_HALF

#define AVX512F_LEN 128
#define AVX512F_LEN_HALF 128
#include ""avx512bw-vpshufhw-2.c""
"
"/* { dg-require-effective-target label_values } */

x (int i)
{
  void *j[] = {&&x, &&y, &&z};
  goto *j[i];
 x:return 2;
 y:return 3;
 z:return 5;

}
main ()
{
  if (x (0) != 2 || x (1) != 3 || x (2) != 5)
    abort();
  exit(0);
}
","/* { dg-require-effective-target label_values } */

x (int i)
{
  void *j[] = {&&x, &&y, &&z};
  goto *j[i];
 x:return 2;
 y:return 3;
 z:return 5;

}
main ()
{
  if (x (0) != 2 || x (1) != 3 || x (2) != 5)
    abort();
  exit(0);
}
"
"/* { dg-do run } */
/* { dg-options ""-O2 -mstringop-strategy=unrolled_loop -mtune=nocona"" } */

#define PATTERN 0xdeadbeef
#define SIZE    32

struct S { int i; char str[SIZE]; int j; };

void __attribute__((noclone, noinline))
my_memcpy (char *, const char *, unsigned int);

void
my_memcpy (char *dst, const char *src, unsigned int len)
{
  if (len < 8)
    __builtin_abort ();

  __builtin_memcpy (dst, src, len);
}

int
main (void)
{
  const char str[SIZE]= ""1234567890123456789012345678901"";
  struct S *s = __builtin_malloc (sizeof (struct S));

  s->j = PATTERN;
  my_memcpy (s->str, str, SIZE);
  if (s->j != PATTERN)
    __builtin_abort ();

  return 0;
}
","/* { dg-do run } */
/* { dg-options ""-O2 -mstringop-strategy=unrolled_loop -mtune=nocona"" } */

#define PATTERN 0xdeadbeef
#define SIZE    32

struct S { int i; char str[SIZE]; int j; };

void __attribute__((noclone, noinline))
my_memcpy (char *, const char *, unsigned int);

void
my_memcpy (char *dst, const char *src, unsigned int len)
{
  if (len < 8)
    __builtin_abort ();

  __builtin_memcpy (dst, src, len);
}

int
main (void)
{
  const char str[SIZE]= ""1234567890123456789012345678901"";
  struct S *s = __builtin_malloc (sizeof (struct S));

  s->j = PATTERN;
  my_memcpy (s->str, str, SIZE);
  if (s->j != PATTERN)
    __builtin_abort ();

  return 0;
}
"
"typedef struct x { int a; int b; } __attribute__((aligned(32))) X;
typedef struct y { X x[32]; int c; } Y;

Y y[2];

int main(void)
{
  if (((char *)&y[1] - (char *)&y[0]) & 31)
    abort ();
  exit (0);
}                
","typedef struct x { int a; int b; } __attribute__((aligned(32))) X;
typedef struct y { X x[32]; int c; } Y;

Y y[2];

int main(void)
{
  if (((char *)&y[1] - (char *)&y[0]) & 31)
    abort ();
  exit (0);
}                
"
"/* { dg-do compile } */
/* { dg-options ""-mavx512f -O2"" } */
/* { dg-final { scan-assembler-times ""vfmsub...sd\[ \\t\]+\[^\n\]*\{rn-sae\}\[^\{\n\]*%xmm\[0-9\]+(?:\n|\[ \\t\]+#)"" 1 } } */

#include <immintrin.h>

volatile __m128d a, b, c;

void extern
avx512f_test (void)
{
  a = _mm_fmsub_round_sd (a, b, c, _MM_FROUND_TO_NEAREST_INT | _MM_FROUND_NO_EXC);
}
","/* { dg-do compile } */
/* { dg-options ""-mavx512f -O2"" } */
/* { dg-final { scan-assembler-times ""vfmsub...sd\[ \\t\]+\[^\n\]*\{rn-sae\}\[^\{\n\]*%xmm\[0-9\]+(?:\n|\[ \\t\]+#)"" 1 } } */

#include <immintrin.h>

volatile __m128d a, b, c;

void extern
avx512f_test (void)
{
  a = _mm_fmsub_round_sd (a, b, c, _MM_FROUND_TO_NEAREST_INT | _MM_FROUND_NO_EXC);
}
"
"/* { dg-do compile } */
/* { dg-options ""-O2"" } */

typedef unsigned IPos;
typedef unsigned char uch;
extern uch window[];
unsigned max_chain_length;
unsigned strstart;
int longest_match(IPos cur_match, int len, int best_len)
{
    unsigned chain_length = max_chain_length;
    register uch *scan = window + strstart;
    register uch *match;
    register uch scan_end1 = scan[best_len-1];
    register uch scan_end = scan[best_len];
    do {
        ;
        match = window + cur_match;
        if (match[best_len] != scan_end ||
            match[best_len-1] != scan_end1 ||
            *match != *scan ||
            *++match != scan[1]) continue;
            best_len = len;
    } while ( --chain_length != 0);
    return best_len;
}
","/* { dg-do compile } */
/* { dg-options ""-O2"" } */

typedef unsigned IPos;
typedef unsigned char uch;
extern uch window[];
unsigned max_chain_length;
unsigned strstart;
int longest_match(IPos cur_match, int len, int best_len)
{
    unsigned chain_length = max_chain_length;
    register uch *scan = window + strstart;
    register uch *match;
    register uch scan_end1 = scan[best_len-1];
    register uch scan_end = scan[best_len];
    do {
        ;
        match = window + cur_match;
        if (match[best_len] != scan_end ||
            match[best_len-1] != scan_end1 ||
            *match != *scan ||
            *++match != scan[1]) continue;
            best_len = len;
    } while ( --chain_length != 0);
    return best_len;
}
"
"/* PR tree-optimization/45919 */

const struct S { int a; int b[]; } s = { 0, { 0 }};

int
foo (void)
{
  return s.b[0];
}
","/* PR tree-optimization/45919 */

const struct S { int a; int b[]; } s = { 0, { 0 }};

int
foo (void)
{
  return s.b[0];
}
"
"/* Make sure the vector load and zero instruction is being used for
   initializing a 32 bit vector with the first element taken from
   memory.  */

/* { dg-do run } */
/* { dg-options ""-O3 -mzarch -march=arch12 --save-temps"" } */
/* { dg-require-effective-target s390_vxe } */

typedef unsigned int       uv4si __attribute__((vector_size(16)));

uv4si __attribute__((noinline))
foo (int *a)
{
  return (uv4si){ *a, 0, 0, 0 };
}

int
main ()
{
  int b = 4;
  uv4si a = (uv4si){ 1, 2, 3, 4 };

  a = foo (&b);

  if (a[0] != 4 || a[1] != 0 || a[2] != 0 || a[3] != 0)
    __builtin_abort ();

  return 0;
}
/* { dg-final { scan-assembler-times ""vllezlf\t%v24,0\\(%r2\\)"" 1 } } */
","/* Make sure the vector load and zero instruction is being used for
   initializing a 32 bit vector with the first element taken from
   memory.  */

/* { dg-do run } */
/* { dg-options ""-O3 -mzarch -march=arch12 --save-temps"" } */
/* { dg-require-effective-target s390_vxe } */

typedef unsigned int       uv4si __attribute__((vector_size(16)));

uv4si __attribute__((noinline))
foo (int *a)
{
  return (uv4si){ *a, 0, 0, 0 };
}

int
main ()
{
  int b = 4;
  uv4si a = (uv4si){ 1, 2, 3, 4 };

  a = foo (&b);

  if (a[0] != 4 || a[1] != 0 || a[2] != 0 || a[3] != 0)
    __builtin_abort ();

  return 0;
}
/* { dg-final { scan-assembler-times ""vllezlf\t%v24,0\\(%r2\\)"" 1 } } */
"
"/* Test the vqdmlsls_lane_s32 AArch64 SIMD intrinsic.  */

/* { dg-do compile } */
/* { dg-options ""-save-temps -O3 -fno-inline"" } */

#include ""arm_neon.h""

int64_t
t_vqdmlsls_lane_s32 (int64_t a, int32_t b, int32x2_t c)
{
  return vqdmlsls_lane_s32 (a, b, c, 0);
}

/* { dg-final { scan-assembler-times ""sqdmlsl\[ \t\]+\[dD\]\[0-9\]+, ?\[sS\]\[0-9\]+, ?\[vV\]\[0-9\]+\.\[sS\]\\\[0\\\]\n"" 1 } } */
","/* Test the vqdmlsls_lane_s32 AArch64 SIMD intrinsic.  */

/* { dg-do compile } */
/* { dg-options ""-save-temps -O3 -fno-inline"" } */

#include ""arm_neon.h""

int64_t
t_vqdmlsls_lane_s32 (int64_t a, int32_t b, int32x2_t c)
{
  return vqdmlsls_lane_s32 (a, b, c, 0);
}

/* { dg-final { scan-assembler-times ""sqdmlsl\[ \t\]+\[dD\]\[0-9\]+, ?\[sS\]\[0-9\]+, ?\[vV\]\[0-9\]+\.\[sS\]\\\[0\\\]\n"" 1 } } */
"
"/* Test that creal and cimag built-in functions do not return lvalues.  */
/* Origin: Joseph Myers <jsm@polyomino.org.uk> */
/* { dg-do compile } */
/* { dg-options """" } */

extern float crealf (float _Complex);
extern double creal (double _Complex);
extern long double creall (long double _Complex);

extern float cimagf (float _Complex);
extern double cimag (double _Complex);
extern long double cimagl (long double _Complex);

float _Complex fc;
double _Complex dc;
long double _Complex ldc;

void
foo (void)
{
  crealf (fc) = 0; /* { dg-error ""lvalue"" ""crealf not lvalue"" } */
  cimagf (fc) = 0; /* { dg-error ""lvalue"" ""cimagf not lvalue"" } */
  creal (dc) = 0; /* { dg-error ""lvalue"" ""creal not lvalue"" } */
  cimag (dc) = 0; /* { dg-error ""lvalue"" ""cimag not lvalue"" } */
  creall (ldc) = 0; /* { dg-error ""lvalue"" ""creall not lvalue"" } */
  cimagl (ldc) = 0; /* { dg-error ""lvalue"" ""cimagl not lvalue"" } */
}
","/* Test that creal and cimag built-in functions do not return lvalues.  */
/* Origin: Joseph Myers <jsm@polyomino.org.uk> */
/* { dg-do compile } */
/* { dg-options """" } */

extern float crealf (float _Complex);
extern double creal (double _Complex);
extern long double creall (long double _Complex);

extern float cimagf (float _Complex);
extern double cimag (double _Complex);
extern long double cimagl (long double _Complex);

float _Complex fc;
double _Complex dc;
long double _Complex ldc;

void
foo (void)
{
  crealf (fc) = 0; /* { dg-error ""lvalue"" ""crealf not lvalue"" } */
  cimagf (fc) = 0; /* { dg-error ""lvalue"" ""cimagf not lvalue"" } */
  creal (dc) = 0; /* { dg-error ""lvalue"" ""creal not lvalue"" } */
  cimag (dc) = 0; /* { dg-error ""lvalue"" ""cimag not lvalue"" } */
  creall (ldc) = 0; /* { dg-error ""lvalue"" ""creall not lvalue"" } */
  cimagl (ldc) = 0; /* { dg-error ""lvalue"" ""cimagl not lvalue"" } */
}
"
"/* { dg-do assemble } */
/* { dg-require-effective-target 3dnow } */
/* { dg-options ""-O0 -Werror-implicit-function-declaration -march=k8 -m3dnow"" } */
/* { dg-add-options bind_pic_locally } */

/* Test that the intrinsics compile without optimization.  All of them are
   defined as inline functions in mmintrin.h that reference the proper
   builtin functions.  Defining away ""extern"" and ""__inline"" results in
   all of them being compiled as proper functions.  */

#define extern
#define __inline

#include <mm3dnow.h>
","/* { dg-do assemble } */
/* { dg-require-effective-target 3dnow } */
/* { dg-options ""-O0 -Werror-implicit-function-declaration -march=k8 -m3dnow"" } */
/* { dg-add-options bind_pic_locally } */

/* Test that the intrinsics compile without optimization.  All of them are
   defined as inline functions in mmintrin.h that reference the proper
   builtin functions.  Defining away ""extern"" and ""__inline"" results in
   all of them being compiled as proper functions.  */

#define extern
#define __inline

#include <mm3dnow.h>
"
"/* Test AAPCS layout (VFP variant) */

/* { dg-do run { target aarch64*-*-* } } */

#ifndef IN_FRAMEWORK

#define TESTFILE ""test_18.c""


struct y
{
  long long p;
  long long q;
  long long r;
  long long s;
} v = { 1, 2, 3, 4 };

struct z
{
  double x[4];
};

struct z a = { 5.0, 6.0, 7.0, 8.0 };
struct z b = { 9.0, 10.0, 11.0, 12.0 };

#include ""abitest.h""
#else
  ARG(int, 7, W0)
  PTR(struct y, v, X1)
  ARG(struct z, a, D0)
  ARG(double, 1.0, D4)
  ARG(struct z, b, STACK)
  LAST_ARG(double, 0.5, STACK+32)
#endif
","/* Test AAPCS layout (VFP variant) */

/* { dg-do run { target aarch64*-*-* } } */

#ifndef IN_FRAMEWORK

#define TESTFILE ""test_18.c""


struct y
{
  long long p;
  long long q;
  long long r;
  long long s;
} v = { 1, 2, 3, 4 };

struct z
{
  double x[4];
};

struct z a = { 5.0, 6.0, 7.0, 8.0 };
struct z b = { 9.0, 10.0, 11.0, 12.0 };

#include ""abitest.h""
#else
  ARG(int, 7, W0)
  PTR(struct y, v, X1)
  ARG(struct z, a, D0)
  ARG(double, 1.0, D4)
  ARG(struct z, b, STACK)
  LAST_ARG(double, 0.5, STACK+32)
#endif
"
"extern void abort (void);

struct S
{
  long o;
};

struct T
{
  long o;
  struct S m[82];
};

struct T t;

int
main ()
{
  struct S *p, *q;

  p = (struct S *) &t;
  p = &((struct T *) p)->m[0];
  q = p + 82;
  while (--q > p)
    q->o = -1;
  q->o = 0;

  if (q > p)
    abort ();
  if (q - p > 0)
    abort ();
  return 0;
}
","extern void abort (void);

struct S
{
  long o;
};

struct T
{
  long o;
  struct S m[82];
};

struct T t;

int
main ()
{
  struct S *p, *q;

  p = (struct S *) &t;
  p = &((struct T *) p)->m[0];
  q = p + 82;
  while (--q > p)
    q->o = -1;
  q->o = 0;

  if (q > p)
    abort ();
  if (q - p > 0)
    abort ();
  return 0;
}
"
"/* Test floating-point conversions.  __float128 type with TImode.  */
/* Origin: Joseph Myers <joseph@codesourcery.com> */
/* { dg-do run } */
/* { dg-require-effective-target __float128 } */
/* { dg-require-effective-target base_quadfloat_support } */
/* { dg-options """" } */
/* { dg-add-options __float128 } */

#include ""fp-int-convert.h""

#define FLOAT128_MANT_DIG 113
#define FLOAT128_MAX_EXP 16384

int
main (void)
{
  TEST_I_F(TItype, UTItype, __float128, FLOAT128_MANT_DIG, FLOAT128_MAX_EXP);
  exit (0);
}
","/* Test floating-point conversions.  __float128 type with TImode.  */
/* Origin: Joseph Myers <joseph@codesourcery.com> */
/* { dg-do run } */
/* { dg-require-effective-target __float128 } */
/* { dg-require-effective-target base_quadfloat_support } */
/* { dg-options """" } */
/* { dg-add-options __float128 } */

#include ""fp-int-convert.h""

#define FLOAT128_MANT_DIG 113
#define FLOAT128_MAX_EXP 16384

int
main (void)
{
  TEST_I_F(TItype, UTItype, __float128, FLOAT128_MANT_DIG, FLOAT128_MAX_EXP);
  exit (0);
}
"
"/* Nested functions shouldn't produce warnings if defined before first use.
   Bug 36774. Test with -Wmissing-prototypes. */
/* { dg-do compile } */
/* { dg-options ""-Wmissing-prototypes"" } */

int foo(int a) { /* { dg-warning ""no previous prototype"" } */
    int bar(int b) { return b; } /* { dg-bogus ""no previous prototype"" } */
    return bar(a);
}
","/* Nested functions shouldn't produce warnings if defined before first use.
   Bug 36774. Test with -Wmissing-prototypes. */
/* { dg-do compile } */
/* { dg-options ""-Wmissing-prototypes"" } */

int foo(int a) { /* { dg-warning ""no previous prototype"" } */
    int bar(int b) { return b; } /* { dg-bogus ""no previous prototype"" } */
    return bar(a);
}
"
"/* { dg-do compile { target lp64 } } */
/* { dg-options ""-O2"" } */

/* { dg-final { scan-assembler-times {(?n)^\s+[a-z]} 3628 } } */
/* { dg-final { scan-assembler-times {(?n)^\s+blr} 1800 } } */
/* { dg-final { scan-assembler-times {(?n)^\s+mr} 30 } } */

/* { dg-final { scan-assembler-times {(?n)^\s+rldimi} 58 } } */

/* { dg-final { scan-assembler-times {(?n)^\s+mulli} 1740 } } */


#define SR

#include ""rldimi.h""
","/* { dg-do compile { target lp64 } } */
/* { dg-options ""-O2"" } */

/* { dg-final { scan-assembler-times {(?n)^\s+[a-z]} 3628 } } */
/* { dg-final { scan-assembler-times {(?n)^\s+blr} 1800 } } */
/* { dg-final { scan-assembler-times {(?n)^\s+mr} 30 } } */

/* { dg-final { scan-assembler-times {(?n)^\s+rldimi} 58 } } */

/* { dg-final { scan-assembler-times {(?n)^\s+mulli} 1740 } } */


#define SR

#include ""rldimi.h""
"
"/* PR c/28502 */
/* { dg-do compile } */

void foo() {}      /* { dg-message ""note: previous"" } */
void foo(void[]);  /* { dg-error ""array of voids"" } */
","/* PR c/28502 */
/* { dg-do compile } */

void foo() {}      /* { dg-message ""note: previous"" } */
void foo(void[]);  /* { dg-error ""array of voids"" } */
"
"static int      gl_cnt = 0;
static char     gl_buf[1024];

void
gl_yank()
{
  int  i;

  for (i=gl_cnt; i >= 0; i--)
    gl_buf[i+10] = gl_buf[i];
}
","static int      gl_cnt = 0;
static char     gl_buf[1024];

void
gl_yank()
{
  int  i;

  for (i=gl_cnt; i >= 0; i--)
    gl_buf[i+10] = gl_buf[i];
}
"
"/* { dg-do run } */
/* { dg-options ""-O2 -mavx512f"" } */
/* { dg-require-effective-target avx512f } */

#define AVX512F

#include ""avx512f-helper.h""

#define SIZE (AVX512F_LEN / 32)
#include ""avx512f-mask-type.h""

static void
CALC (MASK_TYPE *res, int *src1, int *src2)
{
  int i;
  *res = 0;
  MASK_TYPE one = 1;

  for (i = 0; i < SIZE; i++)
    if (src1[i] & src2[i])
      *res = *res | one << i;
}

void
TEST (void)
{
  int i, sign = 1;
  UNION_TYPE (AVX512F_LEN, i_d) src1, src2;
  MASK_TYPE res_ref, res1, res2;
  MASK_TYPE mask = MASK_VALUE;

  for (i = 0; i < SIZE; i++)
    {
      src1.a[i] = i * i * sign;
      src2.a[i] = i + 20;
      sign = -sign;
    }

  res1 = INTRINSIC (_test_epi32_mask) (src1.x, src2.x);
  res2 = INTRINSIC (_mask_test_epi32_mask) (mask, src1.x, src2.x);

  CALC (&res_ref, src1.a, src2.a);

  if (res1 != res_ref)
    abort ();

  res_ref &= mask;

  if (res2 != res_ref)
    abort ();
}
","/* { dg-do run } */
/* { dg-options ""-O2 -mavx512f"" } */
/* { dg-require-effective-target avx512f } */

#define AVX512F

#include ""avx512f-helper.h""

#define SIZE (AVX512F_LEN / 32)
#include ""avx512f-mask-type.h""

static void
CALC (MASK_TYPE *res, int *src1, int *src2)
{
  int i;
  *res = 0;
  MASK_TYPE one = 1;

  for (i = 0; i < SIZE; i++)
    if (src1[i] & src2[i])
      *res = *res | one << i;
}

void
TEST (void)
{
  int i, sign = 1;
  UNION_TYPE (AVX512F_LEN, i_d) src1, src2;
  MASK_TYPE res_ref, res1, res2;
  MASK_TYPE mask = MASK_VALUE;

  for (i = 0; i < SIZE; i++)
    {
      src1.a[i] = i * i * sign;
      src2.a[i] = i + 20;
      sign = -sign;
    }

  res1 = INTRINSIC (_test_epi32_mask) (src1.x, src2.x);
  res2 = INTRINSIC (_mask_test_epi32_mask) (mask, src1.x, src2.x);

  CALC (&res_ref, src1.a, src2.a);

  if (res1 != res_ref)
    abort ();

  res_ref &= mask;

  if (res2 != res_ref)
    abort ();
}
"
"/* { dg-do run } */
/* { dg-options ""-O2 -mavx512bw -mavx512vl"" } */
/* { dg-require-effective-target avx512vl } */
/* { dg-require-effective-target avx512bw } */

#define AVX512VL
#define AVX512F_LEN 256
#define AVX512F_LEN_HALF 128
#include ""avx512bw-vpcmpgtw-2.c""

#undef AVX512F_LEN
#undef AVX512F_LEN_HALF

#define AVX512F_LEN 128
#define AVX512F_LEN_HALF 128
#include ""avx512bw-vpcmpgtw-2.c""
","/* { dg-do run } */
/* { dg-options ""-O2 -mavx512bw -mavx512vl"" } */
/* { dg-require-effective-target avx512vl } */
/* { dg-require-effective-target avx512bw } */

#define AVX512VL
#define AVX512F_LEN 256
#define AVX512F_LEN_HALF 128
#include ""avx512bw-vpcmpgtw-2.c""

#undef AVX512F_LEN
#undef AVX512F_LEN_HALF

#define AVX512F_LEN 128
#define AVX512F_LEN_HALF 128
#include ""avx512bw-vpcmpgtw-2.c""
"
"/* { dg-do run } */
/* { dg-options ""-O3 -mavx2"" } */
/* { dg-require-effective-target avx2 } */

#ifndef CHECK_H
#define CHECK_H ""avx2-check.h""
#endif

#ifndef TEST
#define TEST avx2_test
#endif

#include ""xop-vshift-1.c""
","/* { dg-do run } */
/* { dg-options ""-O3 -mavx2"" } */
/* { dg-require-effective-target avx2 } */

#ifndef CHECK_H
#define CHECK_H ""avx2-check.h""
#endif

#ifndef TEST
#define TEST avx2_test
#endif

#include ""xop-vshift-1.c""
"
"/* The structure is too large for the xstormy16 - won't fit in 16
   bits.  */
/* { dg-do assemble } */
/* { dg-skip-if ""Array too big"" { ""pdp11-*-*"" } { ""-mint32"" } } */

#if __INT_MAX__ >= 2147483647L
struct s {
  char a[0x32100000];
  int x:30, y:30;
};

int
main ()
{
  struct s* p;

  p = (struct s*) 0;
  if (p->x == p->y)
    exit (1);
}
#else
int g;
#endif
","/* The structure is too large for the xstormy16 - won't fit in 16
   bits.  */
/* { dg-do assemble } */
/* { dg-skip-if ""Array too big"" { ""pdp11-*-*"" } { ""-mint32"" } } */

#if __INT_MAX__ >= 2147483647L
struct s {
  char a[0x32100000];
  int x:30, y:30;
};

int
main ()
{
  struct s* p;

  p = (struct s*) 0;
  if (p->x == p->y)
    exit (1);
}
#else
int g;
#endif
"
"/* { dg-do run { target aarch64_sve_hw } } */
/* { dg-options ""-O2 -ftree-vectorize -fno-vect-cost-model --save-temps"" } */

#include ""div_1.c""

#define N 79

#define TEST_LOOP(TYPE)				\
  {						\
    TYPE dst[N], src1[N], src2[N];		\
    for (int i = 0; i < N; ++i)			\
      {						\
	src1[i] = i * 7 + i % 3;		\
	if (i % 11 > 7)				\
	  src1[i] = -src1[i];			\
	src2[i] = 5 + (i % 5);			\
	asm volatile ("""" ::: ""memory"");		\
      }						\
    mod_##TYPE (dst, src1, src2, N);		\
    for (int i = 0; i < N; ++i)			\
      if (dst[i] != src1[i] / src2[i])		\
	__builtin_abort ();			\
  }

int
main (void)
{
  TEST_ALL (TEST_LOOP);
  return 0;
}
","/* { dg-do run { target aarch64_sve_hw } } */
/* { dg-options ""-O2 -ftree-vectorize -fno-vect-cost-model --save-temps"" } */

#include ""div_1.c""

#define N 79

#define TEST_LOOP(TYPE)				\
  {						\
    TYPE dst[N], src1[N], src2[N];		\
    for (int i = 0; i < N; ++i)			\
      {						\
	src1[i] = i * 7 + i % 3;		\
	if (i % 11 > 7)				\
	  src1[i] = -src1[i];			\
	src2[i] = 5 + (i % 5);			\
	asm volatile ("""" ::: ""memory"");		\
      }						\
    mod_##TYPE (dst, src1, src2, N);		\
    for (int i = 0; i < N; ++i)			\
      if (dst[i] != src1[i] / src2[i])		\
	__builtin_abort ();			\
  }

int
main (void)
{
  TEST_ALL (TEST_LOOP);
  return 0;
}
"
"/* PR target/82361 */
/* { dg-do compile { target lp64 } } */
/* { dg-options ""-O2 -mtune=generic -masm=att -m8bit-idiv"" } */
/* We should be able to optimize all %eax to %rax zero extensions, because
   div and idiv instructions with 32-bit operands zero-extend both results.   */
/* { dg-final { scan-assembler-not ""movl\t%eax, %eax"" } } */
/* Ditto %edx to %rdx zero extensions.  */
/* { dg-final { scan-assembler-not ""movl\t%edx, %edx"" } } */

#include ""pr82361-1.c""
","/* PR target/82361 */
/* { dg-do compile { target lp64 } } */
/* { dg-options ""-O2 -mtune=generic -masm=att -m8bit-idiv"" } */
/* We should be able to optimize all %eax to %rax zero extensions, because
   div and idiv instructions with 32-bit operands zero-extend both results.   */
/* { dg-final { scan-assembler-not ""movl\t%eax, %eax"" } } */
/* Ditto %edx to %rdx zero extensions.  */
/* { dg-final { scan-assembler-not ""movl\t%edx, %edx"" } } */

#include ""pr82361-1.c""
"
"/* { dg-options ""-mr10k-cache-barrier=store -mno-abicalls"" } */

/* Test that in-range stores to the frame are not protected by
   cache barriers.  */

void bar (int *x);

NOMIPS16 void
foo (int v)
{
  int x[0x100000];
  bar (x);
  x[0x20] = v;
  bar (x);
}

/* { dg-final { scan-assembler-not ""\tcache\t"" } } */
","/* { dg-options ""-mr10k-cache-barrier=store -mno-abicalls"" } */

/* Test that in-range stores to the frame are not protected by
   cache barriers.  */

void bar (int *x);

NOMIPS16 void
foo (int v)
{
  int x[0x100000];
  bar (x);
  x[0x20] = v;
  bar (x);
}

/* { dg-final { scan-assembler-not ""\tcache\t"" } } */
"
"/* { dg-do run } */
/* { dg-require-effective-target arm_v8_2a_fp16_scalar_hw } */
/* { dg-add-options arm_v8_2a_fp16_scalar }  */

#include <arm_fp16.h>

uint16_t expected[] =
{
  0x8000 /* -0.000000 */,
  0x0000 /* 0.000000 */,
  0xc000 /* -2.000000 */,
  0xc233 /* -3.099609 */,
  0xcd00 /* -20.000000 */,
  0xb666 /* -0.399902 */,
  0x409a /* 2.300781 */,
  0xbd52 /* -1.330078 */,
  0x479a /* 7.601562 */,
  0xb4f6 /* -0.310059 */,
  0xb55d /* -0.335205 */,
  0xb800 /* -0.500000 */,
  0xbc00 /* -1.000000 */,
  0xca91 /* -13.132812 */,
  0x464d /* 6.300781 */,
  0xcd00 /* -20.000000 */,
  0xfc00 /* -inf */,
  0x7c00 /* inf */
};

#define TEST_MSG ""VNEGH_F16""
#define INSN_NAME vnegh_f16

#define EXPECTED expected

#define INPUT_TYPE float16_t
#define OUTPUT_TYPE float16_t
#define OUTPUT_TYPE_SIZE 16

/* Include the template for unary scalar operations.  */
#include ""unary_scalar_op.inc""
","/* { dg-do run } */
/* { dg-require-effective-target arm_v8_2a_fp16_scalar_hw } */
/* { dg-add-options arm_v8_2a_fp16_scalar }  */

#include <arm_fp16.h>

uint16_t expected[] =
{
  0x8000 /* -0.000000 */,
  0x0000 /* 0.000000 */,
  0xc000 /* -2.000000 */,
  0xc233 /* -3.099609 */,
  0xcd00 /* -20.000000 */,
  0xb666 /* -0.399902 */,
  0x409a /* 2.300781 */,
  0xbd52 /* -1.330078 */,
  0x479a /* 7.601562 */,
  0xb4f6 /* -0.310059 */,
  0xb55d /* -0.335205 */,
  0xb800 /* -0.500000 */,
  0xbc00 /* -1.000000 */,
  0xca91 /* -13.132812 */,
  0x464d /* 6.300781 */,
  0xcd00 /* -20.000000 */,
  0xfc00 /* -inf */,
  0x7c00 /* inf */
};

#define TEST_MSG ""VNEGH_F16""
#define INSN_NAME vnegh_f16

#define EXPECTED expected

#define INPUT_TYPE float16_t
#define OUTPUT_TYPE float16_t
#define OUTPUT_TYPE_SIZE 16

/* Include the template for unary scalar operations.  */
#include ""unary_scalar_op.inc""
"
"void foo(double bar[], double *zp, int n)
{
   int i, j;

   i = 0;
   for(j = 0; j < n; j++)
   {
      i += j+1;
      bar[i] *= (1.0 + *zp);
   }
}
","void foo(double bar[], double *zp, int n)
{
   int i, j;

   i = 0;
   for(j = 0; j < n; j++)
   {
      i += j+1;
      bar[i] *= (1.0 + *zp);
   }
}
"
"void byte_insert_op1 (unsigned char *loc, unsigned char *end)
{
  register unsigned char *pto = end + 1 + 2;
  while (end != loc)
    *--pto = *--end;
}
","void byte_insert_op1 (unsigned char *loc, unsigned char *end)
{
  register unsigned char *pto = end + 1 + 2;
  while (end != loc)
    *--pto = *--end;
}
"
"/* { dg-do compile { target { powerpc64le-*-* } } } */
/* { dg-skip-if ""do not override -mcpu"" { powerpc*-*-* } { ""-mcpu=*"" } { ""-mcpu=power8"" } } */
/* { dg-options ""-mcpu=power8 -O3"" } */
/* { dg-final { scan-assembler ""lxvd2x"" } } */
/* { dg-final { scan-assembler ""stxvd2x"" } } */
/* { dg-final { scan-assembler-not ""xxpermdi"" } } */

void abort ();

#define N 256
signed char ca[N] __attribute__((aligned(16)));
signed char cb[N] __attribute__((aligned(16)));
signed char cc[N] __attribute__((aligned(16)));

__attribute__((noinline)) void foo ()
{
  int i;
  for (i = 0; i < N; i++) {
    ca[i] = cb[i] - cc[i];
  }
}

__attribute__((noinline)) void init ()
{
  int i;
  for (i = 0; i < N; ++i) {
    cb[i] = i - 128;
    cc[i] = i/2 - 64;
  }
}

int main ()
{
  int i;
  init ();
  foo ();
  for (i = 0; i < N; ++i)
    if (ca[i] != i - i/2 - 64)
      abort ();
  return 0;
}
","/* { dg-do compile { target { powerpc64le-*-* } } } */
/* { dg-skip-if ""do not override -mcpu"" { powerpc*-*-* } { ""-mcpu=*"" } { ""-mcpu=power8"" } } */
/* { dg-options ""-mcpu=power8 -O3"" } */
/* { dg-final { scan-assembler ""lxvd2x"" } } */
/* { dg-final { scan-assembler ""stxvd2x"" } } */
/* { dg-final { scan-assembler-not ""xxpermdi"" } } */

void abort ();

#define N 256
signed char ca[N] __attribute__((aligned(16)));
signed char cb[N] __attribute__((aligned(16)));
signed char cc[N] __attribute__((aligned(16)));

__attribute__((noinline)) void foo ()
{
  int i;
  for (i = 0; i < N; i++) {
    ca[i] = cb[i] - cc[i];
  }
}

__attribute__((noinline)) void init ()
{
  int i;
  for (i = 0; i < N; ++i) {
    cb[i] = i - 128;
    cc[i] = i/2 - 64;
  }
}

int main ()
{
  int i;
  init ();
  foo ();
  for (i = 0; i < N; ++i)
    if (ca[i] != i - i/2 - 64)
      abort ();
  return 0;
}
"
"/* Test compatibility of vector types: layout between separately-compiled
   modules, parameter passing, and function return.  This test uses
   vectors of floating points values.  */

extern void vector_2_x (void);
extern void exit (int);
int fails;

int
main ()
{
  vector_2_x ();
  exit (0);
}
","/* Test compatibility of vector types: layout between separately-compiled
   modules, parameter passing, and function return.  This test uses
   vectors of floating points values.  */

extern void vector_2_x (void);
extern void exit (int);
int fails;

int
main ()
{
  vector_2_x ();
  exit (0);
}
"
"/* { dg-do compile } */
/* { dg-options ""-O2 -fstack-clash-protection -mtune=generic -fomit-frame-pointer"" } */
/* { dg-require-effective-target supports_stack_clash_protection } */

__attribute__ ((noreturn)) void exit (int);

__attribute__ ((noreturn)) void
f (void)
{
  exit (1);
}

/* { dg-final { scan-assembler-not ""or\[ql\]"" } } */
/* { dg-final { scan-assembler ""pushl	%esi"" { target ia32 } } } */
/* { dg-final { scan-assembler ""popl	%esi"" { target ia32 } } }*/
/* { dg-final { scan-assembler ""pushq	%rax"" { target { ! ia32 } } } } */
/* { dg-final { scan-assembler ""popq	%rax"" { target { ! ia32 } } } }*/

","/* { dg-do compile } */
/* { dg-options ""-O2 -fstack-clash-protection -mtune=generic -fomit-frame-pointer"" } */
/* { dg-require-effective-target supports_stack_clash_protection } */

__attribute__ ((noreturn)) void exit (int);

__attribute__ ((noreturn)) void
f (void)
{
  exit (1);
}

/* { dg-final { scan-assembler-not ""or\[ql\]"" } } */
/* { dg-final { scan-assembler ""pushl	%esi"" { target ia32 } } } */
/* { dg-final { scan-assembler ""popl	%esi"" { target ia32 } } }*/
/* { dg-final { scan-assembler ""pushq	%rax"" { target { ! ia32 } } } } */
/* { dg-final { scan-assembler ""popq	%rax"" { target { ! ia32 } } } }*/

"
"/* { dg-do compile } */
/* { dg-options ""-fdump-tree-gimple -fwrapv"" } */
int g(int x)
{
   return (x - 10) < 0;
}
/* There should be no x >= 9 and one x - 10. */
/* { dg-final { scan-tree-dump-times ""<= 9"" 0 ""gimple""} } */
/* { dg-final { scan-tree-dump-times ""\\+ -10"" 1 ""gimple""} } */
","/* { dg-do compile } */
/* { dg-options ""-fdump-tree-gimple -fwrapv"" } */
int g(int x)
{
   return (x - 10) < 0;
}
/* There should be no x >= 9 and one x - 10. */
/* { dg-final { scan-tree-dump-times ""<= 9"" 0 ""gimple""} } */
/* { dg-final { scan-tree-dump-times ""\\+ -10"" 1 ""gimple""} } */
"
"/* Use 16-bit multiply instruction in Thumb-2 mode when optimizing for
   size.  */
/* { dg-options ""-mthumb -Os"" }  */
/* { dg-require-effective-target arm_thumb2_ok } */
/* { dg-final { scan-assembler ""muls"" } } */

int f(int i, int j) 
{
  return i * j;
}
","/* Use 16-bit multiply instruction in Thumb-2 mode when optimizing for
   size.  */
/* { dg-options ""-mthumb -Os"" }  */
/* { dg-require-effective-target arm_thumb2_ok } */
/* { dg-final { scan-assembler ""muls"" } } */

int f(int i, int j) 
{
  return i * j;
}
"
"/* { dg-do run } */
/* { dg-options ""-O3 -mpower8-vector"" } */
/* { dg-require-effective-target lp64 } */
/* { dg-require-effective-target p8vector_hw } */

#define NO_WARN_X86_INTRINSICS 1

#ifndef CHECK_H
#define CHECK_H ""sse-check.h""
#endif

#include CHECK_H

#ifndef TEST
#define TEST sse_test_ucomiss_2
#endif

#include <xmmintrin.h>

static int 
__attribute__((noinline, unused))
test (__m128 s1, __m128 s2)
{
  return _mm_ucomilt_ss (s1, s2); 
}

static void
TEST (void)
{
  union128  s1, s2;
  int d[1];
  int e[1];

  s1.x = _mm_set_ps (24.43, 68.346, 43.35, 546.46);
  s2.x = _mm_set_ps (1.17, 2.16, 3.15, 4.14);
  d[0] = test (s1.x, s2.x); 
  e[0] = s1.a[0] < s2.a[0];

  if (checkVi (d, e, 1))
    abort ();
}
","/* { dg-do run } */
/* { dg-options ""-O3 -mpower8-vector"" } */
/* { dg-require-effective-target lp64 } */
/* { dg-require-effective-target p8vector_hw } */

#define NO_WARN_X86_INTRINSICS 1

#ifndef CHECK_H
#define CHECK_H ""sse-check.h""
#endif

#include CHECK_H

#ifndef TEST
#define TEST sse_test_ucomiss_2
#endif

#include <xmmintrin.h>

static int 
__attribute__((noinline, unused))
test (__m128 s1, __m128 s2)
{
  return _mm_ucomilt_ss (s1, s2); 
}

static void
TEST (void)
{
  union128  s1, s2;
  int d[1];
  int e[1];

  s1.x = _mm_set_ps (24.43, 68.346, 43.35, 546.46);
  s2.x = _mm_set_ps (1.17, 2.16, 3.15, 4.14);
  d[0] = test (s1.x, s2.x); 
  e[0] = s1.a[0] < s2.a[0];

  if (checkVi (d, e, 1))
    abort ();
}
"
"/* { dg-options ""-fdump-tree-sanopt"" } */
/* { dg-do compile } */
/* { dg-skip-if """" { *-*-* } { ""*"" } { ""-O0"" } } */

extern __UINT32_TYPE__ a;

void
foo ()
{
  /* Instrument a with access size 3.  */
  int d = __builtin_memcmp (&a, ""123"", 3);
  /* This should  generate a __builtin___asan_report_store4, because
     the reference to a has been instrumented above with access size 3.  */
  a = 1;
}

/* { dg-final { scan-tree-dump-times ""__builtin___asan_report_store4"" 1 ""sanopt"" } } */
","/* { dg-options ""-fdump-tree-sanopt"" } */
/* { dg-do compile } */
/* { dg-skip-if """" { *-*-* } { ""*"" } { ""-O0"" } } */

extern __UINT32_TYPE__ a;

void
foo ()
{
  /* Instrument a with access size 3.  */
  int d = __builtin_memcmp (&a, ""123"", 3);
  /* This should  generate a __builtin___asan_report_store4, because
     the reference to a has been instrumented above with access size 3.  */
  a = 1;
}

/* { dg-final { scan-tree-dump-times ""__builtin___asan_report_store4"" 1 ""sanopt"" } } */
"
"static inline int bar(void) { return 1; }
static int mem[3];

static int foo(int x)
{
  if (x != 0)
    return x;

  mem[x++] = foo(bar());

  if (x != 1)
    abort();

  return 0;
}

int main()
{
  foo(0);
  return 0;
}
","static inline int bar(void) { return 1; }
static int mem[3];

static int foo(int x)
{
  if (x != 0)
    return x;

  mem[x++] = foo(bar());

  if (x != 1)
    abort();

  return 0;
}

int main()
{
  foo(0);
  return 0;
}
"
"/* PR rtl-optimization/87065 */
/* { dg-do compile } */
/* { dg-options ""-O3 -mxop -mprefer-vector-width=128"" } */

int a, c, d, e;
short *b;

void
foo (void)
{
  short *g = b;
  int h = 1;
  unsigned i;
  for (; h <= 1; h++)
    g = (short *) &c;
  for (; c; c++)
    {
      for (; i <= 1; i++)
	;
      a ^= (a > 0 <= i) + ((e += d) == 0 ?: (*g = 8));
    }
}
","/* PR rtl-optimization/87065 */
/* { dg-do compile } */
/* { dg-options ""-O3 -mxop -mprefer-vector-width=128"" } */

int a, c, d, e;
short *b;

void
foo (void)
{
  short *g = b;
  int h = 1;
  unsigned i;
  for (; h <= 1; h++)
    g = (short *) &c;
  for (; c; c++)
    {
      for (; i <= 1; i++)
	;
      a ^= (a > 0 <= i) + ((e += d) == 0 ?: (*g = 8));
    }
}
"
"/* PR c++/57945 */
/* { dg-do compile } */

extern int j;
static int i __attribute__((weakref(""j"")));
/* { dg-error ""PTX does not support weak declarations"" """" { target nvptx-*-* } .-1 } */

int
foo (void)
{
  return &i ? i : 0;
}
","/* PR c++/57945 */
/* { dg-do compile } */

extern int j;
static int i __attribute__((weakref(""j"")));
/* { dg-error ""PTX does not support weak declarations"" """" { target nvptx-*-* } .-1 } */

int
foo (void)
{
  return &i ? i : 0;
}
"
"/* { dg-do compile } */
/* { dg-options ""-O0"" } */
/* { dg-final { scan-assembler     ""ashq .*,\\\$0xffffffffffffffff,"" } } */
/* { dg-final { scan-assembler-not ""ashq .*,\\\$-1,"" } } */

void
a (void)
{
	unsigned long i = 1;
	unsigned long long v;

	v = ~ (unsigned long long) 0 << i;
}
","/* { dg-do compile } */
/* { dg-options ""-O0"" } */
/* { dg-final { scan-assembler     ""ashq .*,\\\$0xffffffffffffffff,"" } } */
/* { dg-final { scan-assembler-not ""ashq .*,\\\$-1,"" } } */

void
a (void)
{
	unsigned long i = 1;
	unsigned long long v;

	v = ~ (unsigned long long) 0 << i;
}
"
"/* Verify that we get errors for trying to put TLS data in 
   sections which can't work.  */
/* { dg-require-effective-target tls_native } */

#define A(X)	__attribute__((section(X)))

__thread int i A(""foo"");		/* Ok */

__thread int j A("".data"");  /* { dg-error ""causes a section type conflict"" ""conflict with .data section"" { xfail *-*-* } } */

int k A(""bar"");
__thread int l A(""bar"");  /* { dg-error ""causes a section type conflict"" ""conflict with user-defined section"" } */
","/* Verify that we get errors for trying to put TLS data in 
   sections which can't work.  */
/* { dg-require-effective-target tls_native } */

#define A(X)	__attribute__((section(X)))

__thread int i A(""foo"");		/* Ok */

__thread int j A("".data"");  /* { dg-error ""causes a section type conflict"" ""conflict with .data section"" { xfail *-*-* } } */

int k A(""bar"");
__thread int l A(""bar"");  /* { dg-error ""causes a section type conflict"" ""conflict with user-defined section"" } */
"
"/* { dg-do compile } */
/* { dg-options ""-O -fno-tree-ccp -fno-tree-forwprop -fdump-tree-fre1"" } */

static const int a[4] = {};
int foo(void)
{
  int i = 1;
  const int *p = &a[i];
  return *p;
}

/* { dg-final { scan-tree-dump ""return 0;"" ""fre1"" } } */
","/* { dg-do compile } */
/* { dg-options ""-O -fno-tree-ccp -fno-tree-forwprop -fdump-tree-fre1"" } */

static const int a[4] = {};
int foo(void)
{
  int i = 1;
  const int *p = &a[i];
  return *p;
}

/* { dg-final { scan-tree-dump ""return 0;"" ""fre1"" } } */
"
"/* PR ipa/59722 */
/* { dg-do compile } */
/* { dg-options ""-O2 -fcompare-debug"" } */

extern void abrt (const char *, int) __attribute__((noreturn));
void baz (int *, int *);

static inline int
bar (void)
{
  return 1;
}

static inline void
foo (int *x, int y (void))
{
  while (1)
    {
      int a = 0;
      if (*x)
	{
	  baz (x, &a);
	  while (a && !y ())
	    ;
	  break;
	}
      abrt ("""", 1);
    }
}

void
test (int x)
{
  foo (&x, bar);
  foo (&x, bar);
}
","/* PR ipa/59722 */
/* { dg-do compile } */
/* { dg-options ""-O2 -fcompare-debug"" } */

extern void abrt (const char *, int) __attribute__((noreturn));
void baz (int *, int *);

static inline int
bar (void)
{
  return 1;
}

static inline void
foo (int *x, int y (void))
{
  while (1)
    {
      int a = 0;
      if (*x)
	{
	  baz (x, &a);
	  while (a && !y ())
	    ;
	  break;
	}
      abrt ("""", 1);
    }
}

void
test (int x)
{
  foo (&x, bar);
  foo (&x, bar);
}
"
"/* { dg-do compile } */
/* { dg-options ""-O2 -fno-sched-critical-path-heuristic -fno-sched-rank-heuristic --param=max-sched-extend-regions-iters=5 --param sched-pressure-algorithm=2"" } */

#ifdef __SIZEOF_INT128__
typedef __int128 largeint;
#else
typedef long long largeint;
#endif

largeint a;
int b;

largeint
foo (char d, short e, int f)
{
  b = __builtin_sub_overflow_p (b, 1, (unsigned long)0);
  return a + f;
}
","/* { dg-do compile } */
/* { dg-options ""-O2 -fno-sched-critical-path-heuristic -fno-sched-rank-heuristic --param=max-sched-extend-regions-iters=5 --param sched-pressure-algorithm=2"" } */

#ifdef __SIZEOF_INT128__
typedef __int128 largeint;
#else
typedef long long largeint;
#endif

largeint a;
int b;

largeint
foo (char d, short e, int f)
{
  b = __builtin_sub_overflow_p (b, 1, (unsigned long)0);
  return a + f;
}
"
"/* PR rtl-optimization/85376 */
/* { dg-do run { target int128 } } */
/* { dg-options ""-Og -fno-dce -fgcse -fno-tree-ccp -fno-tree-copy-prop -Wno-psabi"" } */

typedef unsigned int U __attribute__ ((vector_size (64)));
typedef unsigned __int128 V __attribute__ ((vector_size (64)));
unsigned int e, i, l;
unsigned char f;
U g, h, k, j;

static inline V
foo (unsigned char n, unsigned short o, unsigned int p, U q, U r, U s)
{
  unsigned int t;
  o <<= 5;
  q[7] >>= __builtin_add_overflow (0xfffffff0, __builtin_ffs (n), &s[5]);
  t = __builtin_ffs (g[7]);
  e *= __builtin_sub_overflow (o, t, &f);
  return f + (V) g + (V) h + (V) q + i + (V) j + (V) s + (V) k + l;
}

int
main ()
{
  if (__SIZEOF_INT128__ != 16 || __SIZEOF_INT__ != 4 || __CHAR_BIT__ != 8)
    return 0;
  V x = foo (0, 1, 5, (U) { }, (U) { }, (U) { });
  for (unsigned i = 0; i < 4; i++)
    if ((unsigned int) x[i] != 0x20)
      __builtin_abort ();
  return 0;
}
","/* PR rtl-optimization/85376 */
/* { dg-do run { target int128 } } */
/* { dg-options ""-Og -fno-dce -fgcse -fno-tree-ccp -fno-tree-copy-prop -Wno-psabi"" } */

typedef unsigned int U __attribute__ ((vector_size (64)));
typedef unsigned __int128 V __attribute__ ((vector_size (64)));
unsigned int e, i, l;
unsigned char f;
U g, h, k, j;

static inline V
foo (unsigned char n, unsigned short o, unsigned int p, U q, U r, U s)
{
  unsigned int t;
  o <<= 5;
  q[7] >>= __builtin_add_overflow (0xfffffff0, __builtin_ffs (n), &s[5]);
  t = __builtin_ffs (g[7]);
  e *= __builtin_sub_overflow (o, t, &f);
  return f + (V) g + (V) h + (V) q + i + (V) j + (V) s + (V) k + l;
}

int
main ()
{
  if (__SIZEOF_INT128__ != 16 || __SIZEOF_INT__ != 4 || __CHAR_BIT__ != 8)
    return 0;
  V x = foo (0, 1, 5, (U) { }, (U) { }, (U) { });
  for (unsigned i = 0; i < 4; i++)
    if ((unsigned int) x[i] != 0x20)
      __builtin_abort ();
  return 0;
}
"
"/* { dg-do compile } */
/* { dg-options ""-O2 -fgraphite-identity -fno-tree-copy-prop --param lim-expensive=3"" } */

unsigned int dj;

void
np (void)
{
  const unsigned int uw = 2;
  unsigned int eu;

  for (eu = 0; eu < uw; ++eu)
    {
      for (dj = 0; dj < uw; ++dj)
	;
      eu -= !!(dj - uw - 1);
    }
}
","/* { dg-do compile } */
/* { dg-options ""-O2 -fgraphite-identity -fno-tree-copy-prop --param lim-expensive=3"" } */

unsigned int dj;

void
np (void)
{
  const unsigned int uw = 2;
  unsigned int eu;

  for (eu = 0; eu < uw; ++eu)
    {
      for (dj = 0; dj < uw; ++dj)
	;
      eu -= !!(dj - uw - 1);
    }
}
"
"/* PR target/29978 */
/* { dg-do compile } */
/* { dg-options ""-Os"" } */

void g ();

void
f (long long v)
{
  if (v > 0xfffffffffLL)
    g ();
  g ();
}

/* Verify there are no redundant jumps jl .L2; jle .L2 */
/* { dg-final { scan-assembler-not ""jl\[^e\]*\\.L"" { target ia32 } } } */
","/* PR target/29978 */
/* { dg-do compile } */
/* { dg-options ""-Os"" } */

void g ();

void
f (long long v)
{
  if (v > 0xfffffffffLL)
    g ();
  g ();
}

/* Verify there are no redundant jumps jl .L2; jle .L2 */
/* { dg-final { scan-assembler-not ""jl\[^e\]*\\.L"" { target ia32 } } } */
"
"/* { dg-do compile } */

int a, b, c, d, e;
void
fn1 ()
{
  int f, g;
  char h = 0;
  b = 0;
  for (; b < 32; b++)
    {
      g = h > e ? h : h << 1;
      f = g && a ? 0 : 1;
      h = 1;
      for (; h > 0; h = h + 1)
	c = 0 < h | f;
    }
  if (h)
    d = 0;
}
","/* { dg-do compile } */

int a, b, c, d, e;
void
fn1 ()
{
  int f, g;
  char h = 0;
  b = 0;
  for (; b < 32; b++)
    {
      g = h > e ? h : h << 1;
      f = g && a ? 0 : 1;
      h = 1;
      for (; h > 0; h = h + 1)
	c = 0 < h | f;
    }
  if (h)
    d = 0;
}
"
"/* Test TREE_CONSTANT VLA size: bug 27893.  */
/* Origin: Joseph Myers <joseph@codesourcery.com> */
/* { dg-require-effective-target alloca } */
int a;
void g(void *);
void f(void) { int b[(__SIZE_TYPE__)&a]; g(b); }
","/* Test TREE_CONSTANT VLA size: bug 27893.  */
/* Origin: Joseph Myers <joseph@codesourcery.com> */
/* { dg-require-effective-target alloca } */
int a;
void g(void *);
void f(void) { int b[(__SIZE_TYPE__)&a]; g(b); }
"
"/* { dg-do compile } */
/* { dg-options ""-O3 -ffast-math -fdump-tree-optimized"" } */

double baz (double x, double y, double z)
{
  return x * x * y * y * y * z * z * z * z;
}

/* { dg-final { scan-tree-dump-times "" \\* "" 5 ""optimized"" } } */
","/* { dg-do compile } */
/* { dg-options ""-O3 -ffast-math -fdump-tree-optimized"" } */

double baz (double x, double y, double z)
{
  return x * x * y * y * y * z * z * z * z;
}

/* { dg-final { scan-tree-dump-times "" \\* "" 5 ""optimized"" } } */
"
"/* { dg-do run { target ia32 } } */
/* { dg-options ""-Os"" } */

void
__attribute__ ((noipa))
foo (const char *x)
{
  asm volatile ("""" : ""+g"" (x) : : ""memory"");
  if (x)
    __builtin_abort ();
}

int a, b = 1;

int
main ()
{
  while (1)
    {
      unsigned long long d = 18446744073709551615UL;
      while (1)
	{
	  int e = b;
	  while (d < 2)
	    foo (""0"");
	  if (a)
	    d++;
	  if (b)
	    break;
	}
      break;
    }
  return 0;
}
","/* { dg-do run { target ia32 } } */
/* { dg-options ""-Os"" } */

void
__attribute__ ((noipa))
foo (const char *x)
{
  asm volatile ("""" : ""+g"" (x) : : ""memory"");
  if (x)
    __builtin_abort ();
}

int a, b = 1;

int
main ()
{
  while (1)
    {
      unsigned long long d = 18446744073709551615UL;
      while (1)
	{
	  int e = b;
	  while (d < 2)
	    foo (""0"");
	  if (a)
	    d++;
	  if (b)
	    break;
	}
      break;
    }
  return 0;
}
"
"float f(float src[][4])
{
 return *(src[3]);
}
","float f(float src[][4])
{
 return *(src[3]);
}
"
"/* { dg-require-effective-target vect_int } */

#include <stdarg.h>
#include ""tree-vect.h""

#define N 16

char cb[N] = {2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17};
char cc[N] = {1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16};

__attribute__ ((noinline)) int
main1 (void)
{
  int i;
  int diff = 0;

  /* Cross-iteration cycle.  */
  diff = 0;
  for (i = 0; i < N; i++) {
    diff += (cb[i] - cc[i]);
  }

  /* Check results.  */
  if (diff != 16)
    abort();

  return 0;
}

int main (void)
{
  check_vect ();
  return main1 ();
}

/* { dg-final { scan-tree-dump-times ""vectorized 1 loops"" 1 ""vect"" { target vect_unpack } } } */


","/* { dg-require-effective-target vect_int } */

#include <stdarg.h>
#include ""tree-vect.h""

#define N 16

char cb[N] = {2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17};
char cc[N] = {1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16};

__attribute__ ((noinline)) int
main1 (void)
{
  int i;
  int diff = 0;

  /* Cross-iteration cycle.  */
  diff = 0;
  for (i = 0; i < N; i++) {
    diff += (cb[i] - cc[i]);
  }

  /* Check results.  */
  if (diff != 16)
    abort();

  return 0;
}

int main (void)
{
  check_vect ();
  return main1 ();
}

/* { dg-final { scan-tree-dump-times ""vectorized 1 loops"" 1 ""vect"" { target vect_unpack } } } */


"
"/* Verify that preprocessor does not insert redundant newlines
   after #pragma, also check this for #include, #define and #undef */
/* { dg-do compile } */
/* { dg-options ""-dD"" } */
#include <stdio.h>

#undef unknow_def

int main () {

#pragma unknown
  {}
  error;
  /* { dg-error ""undeclared"" ""undeclared-variable message"" { target *-*-* } .-1 } */
  /* { dg-message ""function it appears in"" ""reminder message"" { target *-*-* } .-2 } */ 
}
","/* Verify that preprocessor does not insert redundant newlines
   after #pragma, also check this for #include, #define and #undef */
/* { dg-do compile } */
/* { dg-options ""-dD"" } */
#include <stdio.h>

#undef unknow_def

int main () {

#pragma unknown
  {}
  error;
  /* { dg-error ""undeclared"" ""undeclared-variable message"" { target *-*-* } .-1 } */
  /* { dg-message ""function it appears in"" ""reminder message"" { target *-*-* } .-2 } */ 
}
"
"/* { dg-do compile { target ia32 } } */
/* { dg-options ""-O2 -fdump-tree-optimized -mtune=lakemont"" } */

void bar (void);

void
foo (int x)
{
  if (x != 2 && x != 3 && x != 10 && x != 11 && x != 17 && x != 18 && x != 23)
    bar ();
}

/* Check if the tests have been folded into a bit test.  */
/* { dg-final { scan-tree-dump ""(8784908|0x0*860c0c)"" ""optimized"" } } */
/* { dg-final { scan-tree-dump ""(<<|>>)"" ""optimized"" } } */
","/* { dg-do compile { target ia32 } } */
/* { dg-options ""-O2 -fdump-tree-optimized -mtune=lakemont"" } */

void bar (void);

void
foo (int x)
{
  if (x != 2 && x != 3 && x != 10 && x != 11 && x != 17 && x != 18 && x != 23)
    bar ();
}

/* Check if the tests have been folded into a bit test.  */
/* { dg-final { scan-tree-dump ""(8784908|0x0*860c0c)"" ""optimized"" } } */
/* { dg-final { scan-tree-dump ""(<<|>>)"" ""optimized"" } } */
"
"/* { dg-do assemble } */

#include <arm_neon.h>

int8_t
test_vget_lane_s8_before (int8x8_t in)
{
  /* { dg-error ""lane -1 out of range 0 - 7"" """" {target *-*-*} 0 } */
  return vget_lane_s8 (in, -1);
}

int8_t
test_vget_lane_s8_beyond (int8x8_t in)
{
  /* { dg-error ""lane 8 out of range 0 - 7"" """" {target *-*-*} 0 } */
  return vget_lane_s8 (in, 8);
}
","/* { dg-do assemble } */

#include <arm_neon.h>

int8_t
test_vget_lane_s8_before (int8x8_t in)
{
  /* { dg-error ""lane -1 out of range 0 - 7"" """" {target *-*-*} 0 } */
  return vget_lane_s8 (in, -1);
}

int8_t
test_vget_lane_s8_beyond (int8x8_t in)
{
  /* { dg-error ""lane 8 out of range 0 - 7"" """" {target *-*-*} 0 } */
  return vget_lane_s8 (in, 8);
}
"
"/* PR c++/83059 */
/* { dg-do compile } */

void
foo (int *p, int *q, int *r)
{
  __atomic_compare_exchange (p, q, r, 0, 0, -1);	/* { dg-warning ""invalid memory model argument 6"" } */
  /* { dg-warning ""unknown architecture specifi"" """" { target *-*-* } .-1 } */
  /* { dg-warning ""failure memory model cannot be stronger than success memory model"" """" { target *-*-* } .-2 } */
}
","/* PR c++/83059 */
/* { dg-do compile } */

void
foo (int *p, int *q, int *r)
{
  __atomic_compare_exchange (p, q, r, 0, 0, -1);	/* { dg-warning ""invalid memory model argument 6"" } */
  /* { dg-warning ""unknown architecture specifi"" """" { target *-*-* } .-1 } */
  /* { dg-warning ""failure memory model cannot be stronger than success memory model"" """" { target *-*-* } .-2 } */
}
"
"/* { dg-do run } */
/* { dg-options ""-O2 -ffast-math -ftree-vectorize -msse -mfpmath=sse -mrecip"" } */
/* { dg-require-effective-target sse } */

#ifndef CHECK_H
#define CHECK_H ""sse-check.h""
#endif

#ifndef TEST
#define TEST sse_test
#endif

#include CHECK_H

extern float sqrtf (float);
extern float fabsf (float);

#define N 8

float a[N] = { 0.f, 18.f, 108.f, 324.f, 720.f, 1944.f, 3087.f, 5832.f };
float b[N] = { 1.f, 2.f, 3.f, 4.f, 5.f, 6.f, 7.f, 8.f };
float r[N];

float rc[N] = { 0.f, 3.f, 6.f, 9.f, 12.f, 18.f, 21.f, 27.f };

static void
TEST (void)
{
  int i;

  for (i = 0; i < N; i++)
    {
      r[i] = sqrtf (a[i] / b[i]);
    }

  /* check results:  */
  for (i = 0; i < N; i++)
    {
      if (fabsf (r[i] - rc[i]) > 0.0001)
	abort();
    }   
}
","/* { dg-do run } */
/* { dg-options ""-O2 -ffast-math -ftree-vectorize -msse -mfpmath=sse -mrecip"" } */
/* { dg-require-effective-target sse } */

#ifndef CHECK_H
#define CHECK_H ""sse-check.h""
#endif

#ifndef TEST
#define TEST sse_test
#endif

#include CHECK_H

extern float sqrtf (float);
extern float fabsf (float);

#define N 8

float a[N] = { 0.f, 18.f, 108.f, 324.f, 720.f, 1944.f, 3087.f, 5832.f };
float b[N] = { 1.f, 2.f, 3.f, 4.f, 5.f, 6.f, 7.f, 8.f };
float r[N];

float rc[N] = { 0.f, 3.f, 6.f, 9.f, 12.f, 18.f, 21.f, 27.f };

static void
TEST (void)
{
  int i;

  for (i = 0; i < N; i++)
    {
      r[i] = sqrtf (a[i] / b[i]);
    }

  /* check results:  */
  for (i = 0; i < N; i++)
    {
      if (fabsf (r[i] - rc[i]) > 0.0001)
	abort();
    }   
}
"
"/* Test AAPCS layout (VFP variant)  */

/* { dg-do run { target arm_eabi } }  */
/* { dg-require-effective-target arm_hard_vfp_ok }  */
/* { dg-require-effective-target arm_fp16_hw }  */
/* { dg-add-options arm_fp16_ieee }  */

#ifndef IN_FRAMEWORK
#define VFP
#define TESTFILE ""vfp21.c""

#define PCSATTR __attribute__((pcs(""aapcs"")))

#include ""abitest.h""
#else
#if defined (__ARM_BIG_ENDIAN)
ARG (__fp16, 1.0f, R0 + 2)
#else
ARG (__fp16, 1.0f, R0)
#endif
ARG (double, 2.0, R2)
ARG (__fp16, 3.0f, STACK)
ARG (float, 2.0f, STACK+4)
LAST_ARG (double, 4.0, STACK+8)
#endif

","/* Test AAPCS layout (VFP variant)  */

/* { dg-do run { target arm_eabi } }  */
/* { dg-require-effective-target arm_hard_vfp_ok }  */
/* { dg-require-effective-target arm_fp16_hw }  */
/* { dg-add-options arm_fp16_ieee }  */

#ifndef IN_FRAMEWORK
#define VFP
#define TESTFILE ""vfp21.c""

#define PCSATTR __attribute__((pcs(""aapcs"")))

#include ""abitest.h""
#else
#if defined (__ARM_BIG_ENDIAN)
ARG (__fp16, 1.0f, R0 + 2)
#else
ARG (__fp16, 1.0f, R0)
#endif
ARG (double, 2.0, R2)
ARG (__fp16, 3.0f, STACK)
ARG (float, 2.0f, STACK+4)
LAST_ARG (double, 4.0, STACK+8)
#endif

"
"/* Check calling convention in the vector ABI.  */

/* { dg-do compile { target { s390*-*-* } } } */
/* { dg-options ""-O3 -mzarch -march=z13"" } */

/* { dg-final { scan-assembler ""gnu_attribute 8, 2"" } } */

#include <stdarg.h>

typedef int __attribute__((vector_size(16))) v4si;

extern void bar (int, ...);

void
foo (int a)
{
  v4si b = (v4si){ a, a, a, a };
  bar (1, b);
}
","/* Check calling convention in the vector ABI.  */

/* { dg-do compile { target { s390*-*-* } } } */
/* { dg-options ""-O3 -mzarch -march=z13"" } */

/* { dg-final { scan-assembler ""gnu_attribute 8, 2"" } } */

#include <stdarg.h>

typedef int __attribute__((vector_size(16))) v4si;

extern void bar (int, ...);

void
foo (int a)
{
  v4si b = (v4si){ a, a, a, a };
  bar (1, b);
}
"
"/* { dg-do compile } */
/* { dg-options ""-O2 -mcpu=thunderx -march=armv8-a -dA"" } */

/* Make sure that #pragma overrides command line option and
   target attribute overrides the pragma.  */

#pragma GCC target (""cpu=xgene1"")

int
bar (int a)
{
  return a - 6;
}

__attribute__ ((target (""tune=cortex-a53"")))
int
bam (int a)
{
  return a - bar (a);
}

/* { dg-final { scan-assembler-times ""//.tune xgene1"" 1 } } */
/* { dg-final { scan-assembler-times ""//.tune cortex-a53"" 1 } } */
/* { dg-final { scan-assembler-not ""thunderx"" } } */
","/* { dg-do compile } */
/* { dg-options ""-O2 -mcpu=thunderx -march=armv8-a -dA"" } */

/* Make sure that #pragma overrides command line option and
   target attribute overrides the pragma.  */

#pragma GCC target (""cpu=xgene1"")

int
bar (int a)
{
  return a - 6;
}

__attribute__ ((target (""tune=cortex-a53"")))
int
bam (int a)
{
  return a - bar (a);
}

/* { dg-final { scan-assembler-times ""//.tune xgene1"" 1 } } */
/* { dg-final { scan-assembler-times ""//.tune cortex-a53"" 1 } } */
/* { dg-final { scan-assembler-not ""thunderx"" } } */
"
"/* { dg-require-effective-target vect_int } */

#include ""tree-vect.h""
int arr[2048];
int res[100] = { 13198, 13224, 12735, 12760, 12270, 12294,
		 11803, 11826, 11334, 11356, 10863, 10884,
		 10390, 10410, 9915, 9934, 9438, 9456,
		 8959, 8976, 8478, 8494, 7995, 8010,
		 7510, 7524, 7023, 7036, 6534, 6546,
		 6043, 6054, 5550, 5560, 5055, 5064,
		 4558, 4566, 4059, 4066, 3558, 3564,
		 3055, 3060, 2550, 2554, 2043, 0};

__attribute__ ((noinline)) int
foo (int *a, int *b)
{
  int i;
  int *a1 = a;
  int *a0 = a1 - 512;
  for (i = 0; i < 50; i++)
    {
      *b = *a0 + *a1;
      b--;
      a0--;
      a1--;
    }
  return 0;
}

int main (void)
{
  int *a = &arr[1024];
  int *b = &arr[1022];

  int i;
  for (i = 0; i < 2048; i++)
    arr[i] = i;

  foo (a, b);

  for (i = 973; i < 1020; i++)
    if (arr[i] != res[i - 973])
      abort ();

  return 0;
}
","/* { dg-require-effective-target vect_int } */

#include ""tree-vect.h""
int arr[2048];
int res[100] = { 13198, 13224, 12735, 12760, 12270, 12294,
		 11803, 11826, 11334, 11356, 10863, 10884,
		 10390, 10410, 9915, 9934, 9438, 9456,
		 8959, 8976, 8478, 8494, 7995, 8010,
		 7510, 7524, 7023, 7036, 6534, 6546,
		 6043, 6054, 5550, 5560, 5055, 5064,
		 4558, 4566, 4059, 4066, 3558, 3564,
		 3055, 3060, 2550, 2554, 2043, 0};

__attribute__ ((noinline)) int
foo (int *a, int *b)
{
  int i;
  int *a1 = a;
  int *a0 = a1 - 512;
  for (i = 0; i < 50; i++)
    {
      *b = *a0 + *a1;
      b--;
      a0--;
      a1--;
    }
  return 0;
}

int main (void)
{
  int *a = &arr[1024];
  int *b = &arr[1022];

  int i;
  for (i = 0; i < 2048; i++)
    arr[i] = i;

  foo (a, b);

  for (i = 973; i < 1020; i++)
    if (arr[i] != res[i - 973])
      abort ();

  return 0;
}
"
"/* Verify that we don't ICE trying to put SPE data in .sdata2.  */
/* { dg-do run { target { powerpc*-*-linux* && powerpc_spe } } } */
/* { dg-options ""-msdata=eabi -mcall-eabi -G 8"" } */

#include <spe.h>

__ev64_fs__ x;

int main(void)
{
  x = __ev_fsabs (x);
  return(0);
}

","/* Verify that we don't ICE trying to put SPE data in .sdata2.  */
/* { dg-do run { target { powerpc*-*-linux* && powerpc_spe } } } */
/* { dg-options ""-msdata=eabi -mcall-eabi -G 8"" } */

#include <spe.h>

__ev64_fs__ x;

int main(void)
{
  x = __ev_fsabs (x);
  return(0);
}

"
"/* VLAs should be deallocated on a jump to before their definition,
   including a jump to a label in an inner scope.  PR 19771.  */
/* { dg-require-effective-target alloca } */

#if (__SIZEOF_INT__ <= 2)
#define LIMIT 10000
#else
#define LIMIT 1000000
#endif

void *volatile p;

int
main (void)
{
  int n = 0;
  if (0)
    {
    lab:;
    }
  int x[n % 1000 + 1];
  x[0] = 1;
  x[n % 1000] = 2;
  p = x;
  n++;
  if (n < LIMIT)
    goto lab;
  return 0;
}
","/* VLAs should be deallocated on a jump to before their definition,
   including a jump to a label in an inner scope.  PR 19771.  */
/* { dg-require-effective-target alloca } */

#if (__SIZEOF_INT__ <= 2)
#define LIMIT 10000
#else
#define LIMIT 1000000
#endif

void *volatile p;

int
main (void)
{
  int n = 0;
  if (0)
    {
    lab:;
    }
  int x[n % 1000 + 1];
  x[0] = 1;
  x[n % 1000] = 2;
  p = x;
  n++;
  if (n < LIMIT)
    goto lab;
  return 0;
}
"
"/* { dg-do compile } */
/* { dg-options ""-mavx512f -O2"" } */
/* { dg-final { scan-assembler-times ""vpcmpgtd\[ \\t\]+\[^\{\n\]*%zmm\[0-9\]+\[^\n^k\]*%k\[0-7\](?:\n|\[ \\t\]+#)"" 1 } } */
/* { dg-final { scan-assembler-times ""vpcmpgtd\[ \\t\]+\[^\{\n\]*%zmm\[0-9\]+\[^\n^k\]*%k\[0-7\]\{%k\[0-7\]\}(?:\n|\[ \\t\]+#)"" 1 } } */

#include <immintrin.h>

volatile __m512i x;
volatile __mmask16 m;

void extern
avx512f_test (void)
{
  m = _mm512_cmpgt_epi32_mask (x, x);
  m = _mm512_mask_cmpgt_epi32_mask (3, x, x);
}
","/* { dg-do compile } */
/* { dg-options ""-mavx512f -O2"" } */
/* { dg-final { scan-assembler-times ""vpcmpgtd\[ \\t\]+\[^\{\n\]*%zmm\[0-9\]+\[^\n^k\]*%k\[0-7\](?:\n|\[ \\t\]+#)"" 1 } } */
/* { dg-final { scan-assembler-times ""vpcmpgtd\[ \\t\]+\[^\{\n\]*%zmm\[0-9\]+\[^\n^k\]*%k\[0-7\]\{%k\[0-7\]\}(?:\n|\[ \\t\]+#)"" 1 } } */

#include <immintrin.h>

volatile __m512i x;
volatile __mmask16 m;

void extern
avx512f_test (void)
{
  m = _mm512_cmpgt_epi32_mask (x, x);
  m = _mm512_mask_cmpgt_epi32_mask (3, x, x);
}
"
"/* { dg-do compile { target { powerpc*-*-* && lp64 } } } */
/* { dg-options ""-O2"" } */

/* { dg-final { scan-assembler-not ""cmpw"" } } */

/* Origin:Pete Steinmetz <steinmtz@us.ibm.com> */

/* PR 16458: Extraneous compare.  */

int foo (unsigned a, unsigned b)
{
  if (a == b) return 1;
  if (a > b)  return 2;
  if (a < b)  return 3;
  return 0;
}
","/* { dg-do compile { target { powerpc*-*-* && lp64 } } } */
/* { dg-options ""-O2"" } */

/* { dg-final { scan-assembler-not ""cmpw"" } } */

/* Origin:Pete Steinmetz <steinmtz@us.ibm.com> */

/* PR 16458: Extraneous compare.  */

int foo (unsigned a, unsigned b)
{
  if (a == b) return 1;
  if (a > b)  return 2;
  if (a < b)  return 3;
  return 0;
}
"
"/* { dg-do compile } */
/* { dg-additional-options ""-ftree-vectorize"" } */

void
zz (int x9, short int gt)
{
  if (0)
    {
      while (gt < 1)
	{
	  int pz;

k6:
	  for (pz = 0; pz < 3; ++pz)
	    x9 += gt;
	  ++gt;
	}
    }

  if (x9 != 0)
    goto k6;
}
","/* { dg-do compile } */
/* { dg-additional-options ""-ftree-vectorize"" } */

void
zz (int x9, short int gt)
{
  if (0)
    {
      while (gt < 1)
	{
	  int pz;

k6:
	  for (pz = 0; pz < 3; ++pz)
	    x9 += gt;
	  ++gt;
	}
    }

  if (x9 != 0)
    goto k6;
}
"
"/* { dg-do compile { target int128 } } */
/* { dg-options ""-O -mavx512f -fno-split-wide-types --param max-combine-insns=2"" } */

typedef unsigned      int U __attribute__((vector_size(64)));
typedef unsigned __int128 V __attribute__((vector_size(64)));

V
foo(V v)
{
  v[0] = 1u << ((  ((V)(U){1, 1, v[0]})[0]) & 0xf)
            >> ((-~((V)(U){1, 1, v[0]})[0]) & 0xf);
  return v;
}
","/* { dg-do compile { target int128 } } */
/* { dg-options ""-O -mavx512f -fno-split-wide-types --param max-combine-insns=2"" } */

typedef unsigned      int U __attribute__((vector_size(64)));
typedef unsigned __int128 V __attribute__((vector_size(64)));

V
foo(V v)
{
  v[0] = 1u << ((  ((V)(U){1, 1, v[0]})[0]) & 0xf)
            >> ((-~((V)(U){1, 1, v[0]})[0]) & 0xf);
  return v;
}
"
"/* { dg-do compile } */
/* { dg-options ""-O2 -fdump-tree-ivopts-details"" } */

double g;

int foo(char *flags, long len, long i, long steps)
{
  register long step, iter;

  if(*(flags + i))
    {
      step = i + i + 3;
      for(iter = i + step ; iter <= len ; iter += step)
	{
	  steps++;
	  *(flags + iter)=0;
	}
    }
   g = 5.0*(double)steps;

   return 0;
}

/* Don't expand iv {base+step, step}_loop into {base+x+y, step}_loop
   even if ""step == x + y"".  */
/* { dg-final { scan-tree-dump ""Base:\\tstep_\[0-9\]* \\+ iter|Base:\\titer_\[0-9\]* \\+ step"" ""ivopts""} } */
","/* { dg-do compile } */
/* { dg-options ""-O2 -fdump-tree-ivopts-details"" } */

double g;

int foo(char *flags, long len, long i, long steps)
{
  register long step, iter;

  if(*(flags + i))
    {
      step = i + i + 3;
      for(iter = i + step ; iter <= len ; iter += step)
	{
	  steps++;
	  *(flags + iter)=0;
	}
    }
   g = 5.0*(double)steps;

   return 0;
}

/* Don't expand iv {base+step, step}_loop into {base+x+y, step}_loop
   even if ""step == x + y"".  */
/* { dg-final { scan-tree-dump ""Base:\\tstep_\[0-9\]* \\+ iter|Base:\\titer_\[0-9\]* \\+ step"" ""ivopts""} } */
"
"/* { dg-do compile } */
/* { dg-options ""-O2 -ffast-math -ftree-vectorize -msse -mfpmath=sse -mrecip -fno-common"" } */

float a[4];
float b[4];
float r[4];

void t1(void)
{
 int i;

 for (i = 0; i < 4; i++)
   r[i] = a[i] / b[i];
}

/* { dg-final { scan-assembler ""rcpps"" } } */
","/* { dg-do compile } */
/* { dg-options ""-O2 -ffast-math -ftree-vectorize -msse -mfpmath=sse -mrecip -fno-common"" } */

float a[4];
float b[4];
float r[4];

void t1(void)
{
 int i;

 for (i = 0; i < 4; i++)
   r[i] = a[i] / b[i];
}

/* { dg-final { scan-assembler ""rcpps"" } } */
"
"/* PR tree-optimization/63563 */
/* { dg-do compile } */
/* { dg-options ""-O3 -mavx2"" } */

struct A { unsigned long a, b, c, d; } a[1024] = { { 0, 1, 2, 3 } }, b;

void
foo (void)
{
  int i;
  for (i = 0; i < 1024; i++)
    {
      a[i].a = a[i].b = a[i].c = b.c;
      if (a[i].d)
	a[i].d = b.d;
    }
}
","/* PR tree-optimization/63563 */
/* { dg-do compile } */
/* { dg-options ""-O3 -mavx2"" } */

struct A { unsigned long a, b, c, d; } a[1024] = { { 0, 1, 2, 3 } }, b;

void
foo (void)
{
  int i;
  for (i = 0; i < 1024; i++)
    {
      a[i].a = a[i].b = a[i].c = b.c;
      if (a[i].d)
	a[i].d = b.d;
    }
}
"
"/* Test warnings for missing format attributes on function pointers.  */
/* Origin: Kaveh Ghazi <ghazi@caip.rutgers.edu> */
/* { dg-do compile { target { *-*-mingw* } } } */
/* { dg-options ""-std=gnu99 -Wmissing-format-attribute"" } */

#define USE_SYSTEM_FORMATS
#include ""format.h""

typedef void (*noattr_t) (const char *, ...);
typedef noattr_t __attribute__ ((__format__(__ms_printf__, 1, 2))) attr_t;

typedef void (*vnoattr_t) (const char *, va_list);
typedef vnoattr_t __attribute__ ((__format__(__ms_printf__, 1, 0))) vattr_t;

void
foo1 (noattr_t na, attr_t a, vnoattr_t vna, vattr_t va)
{
  noattr_t na1 = na;
  noattr_t na2 = a; /* { dg-warning ""candidate"" ""initialization warning"" } */
  attr_t a1 = na;
  attr_t a2 = a;

  vnoattr_t vna1 = vna;
  vnoattr_t vna2 = va; /* { dg-warning ""candidate"" ""initialization warning"" } */
  vattr_t va1 = vna;
  vattr_t va2 = va;
}
","/* Test warnings for missing format attributes on function pointers.  */
/* Origin: Kaveh Ghazi <ghazi@caip.rutgers.edu> */
/* { dg-do compile { target { *-*-mingw* } } } */
/* { dg-options ""-std=gnu99 -Wmissing-format-attribute"" } */

#define USE_SYSTEM_FORMATS
#include ""format.h""

typedef void (*noattr_t) (const char *, ...);
typedef noattr_t __attribute__ ((__format__(__ms_printf__, 1, 2))) attr_t;

typedef void (*vnoattr_t) (const char *, va_list);
typedef vnoattr_t __attribute__ ((__format__(__ms_printf__, 1, 0))) vattr_t;

void
foo1 (noattr_t na, attr_t a, vnoattr_t vna, vattr_t va)
{
  noattr_t na1 = na;
  noattr_t na2 = a; /* { dg-warning ""candidate"" ""initialization warning"" } */
  attr_t a1 = na;
  attr_t a2 = a;

  vnoattr_t vna1 = vna;
  vnoattr_t vna2 = va; /* { dg-warning ""candidate"" ""initialization warning"" } */
  vattr_t va1 = vna;
  vattr_t va2 = va;
}
"
"/* { dg-do run { target { ! ia32 } } } */
/* { dg-require-effective-target avx } */
/* { dg-options ""-O2 -mavx"" } */

#define CHECK_H ""avx-check.h""
#define TEST avx_test

#include ""sse2-movq-3.c""
","/* { dg-do run { target { ! ia32 } } } */
/* { dg-require-effective-target avx } */
/* { dg-options ""-O2 -mavx"" } */

#define CHECK_H ""avx-check.h""
#define TEST avx_test

#include ""sse2-movq-3.c""
"
"/* The same test as 921011-1.c.  It can fails on gcc 4.1 due to a dfs
   traversal of the loops after versioning.  */

/* { dg-do compile } */
/* { dg-options ""-O2 -fmodulo-sched -fdump-rtl-sms"" } */

int th, h, em, nlwm, nlwS, nlw, sy;
void
fun (nb)
     int nb;
{

  while (nb--)
    while (h--)
      {
	nlw = nlwm;
	while (nlw)
	  {
	    if (nlwS == 1)
	      {
	      }
	    else
	      if (nlwS == 1)
		{
		}
	    nlwS--; nlw--;
	  }
	if (em)
	  nlwS--;
	if (++sy == th)
	  sy = 0;
      }
}

/* { dg-final { scan-rtl-dump-times ""SMS loop many exits"" 1 ""sms"" { target spu-*-* powerpc*-*-* } } } */
","/* The same test as 921011-1.c.  It can fails on gcc 4.1 due to a dfs
   traversal of the loops after versioning.  */

/* { dg-do compile } */
/* { dg-options ""-O2 -fmodulo-sched -fdump-rtl-sms"" } */

int th, h, em, nlwm, nlwS, nlw, sy;
void
fun (nb)
     int nb;
{

  while (nb--)
    while (h--)
      {
	nlw = nlwm;
	while (nlw)
	  {
	    if (nlwS == 1)
	      {
	      }
	    else
	      if (nlwS == 1)
		{
		}
	    nlwS--; nlw--;
	  }
	if (em)
	  nlwS--;
	if (++sy == th)
	  sy = 0;
      }
}

/* { dg-final { scan-rtl-dump-times ""SMS loop many exits"" 1 ""sms"" { target spu-*-* powerpc*-*-* } } } */
"
"/* { dg-do compile } */

unsigned a;
short b;
char c, d, e;
void fn1();
void fn2() {
    a++;
    for (; a;)
      fn1(0, 0);
}
void fn3() {
    fn2();
l1:;
   unsigned char f;
   short g;
   unsigned char *h = &f;
   g += &h ? e ? g = 1 : 0 : 0;
   d = g;
   c *f;
   if (d & (b %= *h) < f * d / (d -= 0))
     goto l1;
}
","/* { dg-do compile } */

unsigned a;
short b;
char c, d, e;
void fn1();
void fn2() {
    a++;
    for (; a;)
      fn1(0, 0);
}
void fn3() {
    fn2();
l1:;
   unsigned char f;
   short g;
   unsigned char *h = &f;
   g += &h ? e ? g = 1 : 0 : 0;
   d = g;
   c *f;
   if (d & (b %= *h) < f * d / (d -= 0))
     goto l1;
}
"
"/* { dg-do run { target { powerpc64le-*-* } } } */
/* { dg-skip-if ""do not override -mcpu"" { powerpc*-*-* } { ""-mcpu=*"" } { ""-mcpu=power8"" } } */
/* { dg-options ""-mcpu=power8 -O3"" } */

void abort ();

#define N 4096
int ca[N] __attribute__((aligned(16)));
int cb[N] __attribute__((aligned(16)));
int cc[N] __attribute__((aligned(16)));
int cd[N] __attribute__((aligned(16)));

__attribute__((noinline)) void foo ()
{
  int i;
  for (i = 0; i < N; i++) {
    ca[i] = ((cb[i] + cc[i]) * cd[i]) >> 3;
  }
}

__attribute__((noinline)) void init ()
{
  int i;
  for (i = 0; i < N; ++i) {
    cb[i] = 3 * i - 2048;
    cc[i] = -5 * i + 93;
    cd[i] = i % 2 ? 1 : -1;
  }
}

int main ()
{
  int i;
  init ();
  foo ();
  for (i = 0; i < N; ++i)
    if (i % 2 == 1 && ca[i] != (-2 * i - 1955) >> 3)
      abort ();
    else if (i % 2 == 0 && ca[i] != (1955 + 2 * i) >> 3)
      abort ();
  return 0;
}
","/* { dg-do run { target { powerpc64le-*-* } } } */
/* { dg-skip-if ""do not override -mcpu"" { powerpc*-*-* } { ""-mcpu=*"" } { ""-mcpu=power8"" } } */
/* { dg-options ""-mcpu=power8 -O3"" } */

void abort ();

#define N 4096
int ca[N] __attribute__((aligned(16)));
int cb[N] __attribute__((aligned(16)));
int cc[N] __attribute__((aligned(16)));
int cd[N] __attribute__((aligned(16)));

__attribute__((noinline)) void foo ()
{
  int i;
  for (i = 0; i < N; i++) {
    ca[i] = ((cb[i] + cc[i]) * cd[i]) >> 3;
  }
}

__attribute__((noinline)) void init ()
{
  int i;
  for (i = 0; i < N; ++i) {
    cb[i] = 3 * i - 2048;
    cc[i] = -5 * i + 93;
    cd[i] = i % 2 ? 1 : -1;
  }
}

int main ()
{
  int i;
  init ();
  foo ();
  for (i = 0; i < N; ++i)
    if (i % 2 == 1 && ca[i] != (-2 * i - 1955) >> 3)
      abort ();
    else if (i % 2 == 0 && ca[i] != (1955 + 2 * i) >> 3)
      abort ();
  return 0;
}
"
"/* { dg-do compile } */
/* { dg-require-effective-target tls } */
/* { dg-options ""-O2"" } */
/* { dg-final { scan-assembler-not ""ldw\tr., %lo"" } } */
/* { dg-final { scan-assembler-not ""stw\tr., %lo"" } } */

/* Check that address transformations for symbolic constants do NOT
   apply to TLS variables.  */

#define TYPE int

struct ss
{
  TYPE x1,x2;
};

extern __thread TYPE S1;
extern __thread TYPE S2[];

extern __thread struct ss S3;
extern __thread struct ss S4[];

TYPE *addr1 (void) { return &S1; }
TYPE get1 (void) { return S1; }
void set1 (TYPE value) { S1 = value; }

TYPE *addr2 (int i) { return &(S2[i]); }
TYPE get2 (int i) { return S2[i]; }
void set2 (int i, TYPE value) { S2[i] = value; }

TYPE *addr3 (void) { return &(S3.x2); }
TYPE get3 (void) { return S3.x2; }
void set3 (TYPE value) { S3.x2 = value; }

TYPE *addr4 (int i) { return &(S4[i].x2); }
TYPE get4 (int i) { return S4[i].x2; }
void set4 (int i, TYPE value) { S4[i].x2 = value; }

","/* { dg-do compile } */
/* { dg-require-effective-target tls } */
/* { dg-options ""-O2"" } */
/* { dg-final { scan-assembler-not ""ldw\tr., %lo"" } } */
/* { dg-final { scan-assembler-not ""stw\tr., %lo"" } } */

/* Check that address transformations for symbolic constants do NOT
   apply to TLS variables.  */

#define TYPE int

struct ss
{
  TYPE x1,x2;
};

extern __thread TYPE S1;
extern __thread TYPE S2[];

extern __thread struct ss S3;
extern __thread struct ss S4[];

TYPE *addr1 (void) { return &S1; }
TYPE get1 (void) { return S1; }
void set1 (TYPE value) { S1 = value; }

TYPE *addr2 (int i) { return &(S2[i]); }
TYPE get2 (int i) { return S2[i]; }
void set2 (int i, TYPE value) { S2[i] = value; }

TYPE *addr3 (void) { return &(S3.x2); }
TYPE get3 (void) { return S3.x2; }
void set3 (TYPE value) { S3.x2 = value; }

TYPE *addr4 (int i) { return &(S4[i].x2); }
TYPE get4 (int i) { return S4[i].x2; }
void set4 (int i, TYPE value) { S4[i].x2 = value; }

"
"/* { dg-do compile } */
/* { dg-options ""-O2 -fdump-tree-pre-details"" } */

void bark (void);
int flag, hoist, y, z;

void
foo (void)
{
  if (flag)
    y = hoist + 4;
  else
    flag = 888;
  z = hoist + 4;
  bark ();
}

/* We should see the partial redundancy of hoist + 4, not being confused
   about bark () possibly clobbering hoist.  */

/* { dg-final { scan-tree-dump ""Replaced hoist"" ""pre"" } } */
","/* { dg-do compile } */
/* { dg-options ""-O2 -fdump-tree-pre-details"" } */

void bark (void);
int flag, hoist, y, z;

void
foo (void)
{
  if (flag)
    y = hoist + 4;
  else
    flag = 888;
  z = hoist + 4;
  bark ();
}

/* We should see the partial redundancy of hoist + 4, not being confused
   about bark () possibly clobbering hoist.  */

/* { dg-final { scan-tree-dump ""Replaced hoist"" ""pre"" } } */
"
"/* { dg-do compile { target *-*-darwin* } } */
/* { dg-options ""--param case-values-threshold=3 -O2"" } */
/* { dg-additional-options ""-funwind-tables"" { target powerpc*-*-darwin* } }

/* This is testing that a trailing local label is followed by a
   nop where required.  */
   
int foo (int x)
{
  switch (x)
    {
      case 0:
        return 10;
      case 3:
        return -1;
      case 5:
        return 29;
      default:
        __builtin_unreachable();
    }
}

/* { dg-final { scan-assembler ""nop\\nLFE.*"" { target  { *-*-darwin* } } } } */
","/* { dg-do compile { target *-*-darwin* } } */
/* { dg-options ""--param case-values-threshold=3 -O2"" } */
/* { dg-additional-options ""-funwind-tables"" { target powerpc*-*-darwin* } }

/* This is testing that a trailing local label is followed by a
   nop where required.  */
   
int foo (int x)
{
  switch (x)
    {
      case 0:
        return 10;
      case 3:
        return -1;
      case 5:
        return 29;
      default:
        __builtin_unreachable();
    }
}

/* { dg-final { scan-assembler ""nop\\nLFE.*"" { target  { *-*-darwin* } } } } */
"
"/* Copyright (C) 2000 Free Software Foundation, Inc.  */

/* { dg-do preprocess } */
/* { dg-options ""-std=gnu89 -pedantic"" } */

/* This file is for testing the preprocessor in -std=gnu89 -pedantic mode.
   Neil Booth, 2 Dec 2000.  */

#if 1LL				/* { dg-warning ""long long"" } */
#endif
","/* Copyright (C) 2000 Free Software Foundation, Inc.  */

/* { dg-do preprocess } */
/* { dg-options ""-std=gnu89 -pedantic"" } */

/* This file is for testing the preprocessor in -std=gnu89 -pedantic mode.
   Neil Booth, 2 Dec 2000.  */

#if 1LL				/* { dg-warning ""long long"" } */
#endif
"
"/* Test the `vextQp64' ARM Neon intrinsic.  */

/* { dg-require-effective-target arm_crypto_ok } */
/* { dg-options ""-save-temps -O3 -fno-inline"" } */
/* { dg-add-options arm_crypto } */

#include ""arm_neon.h""

extern void abort (void);

poly64x2_t
test_vextq_p64_1 (poly64x2_t a, poly64x2_t b)
{
  return vextq_p64(a, b, 1);
}

int
main (int argc, char **argv)
{
  int i, off;
  poly64x2_t in1 = {0, 1};
  poly64x2_t in2 = {2, 3};
  poly64x2_t actual = test_vextq_p64_1 (in1, in2);
  for (i = 0; i < 2; i++)
    if (actual[i] != i + 1)
      abort ();

  return 0;
}

/* { dg-final { scan-assembler-times ""vext\.64\[ \t\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(?:\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n"" 1 } } */
","/* Test the `vextQp64' ARM Neon intrinsic.  */

/* { dg-require-effective-target arm_crypto_ok } */
/* { dg-options ""-save-temps -O3 -fno-inline"" } */
/* { dg-add-options arm_crypto } */

#include ""arm_neon.h""

extern void abort (void);

poly64x2_t
test_vextq_p64_1 (poly64x2_t a, poly64x2_t b)
{
  return vextq_p64(a, b, 1);
}

int
main (int argc, char **argv)
{
  int i, off;
  poly64x2_t in1 = {0, 1};
  poly64x2_t in2 = {2, 3};
  poly64x2_t actual = test_vextq_p64_1 (in1, in2);
  for (i = 0; i < 2; i++)
    if (actual[i] != i + 1)
      abort ();

  return 0;
}

/* { dg-final { scan-assembler-times ""vext\.64\[ \t\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(?:\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n"" 1 } } */
"
"/* { dg-do compile } */
/* { dg-options ""-O2"" }  */

extern void overflow_handler ();

unsigned __int128 overflow_sub (unsigned __int128 x, unsigned __int128 y)
{
  unsigned __int128 r;

  int ovr = __builtin_sub_overflow (x, y, &r);
  if (ovr)
    overflow_handler ();

  return r;
}

/* { dg-final { scan-assembler ""subs"" } } */
/* { dg-final { scan-assembler ""sbcs"" } } */
","/* { dg-do compile } */
/* { dg-options ""-O2"" }  */

extern void overflow_handler ();

unsigned __int128 overflow_sub (unsigned __int128 x, unsigned __int128 y)
{
  unsigned __int128 r;

  int ovr = __builtin_sub_overflow (x, y, &r);
  if (ovr)
    overflow_handler ();

  return r;
}

/* { dg-final { scan-assembler ""subs"" } } */
/* { dg-final { scan-assembler ""sbcs"" } } */
"
"/* { dg-options ""-fdiagnostics-show-caret"" } */

/* Adapted from https://gcc.gnu.org/wiki/ClangDiagnosticsComparison */

void call_of_non_function_ptr (char **argP, char **argQ)
{
  (argP - argQ)(); /* { dg-error ""called object is not a function or function pointer"" } */

/* { dg-begin-multiline-output """" }
   (argP - argQ)();
   ~~~~~~^~~~~~~
   { dg-end-multiline-output """" } */

  argP();       /* { dg-error ""called object 'argP' is not a function or function pointer"" } */

/* { dg-begin-multiline-output """" }
   argP();
   ^~~~
   { dg-end-multiline-output """" }
   { dg-begin-multiline-output """" }
 void call_of_non_function_ptr (char **argP, char **argQ)
                                ~~~~~~~^~~~
   { dg-end-multiline-output """" } */
}
","/* { dg-options ""-fdiagnostics-show-caret"" } */

/* Adapted from https://gcc.gnu.org/wiki/ClangDiagnosticsComparison */

void call_of_non_function_ptr (char **argP, char **argQ)
{
  (argP - argQ)(); /* { dg-error ""called object is not a function or function pointer"" } */

/* { dg-begin-multiline-output """" }
   (argP - argQ)();
   ~~~~~~^~~~~~~
   { dg-end-multiline-output """" } */

  argP();       /* { dg-error ""called object 'argP' is not a function or function pointer"" } */

/* { dg-begin-multiline-output """" }
   argP();
   ^~~~
   { dg-end-multiline-output """" }
   { dg-begin-multiline-output """" }
 void call_of_non_function_ptr (char **argP, char **argQ)
                                ~~~~~~~^~~~
   { dg-end-multiline-output """" } */
}
"
"/* { dg-do compile { target { *-*-linux* && ia32 } } } */
/* { dg-options ""-O2 -fpic -fno-plt -mregparm=3"" } */

extern void bar (int, int, int);

void
foo (int a, int b, int c)
{
  bar (a, b, c);
  bar (a, b, c);
}

/* { dg-final { scan-assembler-not ""jmp\[ \t\]*.bar@GOT"" } } */
","/* { dg-do compile { target { *-*-linux* && ia32 } } } */
/* { dg-options ""-O2 -fpic -fno-plt -mregparm=3"" } */

extern void bar (int, int, int);

void
foo (int a, int b, int c)
{
  bar (a, b, c);
  bar (a, b, c);
}

/* { dg-final { scan-assembler-not ""jmp\[ \t\]*.bar@GOT"" } } */
"
"/* This testcase caused a buffer overflow in simplify_immed_subreg.  */
/* { dg-do compile } */
/* { dg-options ""-O2 -msse2"" } */

#include <emmintrin.h>

__m128i foo (__m128i x)
{
  return _mm_min_epu8 (x, _mm_set1_epi8 (10));
}
","/* This testcase caused a buffer overflow in simplify_immed_subreg.  */
/* { dg-do compile } */
/* { dg-options ""-O2 -msse2"" } */

#include <emmintrin.h>

__m128i foo (__m128i x)
{
  return _mm_min_epu8 (x, _mm_set1_epi8 (10));
}
"
"/* Copyright (C) 2007 Free Software Foundation, Inc.  */
/* PR preprocessor/28227 */

/* { dg-do preprocess } */
#ifdef defined
#endif
#ifndef defined
#endif

int x;
","/* Copyright (C) 2007 Free Software Foundation, Inc.  */
/* PR preprocessor/28227 */

/* { dg-do preprocess } */
#ifdef defined
#endif
#ifndef defined
#endif

int x;
"
"typedef struct {
    int v[4];
} Test1;

Test1 func2();

int func1()
{
    Test1 test;
    test = func2();

    if (test.v[0] != 10)
      abort ();
    if (test.v[1] != 20)
      abort ();
    if (test.v[2] != 30)
      abort ();
    if (test.v[3] != 40)
      abort ();
}

Test1 func2()
{
    Test1 tmp;
    tmp.v[0] = 10;
    tmp.v[1] = 20;
    tmp.v[2] = 30;
    tmp.v[3] = 40;
    return tmp;
}


int main()
{
    func1();
    exit (0);
}


","typedef struct {
    int v[4];
} Test1;

Test1 func2();

int func1()
{
    Test1 test;
    test = func2();

    if (test.v[0] != 10)
      abort ();
    if (test.v[1] != 20)
      abort ();
    if (test.v[2] != 30)
      abort ();
    if (test.v[3] != 40)
      abort ();
}

Test1 func2()
{
    Test1 tmp;
    tmp.v[0] = 10;
    tmp.v[1] = 20;
    tmp.v[2] = 30;
    tmp.v[3] = 40;
    return tmp;
}


int main()
{
    func1();
    exit (0);
}


"
"/* { dg-do compile } */
/* { dg-require-effective-target arm_v8_vfp_ok } */
/* { dg-options ""-O2"" } */
/* { dg-add-options arm_v8_vfp } */

double
foo (double x)
{
  return __builtin_round (x);
}

/* { dg-final { scan-assembler-times ""vrinta.f64\td\[0-9\]+"" 1 } } */
","/* { dg-do compile } */
/* { dg-require-effective-target arm_v8_vfp_ok } */
/* { dg-options ""-O2"" } */
/* { dg-add-options arm_v8_vfp } */

double
foo (double x)
{
  return __builtin_round (x);
}

/* { dg-final { scan-assembler-times ""vrinta.f64\td\[0-9\]+"" 1 } } */
"
"main ()
{
  int i;
  for (i = 100;  i >= -1; i--)
    foo ();

}
","main ()
{
  int i;
  for (i = 100;  i >= -1; i--)
    foo ();

}
"
"/* Test backslash newline with and without trailing spaces.  */

#define alpha(a, b, c) \
	a, \
	b, \
	c

/* Note the trailing whitespace on the first three lines of beta def.  */
/* { dg-warning ""separated by space"" ""space"" { target *-*-* } .+3 } */
/* { dg-warning ""separated by space"" ""tab"" { target *-*-* } .+3 } */
/* { dg-warning ""separated by space"" ""space and tab"" { target *-*-* } .+3 } */
#define beta(a, b, c) \ 
	a, \	
	b, \ 	
	c

int x[] = {
   alpha(1, 2, 3),
   beta(4, 5, 6)
};
","/* Test backslash newline with and without trailing spaces.  */

#define alpha(a, b, c) \
	a, \
	b, \
	c

/* Note the trailing whitespace on the first three lines of beta def.  */
/* { dg-warning ""separated by space"" ""space"" { target *-*-* } .+3 } */
/* { dg-warning ""separated by space"" ""tab"" { target *-*-* } .+3 } */
/* { dg-warning ""separated by space"" ""space and tab"" { target *-*-* } .+3 } */
#define beta(a, b, c) \ 
	a, \	
	b, \ 	
	c

int x[] = {
   alpha(1, 2, 3),
   beta(4, 5, 6)
};
"
"/* Test that postfix attributes only apply to a single declared object.
   (decl_attributes used to chain them onto the end of the prefix attributes,
   which caused them to apply to other declarations as well.)  */
/* Origin: Joseph Myers <jsm28@cam.ac.uk>.  */
void __attribute__((__noreturn__)) foo (const char *, ...) __attribute__((__format__(__printf__, 1, 2))), bar (void);
","/* Test that postfix attributes only apply to a single declared object.
   (decl_attributes used to chain them onto the end of the prefix attributes,
   which caused them to apply to other declarations as well.)  */
/* Origin: Joseph Myers <jsm28@cam.ac.uk>.  */
void __attribute__((__noreturn__)) foo (const char *, ...) __attribute__((__format__(__printf__, 1, 2))), bar (void);
"
"/* PR middle-end/66429 */
/* { dg-do compile } */
/* { dg-options ""-O2 -fopenmp"" } */

float b[10][15][10];

__attribute__ ((noreturn)) void
noreturn (void)
{
  for (;;);
}

__attribute__ ((noinline, noclone)) void
foo (int n)
{
  int i;

#pragma omp parallel for simd schedule(static, 32) collapse(3)
  for (i = 0; i < 10; i++)
    for (int j = n; j < 8; j++)
      for (long k = -10; k < 10; k++)
	{
	  b[i][j][k] += 16;
	  noreturn ();
	  b[i][j][k] -= 32;
	}
}

__attribute__ ((noinline, noclone)) void
bar (void)
{
  int i;

#pragma omp parallel for simd schedule(static, 32)
  for (i = 0; i < 10; i++)
    {
      b[0][0][i] += 16;
      noreturn ();
      b[0][0][i] -= 32;
    }
}
","/* PR middle-end/66429 */
/* { dg-do compile } */
/* { dg-options ""-O2 -fopenmp"" } */

float b[10][15][10];

__attribute__ ((noreturn)) void
noreturn (void)
{
  for (;;);
}

__attribute__ ((noinline, noclone)) void
foo (int n)
{
  int i;

#pragma omp parallel for simd schedule(static, 32) collapse(3)
  for (i = 0; i < 10; i++)
    for (int j = n; j < 8; j++)
      for (long k = -10; k < 10; k++)
	{
	  b[i][j][k] += 16;
	  noreturn ();
	  b[i][j][k] -= 32;
	}
}

__attribute__ ((noinline, noclone)) void
bar (void)
{
  int i;

#pragma omp parallel for simd schedule(static, 32)
  for (i = 0; i < 10; i++)
    {
      b[0][0][i] += 16;
      noreturn ();
      b[0][0][i] -= 32;
    }
}
"
"/* { dg-do compile } */
/* { dg-options ""-O2 -funswitch-loops -fdump-tree-unswitch-details"" } */

void foo (float **a, float **b, float *c, int n, int m, int l)
{
  int i,j,k;
  float s;
  for (i=0; i<l; i++)
    for (j=0; j<n; j++)
      for (k=0; k<m; k++)
	c[i] += a[i][k] * b[k][j];
}

/* { dg-final { scan-tree-dump-times ""guard hoisted"" 3 ""unswitch"" } } */
/* { dg-final { scan-tree-dump-not ""Invalid sum"" ""unswitch"" } } */

","/* { dg-do compile } */
/* { dg-options ""-O2 -funswitch-loops -fdump-tree-unswitch-details"" } */

void foo (float **a, float **b, float *c, int n, int m, int l)
{
  int i,j,k;
  float s;
  for (i=0; i<l; i++)
    for (j=0; j<n; j++)
      for (k=0; k<m; k++)
	c[i] += a[i][k] * b[k][j];
}

/* { dg-final { scan-tree-dump-times ""guard hoisted"" 3 ""unswitch"" } } */
/* { dg-final { scan-tree-dump-not ""Invalid sum"" ""unswitch"" } } */

"
"/* { dg-do compile } */
/* { dg-options ""-O -fno-tree-forwprop -fno-tree-ccp -fdump-tree-fre1-details"" } */

_Complex float m;

void
foo (_Complex float x)
{    
  float r = __real x;
  float i = __imag x;
  _Complex float z;
  __real z = r;
  __imag z = i;
  m = z;
} 

void
bar (_Complex float x)
{    
  float r = __real x;
  float i = __imag x;
  _Complex float z = x;
  __real z = r;
  __imag z = i;
  m = z;
} 

/* We should CSE all the way to replace the stored value with x.  */
/* { dg-final { scan-tree-dump-times ""m = x_\\d\+\\(D\\);"" 2 ""fre1"" } } */
","/* { dg-do compile } */
/* { dg-options ""-O -fno-tree-forwprop -fno-tree-ccp -fdump-tree-fre1-details"" } */

_Complex float m;

void
foo (_Complex float x)
{    
  float r = __real x;
  float i = __imag x;
  _Complex float z;
  __real z = r;
  __imag z = i;
  m = z;
} 

void
bar (_Complex float x)
{    
  float r = __real x;
  float i = __imag x;
  _Complex float z = x;
  __real z = r;
  __imag z = i;
  m = z;
} 

/* We should CSE all the way to replace the stored value with x.  */
/* { dg-final { scan-tree-dump-times ""m = x_\\d\+\\(D\\);"" 2 ""fre1"" } } */
"
"/* { dg-options ""-mgp64 -mips16"" } */

#ifndef __GCC_HAVE_SYNC_COMPARE_AND_SWAP_1
#error nonono
#endif

#ifndef __GCC_HAVE_SYNC_COMPARE_AND_SWAP_2
#error nonono
#endif

#ifndef __GCC_HAVE_SYNC_COMPARE_AND_SWAP_4
#error nonono
#endif

#ifndef __GCC_HAVE_SYNC_COMPARE_AND_SWAP_8
#error nonono
#endif

#ifdef __GCC_HAVE_SYNC_COMPARE_AND_SWAP_16
#error nonono
#endif
","/* { dg-options ""-mgp64 -mips16"" } */

#ifndef __GCC_HAVE_SYNC_COMPARE_AND_SWAP_1
#error nonono
#endif

#ifndef __GCC_HAVE_SYNC_COMPARE_AND_SWAP_2
#error nonono
#endif

#ifndef __GCC_HAVE_SYNC_COMPARE_AND_SWAP_4
#error nonono
#endif

#ifndef __GCC_HAVE_SYNC_COMPARE_AND_SWAP_8
#error nonono
#endif

#ifdef __GCC_HAVE_SYNC_COMPARE_AND_SWAP_16
#error nonono
#endif
"
"/* PR c/79428 */
int i;
#pragma GCC pch_preprocess /* { dg-error ""'#pragma GCC pch_preprocess' must be first"" } */
","/* PR c/79428 */
int i;
#pragma GCC pch_preprocess /* { dg-error ""'#pragma GCC pch_preprocess' must be first"" } */
"
"/* PR debug/47881 */
/* { dg-do compile } */
/* { dg-options ""-O -fcompare-debug -fno-dce -funroll-loops -fno-web"" } */
/* { dg-xfail-if """" { powerpc-ibm-aix* } } */

extern int data[];

int
foo (int *t, int *f, int n)
{
  int i = 0, a, b, c, d;
  while (data[*f] && n)
    n--;
  for (; i < n; i += 4)
    {
      a = data[*(f++) & 0x7f];
      c = data[*(f++) & 0x7f];
      c = data[*(f++) & 0x7f];
      d = data[*(f++) & 0x7f];
      if ((a & 0x80) || (b & 0x80) || (c & 0x80) || (d & 0x80))
	return 1;
      *(t++) = 16;
    }
  return 0;
}
","/* PR debug/47881 */
/* { dg-do compile } */
/* { dg-options ""-O -fcompare-debug -fno-dce -funroll-loops -fno-web"" } */
/* { dg-xfail-if """" { powerpc-ibm-aix* } } */

extern int data[];

int
foo (int *t, int *f, int n)
{
  int i = 0, a, b, c, d;
  while (data[*f] && n)
    n--;
  for (; i < n; i += 4)
    {
      a = data[*(f++) & 0x7f];
      c = data[*(f++) & 0x7f];
      c = data[*(f++) & 0x7f];
      d = data[*(f++) & 0x7f];
      if ((a & 0x80) || (b & 0x80) || (c & 0x80) || (d & 0x80))
	return 1;
      *(t++) = 16;
    }
  return 0;
}
"
"/* { dg-options { -nostartfiles below100.o -Tbelow100.ld -O2 } } */
/* { dg-final { scan-assembler ""mov.w r.,32532"" } } */

#define SFR (*((volatile unsigned short*)0x7f14))
unsigned short *p = (unsigned short *) 0x7f14;

void
Do (void)
{
  SFR |= 0x0001;
}

int
main (void)
{
  *p = 0x1234;
  Do ();
  return (*p == 0x1235) ? 0 : 1;
}
","/* { dg-options { -nostartfiles below100.o -Tbelow100.ld -O2 } } */
/* { dg-final { scan-assembler ""mov.w r.,32532"" } } */

#define SFR (*((volatile unsigned short*)0x7f14))
unsigned short *p = (unsigned short *) 0x7f14;

void
Do (void)
{
  SFR |= 0x0001;
}

int
main (void)
{
  *p = 0x1234;
  Do ();
  return (*p == 0x1235) ? 0 : 1;
}
"
"/* { dg-do compile } */
/* { dg-options ""-mtune=btver2 -mmemcpy-strategy=rep_8byte:-1:noalign"" }

/* { dg-error ""strategy name 'rep_8byte' specified for option '-mmemcpy_strategy=' not supported for 32-bit code"" """" { target ia32 } 0 } */

struct U9
{
  unsigned a[9];
};

struct U9 u9;

void
foo ()
{
  u9 = (struct U9) {
    .a = {
      0xFF,
      0xFF,
      0xFF,
      0xFF,
      0xFF,
      0xFF,
      0xFF,
      0xFF,
      0xFF
    }
  };
}
","/* { dg-do compile } */
/* { dg-options ""-mtune=btver2 -mmemcpy-strategy=rep_8byte:-1:noalign"" }

/* { dg-error ""strategy name 'rep_8byte' specified for option '-mmemcpy_strategy=' not supported for 32-bit code"" """" { target ia32 } 0 } */

struct U9
{
  unsigned a[9];
};

struct U9 u9;

void
foo ()
{
  u9 = (struct U9) {
    .a = {
      0xFF,
      0xFF,
      0xFF,
      0xFF,
      0xFF,
      0xFF,
      0xFF,
      0xFF,
      0xFF
    }
  };
}
"
"#include <arm_neon.h>
#include ""arm-neon-ref.h""
#include ""compute-ref-data.h""


#define INSN_NAME vpmin
#define TEST_MSG ""VPMIN""

/* Expected results.  */
VECT_VAR_DECL(expected,int,8,8) [] = { 0xf0, 0xf2, 0xf4, 0xf6,
				       0xf0, 0xf2, 0xf4, 0xf6 };
VECT_VAR_DECL(expected,int,16,4) [] = { 0xfff0, 0xfff2, 0xfff0, 0xfff2 };
VECT_VAR_DECL(expected,int,32,2) [] = { 0xfffffff0, 0xfffffff0 };
VECT_VAR_DECL(expected,uint,8,8) [] = { 0xf0, 0xf2, 0xf4, 0xf6,
					0xf0, 0xf2, 0xf4, 0xf6 };
VECT_VAR_DECL(expected,uint,16,4) [] = { 0xfff0, 0xfff2, 0xfff0, 0xfff2 };
VECT_VAR_DECL(expected,uint,32,2) [] = { 0xfffffff0, 0xfffffff0 };
#if defined (__ARM_FEATURE_FP16_VECTOR_ARITHMETIC)
VECT_VAR_DECL(expected, hfloat, 16, 4) [] = { 0xcc00, 0xcb00, 0xcc00, 0xcb00 };
#endif
VECT_VAR_DECL(expected,hfloat,32,2) [] = { 0xc1800000, 0xc1800000 };

#include ""vpXXX.inc""
","#include <arm_neon.h>
#include ""arm-neon-ref.h""
#include ""compute-ref-data.h""


#define INSN_NAME vpmin
#define TEST_MSG ""VPMIN""

/* Expected results.  */
VECT_VAR_DECL(expected,int,8,8) [] = { 0xf0, 0xf2, 0xf4, 0xf6,
				       0xf0, 0xf2, 0xf4, 0xf6 };
VECT_VAR_DECL(expected,int,16,4) [] = { 0xfff0, 0xfff2, 0xfff0, 0xfff2 };
VECT_VAR_DECL(expected,int,32,2) [] = { 0xfffffff0, 0xfffffff0 };
VECT_VAR_DECL(expected,uint,8,8) [] = { 0xf0, 0xf2, 0xf4, 0xf6,
					0xf0, 0xf2, 0xf4, 0xf6 };
VECT_VAR_DECL(expected,uint,16,4) [] = { 0xfff0, 0xfff2, 0xfff0, 0xfff2 };
VECT_VAR_DECL(expected,uint,32,2) [] = { 0xfffffff0, 0xfffffff0 };
#if defined (__ARM_FEATURE_FP16_VECTOR_ARITHMETIC)
VECT_VAR_DECL(expected, hfloat, 16, 4) [] = { 0xcc00, 0xcb00, 0xcc00, 0xcb00 };
#endif
VECT_VAR_DECL(expected,hfloat,32,2) [] = { 0xc1800000, 0xc1800000 };

#include ""vpXXX.inc""
"
"/* PR tree-optimization/33993 */
/* Testcase by Martin Michlmayr <tbm@cyrius.com> */

void
init_full (char *array, int ny)
{
  int j;
  char acc = 128;
  for (j = 0; j < ny; j++)
    *array++ = acc++;
}
","/* PR tree-optimization/33993 */
/* Testcase by Martin Michlmayr <tbm@cyrius.com> */

void
init_full (char *array, int ny)
{
  int j;
  char acc = 128;
  for (j = 0; j < ny; j++)
    *array++ = acc++;
}
"
"/* Test we do not warn about initializing variable with address of self in the initialization. */
/* { dg-do compile } */
/* { dg-options ""-O -Wuninitialized"" } */

void g(void*);
void f()
{
  void *i = &i;
  g(i);
}
","/* Test we do not warn about initializing variable with address of self in the initialization. */
/* { dg-do compile } */
/* { dg-options ""-O -Wuninitialized"" } */

void g(void*);
void f()
{
  void *i = &i;
  g(i);
}
"
"/* { dg-do compile } */
/* { dg-options ""-O3"" } */
/* { dg-require-effective-target arm_v8_2a_fp16_scalar_ok } */
/* { dg-add-options arm_v8_2a_fp16_scalar } */

extern __fp16 foo ();
extern void bar (__fp16* x);

void f1 ()
{
  volatile __fp16 a = 17.0;
}


void f2 (__fp16 *a)
{
  *a = 17.0;
}

void f3 ()
{
  __fp16 b = foo ();
  b = 17.0;
  bar (&b);
}

__fp16 f4 ()
{
  __fp16 a = 0;
  __fp16 b = 1;
  __fp16 c = 2;
  __fp16 d = 4;

  __fp16 z = a + b;
  z = z + c;
  z = z - d;
  return z;
}

__fp16 f5 ()
{
  __fp16 a = 16;
  bar (&a);
  return a;
}

/* { dg-final { scan-assembler-times {fmov\th[0-9]+, #?1\.7e\+1}  3 } } */
/* { dg-final { scan-assembler-times {fmov\th[0-9]+, #?-1\.0e\+0} 1 } } */
/* { dg-final { scan-assembler-times {fmov\th[0-9]+, #?1\.6e\+1}  1 } } */
","/* { dg-do compile } */
/* { dg-options ""-O3"" } */
/* { dg-require-effective-target arm_v8_2a_fp16_scalar_ok } */
/* { dg-add-options arm_v8_2a_fp16_scalar } */

extern __fp16 foo ();
extern void bar (__fp16* x);

void f1 ()
{
  volatile __fp16 a = 17.0;
}


void f2 (__fp16 *a)
{
  *a = 17.0;
}

void f3 ()
{
  __fp16 b = foo ();
  b = 17.0;
  bar (&b);
}

__fp16 f4 ()
{
  __fp16 a = 0;
  __fp16 b = 1;
  __fp16 c = 2;
  __fp16 d = 4;

  __fp16 z = a + b;
  z = z + c;
  z = z - d;
  return z;
}

__fp16 f5 ()
{
  __fp16 a = 16;
  bar (&a);
  return a;
}

/* { dg-final { scan-assembler-times {fmov\th[0-9]+, #?1\.7e\+1}  3 } } */
/* { dg-final { scan-assembler-times {fmov\th[0-9]+, #?-1\.0e\+0} 1 } } */
/* { dg-final { scan-assembler-times {fmov\th[0-9]+, #?1\.6e\+1}  1 } } */
"
"/* Copyright (C) 2003, 2008 Free Software Foundation, Inc.  */

/* { dg-do preprocess } */
/* { dg-options ""-Wno-deprecated"" } */

/* This tests that our eagerness to apply the multiple include guard
   optimization to the #import doesn't stop us marking the file
   once-only.

   Neil Booth, 2 August 2003.  */

#include ""import1.h""
#import ""import1.h""
#undef IMPORT1_H
#define BUG
#include ""import1.h""
","/* Copyright (C) 2003, 2008 Free Software Foundation, Inc.  */

/* { dg-do preprocess } */
/* { dg-options ""-Wno-deprecated"" } */

/* This tests that our eagerness to apply the multiple include guard
   optimization to the #import doesn't stop us marking the file
   once-only.

   Neil Booth, 2 August 2003.  */

#include ""import1.h""
#import ""import1.h""
#undef IMPORT1_H
#define BUG
#include ""import1.h""
"
"/* Test for bogus diagnostics for dremf definition.  Although this
   definition is formally incorrect in ISO C, a GNU extension permits
   a prototype followed by unpromoted types in a function definition,
   so it should be permitted when the function is built in.  Bug
   16666.  Test with -pedantic-errors, where the problem should still
   be diagnosed.  */
/* { dg-do compile } */
/* { dg-options ""-pedantic-errors"" } */

float dremf (float, float); /* { dg-error ""prototype declaration"" } */

float
dremf (x, y)
     float x; /* { dg-error ""promoted argument 'x' doesn't match prototype"" } */
     float y; /* { dg-error ""promoted argument 'y' doesn't match prototype"" } */
{
  return x + y;
}
","/* Test for bogus diagnostics for dremf definition.  Although this
   definition is formally incorrect in ISO C, a GNU extension permits
   a prototype followed by unpromoted types in a function definition,
   so it should be permitted when the function is built in.  Bug
   16666.  Test with -pedantic-errors, where the problem should still
   be diagnosed.  */
/* { dg-do compile } */
/* { dg-options ""-pedantic-errors"" } */

float dremf (float, float); /* { dg-error ""prototype declaration"" } */

float
dremf (x, y)
     float x; /* { dg-error ""promoted argument 'x' doesn't match prototype"" } */
     float y; /* { dg-error ""promoted argument 'y' doesn't match prototype"" } */
{
  return x + y;
}
"
"/* { dg-do compile } */
/* { dg-options ""-O -fdump-tree-optimized"" } */

int f(int x){
  int y = x;
  int z = 0;
  return x / y - x % y + z / y;
}

/* { dg-final { scan-tree-dump ""return 1;"" ""optimized""} } */
","/* { dg-do compile } */
/* { dg-options ""-O -fdump-tree-optimized"" } */

int f(int x){
  int y = x;
  int z = 0;
  return x / y - x % y + z / y;
}

/* { dg-final { scan-tree-dump ""return 1;"" ""optimized""} } */
"
"/* { dg-do compile } */
/* { dg-options ""-O2 -save-temps"" } */

/* Make sure that bar is inlined into bam.  */

__attribute__ ((target (""arch=armv8-a+nocrc"")))
static int
bar (int a)
{
  return a - 6;
}

__attribute__ ((target (""cpu=cortex-a53+nocrc"")))
int
bam (int a)
{
  return a - bar (a);
}

/* { dg-final { scan-assembler-not ""bl.*bar"" } } */
","/* { dg-do compile } */
/* { dg-options ""-O2 -save-temps"" } */

/* Make sure that bar is inlined into bam.  */

__attribute__ ((target (""arch=armv8-a+nocrc"")))
static int
bar (int a)
{
  return a - 6;
}

__attribute__ ((target (""cpu=cortex-a53+nocrc"")))
int
bam (int a)
{
  return a - bar (a);
}

/* { dg-final { scan-assembler-not ""bl.*bar"" } } */
"
"typedef short type;

short
foo (type *sp, int a)
{
  type t;
  int i;

  t = sp[a];
  i = (int)(type)sp[a];
  if (i)
    return 0;
  return t;
}
","typedef short type;

short
foo (type *sp, int a)
{
  type t;
  int i;

  t = sp[a];
  i = (int)(type)sp[a];
  if (i)
    return 0;
  return t;
}
"
"/* { dg-do compile } */
/* { dg-options ""-O2 -fdump-tree-einline"" } */
/* { dg-require-effective-target alloca } */

void bar (char *);
int i;

static void
foo (void)
{
  char *p = __builtin_alloca (i);
  bar (p);
}

int
baz (void)
{
  foo ();	/* foo() should not be inlined here because it calls alloca */
  return 6;
}

/* { dg-final { scan-tree-dump-times ""Inlining foo into baz"" 0 ""einline""} } */
","/* { dg-do compile } */
/* { dg-options ""-O2 -fdump-tree-einline"" } */
/* { dg-require-effective-target alloca } */

void bar (char *);
int i;

static void
foo (void)
{
  char *p = __builtin_alloca (i);
  bar (p);
}

int
baz (void)
{
  foo ();	/* foo() should not be inlined here because it calls alloca */
  return 6;
}

/* { dg-final { scan-tree-dump-times ""Inlining foo into baz"" 0 ""einline""} } */
"
"/* This testcase caused on IA-32 -O2 endless loop in
   merge_blocks when trying to merge a basic block
   with itself.  */

void f (void)
{
  char *c;
  do
    {
      if (c)
	break;
    }
  while (1);
  if (!c)
    while (1)
      f ();
}
","/* This testcase caused on IA-32 -O2 endless loop in
   merge_blocks when trying to merge a basic block
   with itself.  */

void f (void)
{
  char *c;
  do
    {
      if (c)
	break;
    }
  while (1);
  if (!c)
    while (1)
      f ();
}
"
"/* { dg-do compile } */
/* { dg-require-effective-target arm_arch_v8a_ok } */
/* { dg-options ""-O2"" } */
/* { dg-add-options arm_arch_v8a } */

#include ""../aarch64/atomic-op-int.x""

/* { dg-final { scan-assembler-times ""ldrex\tr\[0-9\]+, \\\[r\[0-9\]+\\\]"" 6 } } */
/* { dg-final { scan-assembler-times ""strex\t...?, r\[0-9\]+, \\\[r\[0-9\]+\\\]"" 6 } } */
/* { dg-final { scan-assembler-not ""dmb"" } } */
","/* { dg-do compile } */
/* { dg-require-effective-target arm_arch_v8a_ok } */
/* { dg-options ""-O2"" } */
/* { dg-add-options arm_arch_v8a } */

#include ""../aarch64/atomic-op-int.x""

/* { dg-final { scan-assembler-times ""ldrex\tr\[0-9\]+, \\\[r\[0-9\]+\\\]"" 6 } } */
/* { dg-final { scan-assembler-times ""strex\t...?, r\[0-9\]+, \\\[r\[0-9\]+\\\]"" 6 } } */
/* { dg-final { scan-assembler-not ""dmb"" } } */
"
"/* { dg-options ""-mlock"" } */
/* { dg-do assemble } */
/* { dg-skip-if """" { arc6xx } } */

int f (void *p)
{
  int i;

  __asm__(""llock %0, [%1]\n\t""
	  ""scond %0, [%1]"" : ""=&r""(i) : ""r""(p));
  return i;
}
","/* { dg-options ""-mlock"" } */
/* { dg-do assemble } */
/* { dg-skip-if """" { arc6xx } } */

int f (void *p)
{
  int i;

  __asm__(""llock %0, [%1]\n\t""
	  ""scond %0, [%1]"" : ""=&r""(i) : ""r""(p));
  return i;
}
"
"/* { dg-do compile } */
/* { dg-options ""-mips32"" } */
/* { dg-final { scan-assembler-not ""\tsynci"" } } */
/* { dg-final { scan-assembler-not ""\tjr.hb"" } } */
/* { dg-final { scan-assembler ""_flush_cache|mips_sync_icache|_cacheflush"" } } */

void f()
{
  int size = 40;
  char *memory = __builtin_alloca(size);
  __builtin___clear_cache(memory, memory + size);
}

","/* { dg-do compile } */
/* { dg-options ""-mips32"" } */
/* { dg-final { scan-assembler-not ""\tsynci"" } } */
/* { dg-final { scan-assembler-not ""\tjr.hb"" } } */
/* { dg-final { scan-assembler ""_flush_cache|mips_sync_icache|_cacheflush"" } } */

void f()
{
  int size = 40;
  char *memory = __builtin_alloca(size);
  __builtin___clear_cache(memory, memory + size);
}

"
"/* PR optimization/7153 */
/* Verify that GCC doesn't promote a register when its
   lifetime is not limited to one basic block. */

void f(char);
void g(void);

void scale(void)
{
  int width;
  char bytes;
  char *src;

  if (width)
  {
    bytes = *src;
    g();
    width *= bytes;
  }

  f(bytes);
}
","/* PR optimization/7153 */
/* Verify that GCC doesn't promote a register when its
   lifetime is not limited to one basic block. */

void f(char);
void g(void);

void scale(void)
{
  int width;
  char bytes;
  char *src;

  if (width)
  {
    bytes = *src;
    g();
    width *= bytes;
  }

  f(bytes);
}
"
"/* PR tree-optimization/55281 */
/* { dg-do compile } */

static inline float
bar (float k, float j)
{
  float l = 0.0f;
  if (k > j)
    l = k;
  float t = k / j;
  float v = t * t;
  if (k == 0)
    v = 0.0f;
  if (t > 0.4f)
    v += 0.7;
  if (l != 0)
    v = 1.5 - v;
  return v;
}

void
foo (int *a, int b, float *d, float *e, int *f)
{
  int i, l;
  for (l = 0; l != b; ++l)
    for (i = 0; i != 8; ++i)
      f[i] = e[i] + bar (a[i], d[i]);
}

","/* PR tree-optimization/55281 */
/* { dg-do compile } */

static inline float
bar (float k, float j)
{
  float l = 0.0f;
  if (k > j)
    l = k;
  float t = k / j;
  float v = t * t;
  if (k == 0)
    v = 0.0f;
  if (t > 0.4f)
    v += 0.7;
  if (l != 0)
    v = 1.5 - v;
  return v;
}

void
foo (int *a, int b, float *d, float *e, int *f)
{
  int i, l;
  for (l = 0; l != b; ++l)
    for (i = 0; i != 8; ++i)
      f[i] = e[i] + bar (a[i], d[i]);
}

"
"/* PR target/79568 */
/* { dg-do compile } */
/* { dg-options ""-mno-avx512vl -mavx512bw -O2"" } */

#pragma GCC push_options
#pragma GCC target (""avx512vl,avx512bw"")
void
foo (char *x, char __attribute__ ((__vector_size__(32))) *y, int z)
{
  __builtin_ia32_storedquqi256_mask (x, *y, z);
}
#pragma GCC pop_options

void
bar (char *x, char __attribute__ ((__vector_size__(32))) *y, int z)
{
  __builtin_ia32_storedquqi256_mask (x, *y, z); /* { dg-error ""needs isa option"" } */
}
","/* PR target/79568 */
/* { dg-do compile } */
/* { dg-options ""-mno-avx512vl -mavx512bw -O2"" } */

#pragma GCC push_options
#pragma GCC target (""avx512vl,avx512bw"")
void
foo (char *x, char __attribute__ ((__vector_size__(32))) *y, int z)
{
  __builtin_ia32_storedquqi256_mask (x, *y, z);
}
#pragma GCC pop_options

void
bar (char *x, char __attribute__ ((__vector_size__(32))) *y, int z)
{
  __builtin_ia32_storedquqi256_mask (x, *y, z); /* { dg-error ""needs isa option"" } */
}
"
"/* PR c/79428 */
/* { dg-options ""-fopenacc"" } */
void
foo ()
{
#pragma acc routine /* { dg-error "".#pragma acc routine. must be at file scope|expected"" } */
","/* PR c/79428 */
/* { dg-options ""-fopenacc"" } */
void
foo ()
{
#pragma acc routine /* { dg-error "".#pragma acc routine. must be at file scope|expected"" } */
"
"/* { dg-do run } */
/* { dg-skip-if """" { *-*-* } { ""-march=*"" } { ""-march=amdfam10"" } } */
/* { dg-options ""-march=amdfam10 -mno-sse4"" } */

extern void abort (void);

int
main ()
{
#if !defined __SSE__
  abort ();
#endif
#if !defined __SSE2__
  abort ();
#endif
#if !defined __SSE3__
  abort ();
#endif
#if defined __SSSE3__
  abort ();
#endif
#if defined __SSE4_1__
  abort ();
#endif
#if defined __SSE4_2__
  abort ();
#endif
#if !defined __SSE4A__
  abort ();
#endif
#if defined __AVX__
  abort ();
#endif
#if defined __FMA4__
  abort ();
#endif
  return 0;
}
","/* { dg-do run } */
/* { dg-skip-if """" { *-*-* } { ""-march=*"" } { ""-march=amdfam10"" } } */
/* { dg-options ""-march=amdfam10 -mno-sse4"" } */

extern void abort (void);

int
main ()
{
#if !defined __SSE__
  abort ();
#endif
#if !defined __SSE2__
  abort ();
#endif
#if !defined __SSE3__
  abort ();
#endif
#if defined __SSSE3__
  abort ();
#endif
#if defined __SSE4_1__
  abort ();
#endif
#if defined __SSE4_2__
  abort ();
#endif
#if !defined __SSE4A__
  abort ();
#endif
#if defined __AVX__
  abort ();
#endif
#if defined __FMA4__
  abort ();
#endif
  return 0;
}
"
"/* { dg-do compile { target *-*-linux* } } */
/* { dg-options ""-O2 -fno-pic -fno-plt"" } */

extern int bar (void);

int
foo (void)
{
  return bar ();
}

/* { dg-final { scan-assembler ""jmp\[ \t\]*.bar@GOTPCREL"" { target { ! ia32 } } } } */
/* { dg-final { scan-assembler ""jmp\[ \t\]*.bar@GOT"" { target { ia32 && got32x_reloc } } } } */
","/* { dg-do compile { target *-*-linux* } } */
/* { dg-options ""-O2 -fno-pic -fno-plt"" } */

extern int bar (void);

int
foo (void)
{
  return bar ();
}

/* { dg-final { scan-assembler ""jmp\[ \t\]*.bar@GOTPCREL"" { target { ! ia32 } } } } */
/* { dg-final { scan-assembler ""jmp\[ \t\]*.bar@GOT"" { target { ia32 && got32x_reloc } } } } */
"
"/* { dg-do run } */
/* { dg-options ""-O3 -mpower8-vector -Wno-psabi"" } */
/* { dg-require-effective-target lp64 } */
/* { dg-require-effective-target p8vector_hw } */

#ifndef CHECK_H
#define CHECK_H ""sse2-check.h""
#endif

#include CHECK_H

#ifndef TEST
#define TEST sse2_test_paddd_1
#endif

#include <emmintrin.h>

static __m128i
__attribute__((noinline, unused))
test (__m128i s1, __m128i s2)
{
  __asm("""" : ""+v""(s1), ""+v""(s2));
  return _mm_add_epi32 (s1, s2); 
}

static void
TEST (void)
{
  union128i_d u, s1, s2;
  int e[4];
  int i;
   
  s1.x = _mm_set_epi32 (30,90,-80,-40);
  s2.x = _mm_set_epi32 (76, -100, -34, -78);
  u.x = test (s1.x, s2.x); 
   
  for (i = 0; i < 4; i++)
     e[i] = s1.a[i] + s2.a[i];

  if (check_union128i_d (u, e))
    abort ();
}
","/* { dg-do run } */
/* { dg-options ""-O3 -mpower8-vector -Wno-psabi"" } */
/* { dg-require-effective-target lp64 } */
/* { dg-require-effective-target p8vector_hw } */

#ifndef CHECK_H
#define CHECK_H ""sse2-check.h""
#endif

#include CHECK_H

#ifndef TEST
#define TEST sse2_test_paddd_1
#endif

#include <emmintrin.h>

static __m128i
__attribute__((noinline, unused))
test (__m128i s1, __m128i s2)
{
  __asm("""" : ""+v""(s1), ""+v""(s2));
  return _mm_add_epi32 (s1, s2); 
}

static void
TEST (void)
{
  union128i_d u, s1, s2;
  int e[4];
  int i;
   
  s1.x = _mm_set_epi32 (30,90,-80,-40);
  s2.x = _mm_set_epi32 (76, -100, -34, -78);
  u.x = test (s1.x, s2.x); 
   
  for (i = 0; i < 4; i++)
     e[i] = s1.a[i] + s2.a[i];

  if (check_union128i_d (u, e))
    abort ();
}
"
"/* { dg-do compile } */
/* { dg-options ""-O3"" } */

unsigned int a[64], b[64], c[64], d[64], e[64];

void
foo ()
{
  int i;
  for (i = 0; i < 64; i++)
    {
      d[i] = a[i];
      e[i] = ((b[i] < e[i]) != !c[i]) && !a[i];
    }
}
","/* { dg-do compile } */
/* { dg-options ""-O3"" } */

unsigned int a[64], b[64], c[64], d[64], e[64];

void
foo ()
{
  int i;
  for (i = 0; i < 64; i++)
    {
      d[i] = a[i];
      e[i] = ((b[i] < e[i]) != !c[i]) && !a[i];
    }
}
"
"/* { dg-do compile { target { powerpc*-*-* } } } */
/* { dg-skip-if ""do not override -mcpu"" { powerpc*-*-* } { ""-mcpu=*"" } { ""-mcpu=power9"" } } */
/* { dg-require-effective-target powerpc_p9vector_ok } */
/* { dg-options ""-mcpu=power9"" } */

#include <altivec.h>
#include <stdbool.h>

bool
test_data_class (double *p)
{
  double source = *p;

  return scalar_test_data_class (source, 256);	/* { dg-error ""argument 2 must be a 7-bit unsigned literal"" } */
}

","/* { dg-do compile { target { powerpc*-*-* } } } */
/* { dg-skip-if ""do not override -mcpu"" { powerpc*-*-* } { ""-mcpu=*"" } { ""-mcpu=power9"" } } */
/* { dg-require-effective-target powerpc_p9vector_ok } */
/* { dg-options ""-mcpu=power9"" } */

#include <altivec.h>
#include <stdbool.h>

bool
test_data_class (double *p)
{
  double source = *p;

  return scalar_test_data_class (source, 256);	/* { dg-error ""argument 2 must be a 7-bit unsigned literal"" } */
}

"
"/* { dg-do run } */
/* { dg-options ""-O2 -mavx512f"" } */
/* { dg-require-effective-target avx512f } */

#include ""avx512f-check.h""

static __m512i
__attribute__ ((noinline))
foo (int *v)
{
  return _mm512_set_epi32 (v[15], v[14], v[13], v[12],
			   v[11], v[10], v[9], v[8],
			   v[7], v[6], v[5], v[4],
			   v[3], v[2], v[1], v[0]);
}

static __m512i
__attribute__ ((noinline))
foo_r (int *v)
{
  return _mm512_setr_epi32 (v[0], v[1], v[2], v[3],
			    v[4], v[5], v[6], v[7],
			    v[8], v[9], v[10], v[11],
			    v[12], v[13], v[14], v[15]);
}

static void
avx512f_test (void)
{
  int v[16] = { 19832468, 2134, 6576856, 6678,
		8723467, 54646, 234566, 12314,
		786784, 77575, 645245, 234555,
		9487733, 411244, 12344, 86533 };
  union512i_d res;

  res.x = foo (v);

  if (check_union512i_d (res, v))
    abort ();

  res.x = _mm512_setzero_si512 ();

  res.x = foo_r (v);

  if (check_union512i_d (res, v))
    abort ();
}
","/* { dg-do run } */
/* { dg-options ""-O2 -mavx512f"" } */
/* { dg-require-effective-target avx512f } */

#include ""avx512f-check.h""

static __m512i
__attribute__ ((noinline))
foo (int *v)
{
  return _mm512_set_epi32 (v[15], v[14], v[13], v[12],
			   v[11], v[10], v[9], v[8],
			   v[7], v[6], v[5], v[4],
			   v[3], v[2], v[1], v[0]);
}

static __m512i
__attribute__ ((noinline))
foo_r (int *v)
{
  return _mm512_setr_epi32 (v[0], v[1], v[2], v[3],
			    v[4], v[5], v[6], v[7],
			    v[8], v[9], v[10], v[11],
			    v[12], v[13], v[14], v[15]);
}

static void
avx512f_test (void)
{
  int v[16] = { 19832468, 2134, 6576856, 6678,
		8723467, 54646, 234566, 12314,
		786784, 77575, 645245, 234555,
		9487733, 411244, 12344, 86533 };
  union512i_d res;

  res.x = foo (v);

  if (check_union512i_d (res, v))
    abort ();

  res.x = _mm512_setzero_si512 ();

  res.x = foo_r (v);

  if (check_union512i_d (res, v))
    abort ();
}
"
"/* { dg-do run } */
/* { dg-require-effective-target avx } */
/* { dg-options ""-O2 -mfpmath=sse -mavx"" } */

#define CHECK_H ""avx-check.h""
#define TEST avx_test

#include ""sse-divss-1.c""
","/* { dg-do run } */
/* { dg-require-effective-target avx } */
/* { dg-options ""-O2 -mfpmath=sse -mavx"" } */

#define CHECK_H ""avx-check.h""
#define TEST avx_test

#include ""sse-divss-1.c""
"
"/* { dg-do compile } */
/* { dg-options ""-fgnu-tm"" } */
/* { dg-add-options bind_pic_locally } */

void f_extern (void);
void f_first (void);
void f_later (void);

extern int x;

void f_first (void) { x++; }

void __attribute__((transaction_safe))
test_safe (void)
{
  f_extern ();		/* { dg-error ""unsafe function call"" } */
  f_first ();
  f_later ();
}

void __attribute__((transaction_may_cancel_outer))
test_mco (void)
{
  f_extern ();		/* { dg-error ""unsafe function call"" } */
  f_first ();
  f_later ();
}

void
test_atomic (void)
{
  __transaction_atomic {
    f_extern ();	/* { dg-error ""unsafe function call"" } */
    f_first ();
    f_later ();
  }
  __transaction_relaxed {
    f_extern ();
    f_first ();
    f_later ();
  }
  __transaction_atomic [[outer]] {
    f_extern ();	/* { dg-error ""unsafe function call"" } */
    f_first ();
    f_later ();
  }
}

void f_later () { f_first(); test_safe(); }
","/* { dg-do compile } */
/* { dg-options ""-fgnu-tm"" } */
/* { dg-add-options bind_pic_locally } */

void f_extern (void);
void f_first (void);
void f_later (void);

extern int x;

void f_first (void) { x++; }

void __attribute__((transaction_safe))
test_safe (void)
{
  f_extern ();		/* { dg-error ""unsafe function call"" } */
  f_first ();
  f_later ();
}

void __attribute__((transaction_may_cancel_outer))
test_mco (void)
{
  f_extern ();		/* { dg-error ""unsafe function call"" } */
  f_first ();
  f_later ();
}

void
test_atomic (void)
{
  __transaction_atomic {
    f_extern ();	/* { dg-error ""unsafe function call"" } */
    f_first ();
    f_later ();
  }
  __transaction_relaxed {
    f_extern ();
    f_first ();
    f_later ();
  }
  __transaction_atomic [[outer]] {
    f_extern ();	/* { dg-error ""unsafe function call"" } */
    f_first ();
    f_later ();
  }
}

void f_later () { f_first(); test_safe(); }
"
"/*  Testcase from <marcus@jet.franken.de>
    PR optimization/15245
    This used to ICE as convert was used
    in tree-ssa-phiopt which created non gimple
    code.   */

char *f(char *x, int flag)
{
    char *ret = (char*)0;


    if( x > (char*)1 ) {
      if(x)
        return (char*)0;
    } else {
      if( flag & 1 )
        ret = (char*)1;
      flag |= 2;
    }
    return ret;
}
","/*  Testcase from <marcus@jet.franken.de>
    PR optimization/15245
    This used to ICE as convert was used
    in tree-ssa-phiopt which created non gimple
    code.   */

char *f(char *x, int flag)
{
    char *ret = (char*)0;


    if( x > (char*)1 ) {
      if(x)
        return (char*)0;
    } else {
      if( flag & 1 )
        ret = (char*)1;
      flag |= 2;
    }
    return ret;
}
"
"/* PR tree-optimization/48739 */
/* { dg-do compile } */
/* { dg-require-effective-target pthread } */
/* { dg-options ""-O1 -ftree-parallelize-loops=2 -fno-tree-dominator-opts"" } */

extern int g;
extern void bar (void);

int
foo (int x)
{
  int a, b, *c = (int *) 0;
  for (a = 0; a < 10; ++a)
    {
      bar ();
      for (b = 0; b < 5; ++b)
	{
	  x = 0;
	  c = &x;
	  g = 1;
	}
    }
  *c = x;
  for (x = 0; x != 10; x++)
    ;
  return g;
}
","/* PR tree-optimization/48739 */
/* { dg-do compile } */
/* { dg-require-effective-target pthread } */
/* { dg-options ""-O1 -ftree-parallelize-loops=2 -fno-tree-dominator-opts"" } */

extern int g;
extern void bar (void);

int
foo (int x)
{
  int a, b, *c = (int *) 0;
  for (a = 0; a < 10; ++a)
    {
      bar ();
      for (b = 0; b < 5; ++b)
	{
	  x = 0;
	  c = &x;
	  g = 1;
	}
    }
  *c = x;
  for (x = 0; x != 10; x++)
    ;
  return g;
}
"
"/* Copyright (C) 2000 Free Software Foundation, Inc.  */

/* { dg-do preprocess } */

/* Test warnings for backslash-space-newline.
   Source: Neil Booth. 6 Dec 2000.  */

foo \  
bar
/* { dg-warning ""separated by space"" """" { target *-*-* } .-2 } */

/* foo \   
   bar */
/* { dg-bogus ""separated by space"" """" { target *-*-* } .-2 } */
","/* Copyright (C) 2000 Free Software Foundation, Inc.  */

/* { dg-do preprocess } */

/* Test warnings for backslash-space-newline.
   Source: Neil Booth. 6 Dec 2000.  */

foo \  
bar
/* { dg-warning ""separated by space"" """" { target *-*-* } .-2 } */

/* foo \   
   bar */
/* { dg-bogus ""separated by space"" """" { target *-*-* } .-2 } */
"
"/* PR middle-end/83977 */
/* { dg-do compile } */

void bar (void);

#pragma omp declare simd uniform (b) linear(a:b)
int
foo (int a, int b)
{
  a = a + 1;
/* This function can't be called from simd loops,
   because it violates declare simd restrictions.
   We shouldn't ICE on it though, nor attempt to generate
   simd clones for the *omp_fn* functions.  */
  #pragma omp parallel
  bar ();  
  return a;
}
","/* PR middle-end/83977 */
/* { dg-do compile } */

void bar (void);

#pragma omp declare simd uniform (b) linear(a:b)
int
foo (int a, int b)
{
  a = a + 1;
/* This function can't be called from simd loops,
   because it violates declare simd restrictions.
   We shouldn't ICE on it though, nor attempt to generate
   simd clones for the *omp_fn* functions.  */
  #pragma omp parallel
  bar ();  
  return a;
}
"
"struct foo
{
  char a;
} foo[100];

main ()
{
  foo[1].a = '1';
  foo[2].a = '2';
}
","struct foo
{
  char a;
} foo[100];

main ()
{
  foo[1].a = '1';
  foo[2].a = '2';
}
"
"#include ""decl-5.h""
static int (*t)(void) = foo;
","#include ""decl-5.h""
static int (*t)(void) = foo;
"
"/* { dg-do compile } */
/* { dg-require-effective-target arm_arch_v8m_base_ok } */
/* { dg-options ""-O2 -fno-ipa-icf"" } */
/* { dg-add-options arm_arch_v8m_base } */

#include ""../aarch64/atomic-comp-swap-release-acquire.x""

/* { dg-final { scan-assembler-times ""ldaex"" 4 } } */
/* { dg-final { scan-assembler-times ""stlex"" 4 } } */
/* { dg-final { scan-assembler-not ""dmb"" } } */
","/* { dg-do compile } */
/* { dg-require-effective-target arm_arch_v8m_base_ok } */
/* { dg-options ""-O2 -fno-ipa-icf"" } */
/* { dg-add-options arm_arch_v8m_base } */

#include ""../aarch64/atomic-comp-swap-release-acquire.x""

/* { dg-final { scan-assembler-times ""ldaex"" 4 } } */
/* { dg-final { scan-assembler-times ""stlex"" 4 } } */
/* { dg-final { scan-assembler-not ""dmb"" } } */
"
"/* { dg-do run } */
/* { dg-options ""-O3"" } */
/* { dg-require-effective-target ilp32 } */

typedef unsigned int u32;
typedef unsigned long long u64;

u64 __attribute__((noinline))
foo (u32 high, u32 low)
{
  return ((u64)high << 32) | low;
}

u32 __attribute__((noinline))
right (u64 t)
{
  return (u32)(t >> 32);
}

u64 __attribute__((noinline))
left (u32 t)
{
  return (u64)t << 32;
}

u32 __attribute__((noinline))
right2 (u64 t)
{
  return (u32)(t >> 40);
}

u64 __attribute__((noinline))
left2 (u32 t)
{
  return (u64)t << 40;
}

u64 __attribute__((noinline))
zeroextend (u32 t)
{
  return (u64)t;
}

extern void abort ();

int
main ()
{
  if (foo (13000, 12000) != 55834574860000ULL)
    abort ();

  if (right (55834574860000ULL) != 13000)
    abort ();

  if (left (13000) != 55834574848000ULL)
    abort ();

  if (right2 (55834574860000ULL) != 50)
    abort ();

  if (left2 (13000) != 14293651161088000ULL)
    abort ();

  if (zeroextend (13000) != 13000ULL)
    abort ();

  return 0;
}
","/* { dg-do run } */
/* { dg-options ""-O3"" } */
/* { dg-require-effective-target ilp32 } */

typedef unsigned int u32;
typedef unsigned long long u64;

u64 __attribute__((noinline))
foo (u32 high, u32 low)
{
  return ((u64)high << 32) | low;
}

u32 __attribute__((noinline))
right (u64 t)
{
  return (u32)(t >> 32);
}

u64 __attribute__((noinline))
left (u32 t)
{
  return (u64)t << 32;
}

u32 __attribute__((noinline))
right2 (u64 t)
{
  return (u32)(t >> 40);
}

u64 __attribute__((noinline))
left2 (u32 t)
{
  return (u64)t << 40;
}

u64 __attribute__((noinline))
zeroextend (u32 t)
{
  return (u64)t;
}

extern void abort ();

int
main ()
{
  if (foo (13000, 12000) != 55834574860000ULL)
    abort ();

  if (right (55834574860000ULL) != 13000)
    abort ();

  if (left (13000) != 55834574848000ULL)
    abort ();

  if (right2 (55834574860000ULL) != 50)
    abort ();

  if (left2 (13000) != 14293651161088000ULL)
    abort ();

  if (zeroextend (13000) != 13000ULL)
    abort ();

  return 0;
}
"
"static inline int
mod (int a, int n)
{
  return a >= n ? a % n : a;
}
void dpara(int);
void opticurve (int m)
{
  int i;
  for (i = 0; i < m; i++)
    {
        dpara(mod (i - 1, m));
    }
}
","static inline int
mod (int a, int n)
{
  return a >= n ? a % n : a;
}
void dpara(int);
void opticurve (int m)
{
  int i;
  for (i = 0; i < m; i++)
    {
        dpara(mod (i - 1, m));
    }
}
"
"/* { dg-do compile { target *-*-linux* } } */
/* { dg-options ""-fno-pic -O2 -fcf-protection -pg -mfentry -mrecord-mcount -mnop-mcount -fasynchronous-unwind-tables"" } */
/* { dg-final { scan-assembler-times {\t\.cfi_startproc\n\tendbr} 1 } } */

extern int bar (int);

int
foo (int i)
{
  return bar (i);
}
","/* { dg-do compile { target *-*-linux* } } */
/* { dg-options ""-fno-pic -O2 -fcf-protection -pg -mfentry -mrecord-mcount -mnop-mcount -fasynchronous-unwind-tables"" } */
/* { dg-final { scan-assembler-times {\t\.cfi_startproc\n\tendbr} 1 } } */

extern int bar (int);

int
foo (int i)
{
  return bar (i);
}
"
"#define PTR1 * * * * * * * * * *
#define PTR2 PTR1 PTR1 PTR1 PTR1 PTR1 PTR1 PTR1 PTR1 PTR1 PTR1
#define PTR3 PTR2 PTR2 PTR2 PTR2 PTR2 PTR2 PTR2 PTR2 PTR2 PTR2
#define PTR4 PTR3 PTR3 PTR3 PTR3 PTR3 PTR3 PTR3 PTR3 PTR3 PTR3
#define PTR5 PTR4 PTR4 PTR4 PTR4 PTR4 PTR4 PTR4 PTR4 PTR4 PTR4
#define PTR6 PTR5 PTR5 PTR5 PTR5 PTR5 PTR5 PTR5 PTR5 PTR5 PTR5

int PTR4 q3_var = 0;
","#define PTR1 * * * * * * * * * *
#define PTR2 PTR1 PTR1 PTR1 PTR1 PTR1 PTR1 PTR1 PTR1 PTR1 PTR1
#define PTR3 PTR2 PTR2 PTR2 PTR2 PTR2 PTR2 PTR2 PTR2 PTR2 PTR2
#define PTR4 PTR3 PTR3 PTR3 PTR3 PTR3 PTR3 PTR3 PTR3 PTR3 PTR3
#define PTR5 PTR4 PTR4 PTR4 PTR4 PTR4 PTR4 PTR4 PTR4 PTR4 PTR4
#define PTR6 PTR5 PTR5 PTR5 PTR5 PTR5 PTR5 PTR5 PTR5 PTR5 PTR5

int PTR4 q3_var = 0;
"
"/* { dg-do compile } */
/* { dg-options ""-Wall -O2"" } */

static int xyzzy __attribute__((__used__)) = 1; 

void foo()
{
  int x __attribute__((__used__)); /* { dg-warning ""attribute ignored|unused variable"" } */
}

/* { dg-final { scan-assembler ""xyzzy"" } } */
","/* { dg-do compile } */
/* { dg-options ""-Wall -O2"" } */

static int xyzzy __attribute__((__used__)) = 1; 

void foo()
{
  int x __attribute__((__used__)); /* { dg-warning ""attribute ignored|unused variable"" } */
}

/* { dg-final { scan-assembler ""xyzzy"" } } */
"
"/* { dg-options ""-fpeephole2 -mtune=m14k (-mmicromips)"" } */
/* { dg-skip-if ""code quality test"" { *-*-* } { ""-O0"" } { """" } } */

void MICROMIPS
foo (int *r4, int r5, int r6)
{
  r6 *= r6;
  r4[512] = r5;
  r4[513] = r6;
  {
    register int r5asm asm (""$5"") = r5;
    register int r6asm asm (""$6"") = r6;
    asm (""#foo"" : ""=m"" (r4[2]) : ""d"" (r5asm), ""d"" (r6asm));
  }
}

/* { dg-final { scan-assembler-not ""\tswp"" } }*/
","/* { dg-options ""-fpeephole2 -mtune=m14k (-mmicromips)"" } */
/* { dg-skip-if ""code quality test"" { *-*-* } { ""-O0"" } { """" } } */

void MICROMIPS
foo (int *r4, int r5, int r6)
{
  r6 *= r6;
  r4[512] = r5;
  r4[513] = r6;
  {
    register int r5asm asm (""$5"") = r5;
    register int r6asm asm (""$6"") = r6;
    asm (""#foo"" : ""=m"" (r4[2]) : ""d"" (r5asm), ""d"" (r6asm));
  }
}

/* { dg-final { scan-assembler-not ""\tswp"" } }*/
"
"typedef enum { POSITION_ASIS, POSITION_UNSPECIFIED } unit_position;

typedef enum { STATUS_UNKNOWN, STATUS_UNSPECIFIED } unit_status;

typedef struct
{
  unit_position position;
  unit_status status;
} unit_flags;

extern void abort (void);

void
new_unit (unit_flags * flags)
{
  if (flags->status == STATUS_UNSPECIFIED)
    flags->status = STATUS_UNKNOWN;

  if (flags->position == POSITION_UNSPECIFIED)
    flags->position = POSITION_ASIS;

  switch (flags->status)
    {
    case STATUS_UNKNOWN:
      break;

    default:
      abort ();
    }
}

int main()
{
  unit_flags f;
  f.status = STATUS_UNSPECIFIED;
  new_unit (&f);
  return 0;
}
","typedef enum { POSITION_ASIS, POSITION_UNSPECIFIED } unit_position;

typedef enum { STATUS_UNKNOWN, STATUS_UNSPECIFIED } unit_status;

typedef struct
{
  unit_position position;
  unit_status status;
} unit_flags;

extern void abort (void);

void
new_unit (unit_flags * flags)
{
  if (flags->status == STATUS_UNSPECIFIED)
    flags->status = STATUS_UNKNOWN;

  if (flags->position == POSITION_UNSPECIFIED)
    flags->position = POSITION_ASIS;

  switch (flags->status)
    {
    case STATUS_UNKNOWN:
      break;

    default:
      abort ();
    }
}

int main()
{
  unit_flags f;
  f.status = STATUS_UNSPECIFIED;
  new_unit (&f);
  return 0;
}
"
"/* { dg-do compile } */
/* { dg-options """" } */

void
foo (void)
{
  int i = 0;
  asm ("""" : : : ""memory"");
  asm ("""" : : : );
  asm ("""" : : ""r"" (i));
  asm ("""" : : );
  asm ("""" : ""=r"" (i));
  asm ("""" : );
  asm ("""");
}
","/* { dg-do compile } */
/* { dg-options """" } */

void
foo (void)
{
  int i = 0;
  asm ("""" : : : ""memory"");
  asm ("""" : : : );
  asm ("""" : : ""r"" (i));
  asm ("""" : : );
  asm ("""" : ""=r"" (i));
  asm ("""" : );
  asm ("""");
}
"
"/* Test the vqdmlsl_high_laneq_s32 AArch64 SIMD intrinsic.  */

/* { dg-do compile } */
/* { dg-options ""-save-temps -O3 -fno-inline"" } */

#include ""arm_neon.h""

int64x2_t
t_vqdmlsl_high_laneq_s32 (int64x2_t a, int32x4_t b, int32x4_t c)
{
  return vqdmlsl_high_laneq_s32 (a, b, c, 0);
}

/* { dg-final { scan-assembler-times ""sqdmlsl2\[ \t\]+\[vV\]\[0-9\]+\.2\[dD\], ?\[vV\]\[0-9\]+\.4\[sS\], ?\[vV\]\[0-9\]+\.\[sS\]\\\[0\\\]\n"" 1 } } */
","/* Test the vqdmlsl_high_laneq_s32 AArch64 SIMD intrinsic.  */

/* { dg-do compile } */
/* { dg-options ""-save-temps -O3 -fno-inline"" } */

#include ""arm_neon.h""

int64x2_t
t_vqdmlsl_high_laneq_s32 (int64x2_t a, int32x4_t b, int32x4_t c)
{
  return vqdmlsl_high_laneq_s32 (a, b, c, 0);
}

/* { dg-final { scan-assembler-times ""sqdmlsl2\[ \t\]+\[vV\]\[0-9\]+\.2\[dD\], ?\[vV\]\[0-9\]+\.4\[sS\], ?\[vV\]\[0-9\]+\.\[sS\]\\\[0\\\]\n"" 1 } } */
"
"/* { dg-do assemble } */

#include <arm_neon.h>

uint8_t
test_vget_lane_u8_before (uint8x8_t in)
{
  /* { dg-error ""lane -1 out of range 0 - 7"" """" {target *-*-*} 0 } */
  return vget_lane_u8 (in, -1);
}

uint8_t
test_vget_lane_u8_beyond (uint8x8_t in)
{
  /* { dg-error ""lane 8 out of range 0 - 7"" """" {target *-*-*} 0 } */
  return vget_lane_u8 (in, 8);
}
","/* { dg-do assemble } */

#include <arm_neon.h>

uint8_t
test_vget_lane_u8_before (uint8x8_t in)
{
  /* { dg-error ""lane -1 out of range 0 - 7"" """" {target *-*-*} 0 } */
  return vget_lane_u8 (in, -1);
}

uint8_t
test_vget_lane_u8_beyond (uint8x8_t in)
{
  /* { dg-error ""lane 8 out of range 0 - 7"" """" {target *-*-*} 0 } */
  return vget_lane_u8 (in, 8);
}
"
"/* { dg-require-effective-target vect_int } */

#define SIGNEDNESS signed
#define BIAS 1

#include ""vect-avg-5.c""

/* { dg-final { scan-tree-dump ""vect_recog_average_pattern: detected"" ""vect"" } } */
/* { dg-final { scan-tree-dump {\.AVG_CEIL} ""vect"" { target vect_avg_qi } } } */
/* { dg-final { scan-tree-dump-not {vector\([^\n]*short} ""vect"" { target vect_avg_qi } } } */
/* { dg-final { scan-tree-dump-times ""vectorized 1 loop"" 1 ""vect"" { target vect_avg_qi } } } */
","/* { dg-require-effective-target vect_int } */

#define SIGNEDNESS signed
#define BIAS 1

#include ""vect-avg-5.c""

/* { dg-final { scan-tree-dump ""vect_recog_average_pattern: detected"" ""vect"" } } */
/* { dg-final { scan-tree-dump {\.AVG_CEIL} ""vect"" { target vect_avg_qi } } } */
/* { dg-final { scan-tree-dump-not {vector\([^\n]*short} ""vect"" { target vect_avg_qi } } } */
/* { dg-final { scan-tree-dump-times ""vectorized 1 loop"" 1 ""vect"" { target vect_avg_qi } } } */
"
"/* Test that stack protection is done on chosen functions. */

/* { dg-do compile { target i?86-*-* x86_64-*-* rs6000-*-* s390x-*-* } } */
/* { dg-options ""-O2 -fstack-protector-all"" } */

/* This test checks the presence of __stack_chk_fail function in assembler.
 * Compiler generates _stack_chk_fail_local (wrapper) calls instead for PIC.
 */
/* { dg-require-effective-target nonpic } */


#pragma GCC push_options
#pragma GCC optimize (""-fno-stack-protector"")

int foo()
{
  return 0;
}

#pragma GCC pop_options

int main() { foo (); }

/* { dg-final { scan-assembler-times ""stack_chk_fail"" 1 } } */
","/* Test that stack protection is done on chosen functions. */

/* { dg-do compile { target i?86-*-* x86_64-*-* rs6000-*-* s390x-*-* } } */
/* { dg-options ""-O2 -fstack-protector-all"" } */

/* This test checks the presence of __stack_chk_fail function in assembler.
 * Compiler generates _stack_chk_fail_local (wrapper) calls instead for PIC.
 */
/* { dg-require-effective-target nonpic } */


#pragma GCC push_options
#pragma GCC optimize (""-fno-stack-protector"")

int foo()
{
  return 0;
}

#pragma GCC pop_options

int main() { foo (); }

/* { dg-final { scan-assembler-times ""stack_chk_fail"" 1 } } */
"
"/* { dg-do compile } */
/* { dg-require-effective-target arm_arch_v8m_base_ok } */
/* { dg-options ""-O2"" } */
/* { dg-add-options arm_arch_v8m_base } */

#include ""../aarch64/atomic-op-relaxed.x""

/* { dg-final { scan-assembler-times ""ldrex\tr\[0-9\]+, \\\[r\[0-9\]+\\\]"" 6 } } */
/* { dg-final { scan-assembler-times ""strex\t...?, r\[0-9\]+, \\\[r\[0-9\]+\\\]"" 6 } } */
/* { dg-final { scan-assembler-not ""dmb"" } } */
","/* { dg-do compile } */
/* { dg-require-effective-target arm_arch_v8m_base_ok } */
/* { dg-options ""-O2"" } */
/* { dg-add-options arm_arch_v8m_base } */

#include ""../aarch64/atomic-op-relaxed.x""

/* { dg-final { scan-assembler-times ""ldrex\tr\[0-9\]+, \\\[r\[0-9\]+\\\]"" 6 } } */
/* { dg-final { scan-assembler-times ""strex\t...?, r\[0-9\]+, \\\[r\[0-9\]+\\\]"" 6 } } */
/* { dg-final { scan-assembler-not ""dmb"" } } */
"
"/* { dg-skip-if """" { ! { arm_thumb1_ok || arm_thumb2_ok } } } */
/* { dg-options ""-mthumb -Os"" }  */
/* { dg-final { scan-assembler-not ""ldr"" } } */

unsigned int foo (unsigned int i )
{
  return i | 0xff000000;
}
","/* { dg-skip-if """" { ! { arm_thumb1_ok || arm_thumb2_ok } } } */
/* { dg-options ""-mthumb -Os"" }  */
/* { dg-final { scan-assembler-not ""ldr"" } } */

unsigned int foo (unsigned int i )
{
  return i | 0xff000000;
}
"
"extern char letters[26+1];
char letter;
int letter_number;
char letters[] = ""AbCdefghiJklmNopQrStuVwXyZ"";

static void
pad_home1 ()
{
  letter = letters[letter_number =
		   letters[letter_number + 1] ? letter_number +
		   1 : 0];
}

","extern char letters[26+1];
char letter;
int letter_number;
char letters[] = ""AbCdefghiJklmNopQrStuVwXyZ"";

static void
pad_home1 ()
{
  letter = letters[letter_number =
		   letters[letter_number + 1] ? letter_number +
		   1 : 0];
}

"
"/* PR 18987.  This caused an assembler error because we emitted "".restore sp""
   twice.  */
/* { dg-do compile } */
/* { dg-options ""-O2 -fno-omit-frame-pointer -w"" } */
/* { dg-final { scan-assembler-times ""\\.restore sp"" 1 } } */

static void do_date (char *);  
void rfc822_date (char *date)  
{  
  do_date (date);
}
","/* PR 18987.  This caused an assembler error because we emitted "".restore sp""
   twice.  */
/* { dg-do compile } */
/* { dg-options ""-O2 -fno-omit-frame-pointer -w"" } */
/* { dg-final { scan-assembler-times ""\\.restore sp"" 1 } } */

static void do_date (char *);  
void rfc822_date (char *date)  
{  
  do_date (date);
}
"
"void foo(int x)
{
  if (x > 3)
    {;}
  else
    bar();
  x = 9;
}

main()
{
  int j;

  foo(j);
  return j;
}
","void foo(int x)
{
  if (x > 3)
    {;}
  else
    bar();
  x = 9;
}

main()
{
  int j;

  foo(j);
  return j;
}
"
"/* { dg-do compile } */
/* { dg-options ""-O2"" } */

/* Check that an X-reg UBFIZ can be simplified into a W-reg LSL.  */

long long
f2 (long long x)
{
  return (x << 5) & 0xffffffff;
}

/* { dg-final { scan-assembler ""lsl\tw"" } } */
/* { dg-final { scan-assembler-not ""ubfiz\tx"" } } */
","/* { dg-do compile } */
/* { dg-options ""-O2"" } */

/* Check that an X-reg UBFIZ can be simplified into a W-reg LSL.  */

long long
f2 (long long x)
{
  return (x << 5) & 0xffffffff;
}

/* { dg-final { scan-assembler ""lsl\tw"" } } */
/* { dg-final { scan-assembler-not ""ubfiz\tx"" } } */
"
"/* { dg-do compile } */
/* { dg-options ""-w -fdump-tree-gimple"" } */

/* Things that should be folded.  */

struct { long base; int tail; void * volatile ptr; } *s;
int foo1a (void) { return (s == &s->base); }
int foo1b (void) { return (&s->base == s); }
int foo2 (void) { return ((void *)s == (void *) &s->base); }
int foo4 (void) { return s->base == s->base; }
int foo5 (void) { return &s->ptr == &s->ptr; }
int foo6 (void) { return &s->ptr != &s->ptr; }
int foo7 (void) { return &s->base != &s->ptr; }

struct { union { int i; short s } u; } x;
int foo8 (void) { return &x.u.i == &x.u.s; }

/* { dg-final { scan-tree-dump-times ""= 0"" 1 ""gimple"" } } */
/* { dg-final { scan-tree-dump-times ""= 1"" 7 ""gimple"" } } */
","/* { dg-do compile } */
/* { dg-options ""-w -fdump-tree-gimple"" } */

/* Things that should be folded.  */

struct { long base; int tail; void * volatile ptr; } *s;
int foo1a (void) { return (s == &s->base); }
int foo1b (void) { return (&s->base == s); }
int foo2 (void) { return ((void *)s == (void *) &s->base); }
int foo4 (void) { return s->base == s->base; }
int foo5 (void) { return &s->ptr == &s->ptr; }
int foo6 (void) { return &s->ptr != &s->ptr; }
int foo7 (void) { return &s->base != &s->ptr; }

struct { union { int i; short s } u; } x;
int foo8 (void) { return &x.u.i == &x.u.s; }

/* { dg-final { scan-tree-dump-times ""= 0"" 1 ""gimple"" } } */
/* { dg-final { scan-tree-dump-times ""= 1"" 7 ""gimple"" } } */
"
"/* Origin: <URL:http://gcc.gnu.org/ml/gcc-patches/2000-12/msg01384.html>
   from Fred Fish <fnf@geekgadgets.org>.  See also PR c/1625.  */

#include <stdbool.h>

struct { int x; bool y; } foo = { 0, false };
","/* Origin: <URL:http://gcc.gnu.org/ml/gcc-patches/2000-12/msg01384.html>
   from Fred Fish <fnf@geekgadgets.org>.  See also PR c/1625.  */

#include <stdbool.h>

struct { int x; bool y; } foo = { 0, false };
"
"/* { dg-do compile } */
/* { dg-options ""-mavx512f -O2"" } */
/* { dg-final { scan-assembler-times ""vfmadd...ss\[ \\t\]+\[^\n\]*\{rn-sae\}\[^\{\n\]*%xmm\[0-9\]+(?:\n|\[ \\t\]+#)"" 1 } } */

#include <immintrin.h>

volatile __m128 a, b, c;

void extern
avx512f_test (void)
{
  a = _mm_fmadd_round_ss (a, b, c, _MM_FROUND_TO_NEAREST_INT | _MM_FROUND_NO_EXC);
}
","/* { dg-do compile } */
/* { dg-options ""-mavx512f -O2"" } */
/* { dg-final { scan-assembler-times ""vfmadd...ss\[ \\t\]+\[^\n\]*\{rn-sae\}\[^\{\n\]*%xmm\[0-9\]+(?:\n|\[ \\t\]+#)"" 1 } } */

#include <immintrin.h>

volatile __m128 a, b, c;

void extern
avx512f_test (void)
{
  a = _mm_fmadd_round_ss (a, b, c, _MM_FROUND_TO_NEAREST_INT | _MM_FROUND_NO_EXC);
}
"
"/* { dg-do compile } */

struct S { int s; };

void
foo (void)
{
  for (;;)
    ;
}

struct S
bar (void)
{
  struct S s = { 99 };
  return s;
}

void
baz (int i)
{
  struct S s[1];
  s[0] = bar ();
  bar ();
  foo ();
}

","/* { dg-do compile } */

struct S { int s; };

void
foo (void)
{
  for (;;)
    ;
}

struct S
bar (void)
{
  struct S s = { 99 };
  return s;
}

void
baz (int i)
{
  struct S s[1];
  s[0] = bar ();
  bar ();
  foo ();
}

"
"/* { dg-do compile } */
/* { dg-options ""-mavx2 -O2"" } */
/* { dg-final { scan-assembler ""vpminsb\[ \\t\]+\[^\n\]*%ymm\[0-9\]"" } } */

#include <immintrin.h>

volatile __m256i x;

void extern
avx2_test (void)
{
  x = _mm256_min_epi8 (x, x);
}
","/* { dg-do compile } */
/* { dg-options ""-mavx2 -O2"" } */
/* { dg-final { scan-assembler ""vpminsb\[ \\t\]+\[^\n\]*%ymm\[0-9\]"" } } */

#include <immintrin.h>

volatile __m256i x;

void extern
avx2_test (void)
{
  x = _mm256_min_epi8 (x, x);
}
"
"/* { dg-do compile } */
/* { dg-options ""-fgnu-tm -fdump-tree-tmlower"" } */

char array[4];

void *memset(void *s, int c, __SIZE_TYPE__);

int main()
{
  __transaction_atomic {
    memset(array, 'b', sizeof(4));
  }
  return 0;
}

/* { dg-final { scan-tree-dump-times ""GTMA_HAVE_STORE"" 1 ""tmlower"" } } */
","/* { dg-do compile } */
/* { dg-options ""-fgnu-tm -fdump-tree-tmlower"" } */

char array[4];

void *memset(void *s, int c, __SIZE_TYPE__);

int main()
{
  __transaction_atomic {
    memset(array, 'b', sizeof(4));
  }
  return 0;
}

/* { dg-final { scan-tree-dump-times ""GTMA_HAVE_STORE"" 1 ""tmlower"" } } */
"
"/* { dg-do run } */
/* { dg-options ""-mavx2 -O2"" } */
/* { dg-require-effective-target avx2 } */

#include ""avx2-check.h""
#include <string.h>

#define NUM 10

static void
init_pbroadcastq128 (long long int *src, int seed)
{
  int i, sign = 1;

  for (i = 0; i < 2; i++)
    {
      src[i] = (i + seed) * (i + seed) * sign;
      sign = -sign;
    }
}

static void
calc_pbroadcastq128 (long long int *src, long long int *dst)
{
  int i;

  for (i = 0; i < 2; i++)
    dst[i] = src[0];
}

static void
avx2_test (void)
{
  union128i_q src, dst;
  long long int dst_ref[2];
  int i;

  for (i = 0; i < NUM; i++)
    {
      init_pbroadcastq128 (src.a, i);

      dst.x = _mm_broadcastq_epi64 (src.x);
      calc_pbroadcastq128 (src.a, dst_ref);

      if (check_union128i_q (dst, dst_ref))
	abort ();
    }
}
","/* { dg-do run } */
/* { dg-options ""-mavx2 -O2"" } */
/* { dg-require-effective-target avx2 } */

#include ""avx2-check.h""
#include <string.h>

#define NUM 10

static void
init_pbroadcastq128 (long long int *src, int seed)
{
  int i, sign = 1;

  for (i = 0; i < 2; i++)
    {
      src[i] = (i + seed) * (i + seed) * sign;
      sign = -sign;
    }
}

static void
calc_pbroadcastq128 (long long int *src, long long int *dst)
{
  int i;

  for (i = 0; i < 2; i++)
    dst[i] = src[0];
}

static void
avx2_test (void)
{
  union128i_q src, dst;
  long long int dst_ref[2];
  int i;

  for (i = 0; i < NUM; i++)
    {
      init_pbroadcastq128 (src.a, i);

      dst.x = _mm_broadcastq_epi64 (src.x);
      calc_pbroadcastq128 (src.a, dst_ref);

      if (check_union128i_q (dst, dst_ref))
	abort ();
    }
}
"
"int foo (void)
{
  int i, a;

  a = 30;

  #pragma omp parallel for lastprivate (a)
  for (i = 0; i < 10; i++)
    a = a + i;

  return a;
}
","int foo (void)
{
  int i, a;

  a = 30;

  #pragma omp parallel for lastprivate (a)
  for (i = 0; i < 10; i++)
    a = a + i;

  return a;
}
"
"/* { dg-options ""-O3 -fgraphite-identity"" } */

typedef struct {
  unsigned int avail_out;
  void *state;
} stream;

typedef struct {
  stream* test;
  int num;
} state_in;

int test_in ( stream *test, int action )
{
  state_in* tst;
  if (test == ((void *)0)) return (-2);
  if (tst == ((void *)0)) return (-2);
  if (tst->test != test) return (-2);
 jump_here:
  switch (tst->num) {
  case 1:
    return (-1);
  case 2:
    if (action == 0) {
    }
    if (action == 1) {
      goto jump_here;
    }
  }
  return 0;
}
","/* { dg-options ""-O3 -fgraphite-identity"" } */

typedef struct {
  unsigned int avail_out;
  void *state;
} stream;

typedef struct {
  stream* test;
  int num;
} state_in;

int test_in ( stream *test, int action )
{
  state_in* tst;
  if (test == ((void *)0)) return (-2);
  if (tst == ((void *)0)) return (-2);
  if (tst->test != test) return (-2);
 jump_here:
  switch (tst->num) {
  case 1:
    return (-1);
  case 2:
    if (action == 0) {
    }
    if (action == 1) {
      goto jump_here;
    }
  }
  return 0;
}
"
"/* PR opt/7130 */
#define TYPE long

void
scale (TYPE *alpha, TYPE *x, int n)
{
  int i, ix;

  if (*alpha != 1)
    for (i = 0, ix = 0; i < n; i++, ix += 2)
      {
	TYPE tmpr, tmpi;
	tmpr = *alpha * x[ix];
	tmpi = *alpha * x[ix + 1];
	x[ix] = tmpr;
	x[ix + 1] = tmpi;
      }
}

int
main (void)
{
  int i;
  TYPE x[10];
  TYPE alpha = 2;

  for (i = 0; i < 10; i++)
    x[i] = i;

  scale (&alpha, x, 5);

  if (x[9] != 18)
    abort ();

  return 0;
}
","/* PR opt/7130 */
#define TYPE long

void
scale (TYPE *alpha, TYPE *x, int n)
{
  int i, ix;

  if (*alpha != 1)
    for (i = 0, ix = 0; i < n; i++, ix += 2)
      {
	TYPE tmpr, tmpi;
	tmpr = *alpha * x[ix];
	tmpi = *alpha * x[ix + 1];
	x[ix] = tmpr;
	x[ix + 1] = tmpi;
      }
}

int
main (void)
{
  int i;
  TYPE x[10];
  TYPE alpha = 2;

  for (i = 0; i < 10; i++)
    x[i] = i;

  scale (&alpha, x, 5);

  if (x[9] != 18)
    abort ();

  return 0;
}
"
"/* { dg-do run } */
/* { dg-require-effective-target avx } */
/* { dg-options ""-O2 -mavx"" } */

#include ""avx-check.h""

static __m256
__attribute__((noinline, unused))
test (float *e)
{
  return _mm256_loadu_ps (e);
}

void static
avx_test (void)
{
  union256 u;
  float e [8]  = {24.43, 68.346, 43.35, 546.46, 46.79, 82.78, 82.7, 9.4};

  u.x = test (e);

  if (check_union256 (u, e))
    abort ();
}
","/* { dg-do run } */
/* { dg-require-effective-target avx } */
/* { dg-options ""-O2 -mavx"" } */

#include ""avx-check.h""

static __m256
__attribute__((noinline, unused))
test (float *e)
{
  return _mm256_loadu_ps (e);
}

void static
avx_test (void)
{
  union256 u;
  float e [8]  = {24.43, 68.346, 43.35, 546.46, 46.79, 82.78, 82.7, 9.4};

  u.x = test (e);

  if (check_union256 (u, e))
    abort ();
}
"
"/* { dg-do compile { target powerpc-ibm-aix* } } */

extern struct { int a, b, c, d; } v;
extern int w;

void
foo (void)
{
  int e1 = v.a;
  int e2 = w;
  int e3 = v.b;
  int e4 = v.c;
  int e5 = v.d;
  __asm__ volatile ("""" : : ""nro"" (e1), ""nro"" (e2), ""nro"" (e3), ""nro"" (e4), ""nro"" (e5));
}

","/* { dg-do compile { target powerpc-ibm-aix* } } */

extern struct { int a, b, c, d; } v;
extern int w;

void
foo (void)
{
  int e1 = v.a;
  int e2 = w;
  int e3 = v.b;
  int e4 = v.c;
  int e5 = v.d;
  __asm__ volatile ("""" : : ""nro"" (e1), ""nro"" (e2), ""nro"" (e3), ""nro"" (e4), ""nro"" (e5));
}

"
"void
foo (void)
{
#pragma acc parallel loop tile (2, 3)
  for (short i = 0; i < 10; ++i)
    for (short j = 0; j < 10; ++j)
      ;
}
","void
foo (void)
{
#pragma acc parallel loop tile (2, 3)
  for (short i = 0; i < 10; ++i)
    for (short j = 0; j < 10; ++j)
      ;
}
"
"/* { dg-do run } */
/* { dg-options ""-O2 -msse2"" } */
/* { dg-require-effective-target sse2 } */
#include ""sse2-check.h""
#include <xmmintrin.h>
extern void abort();
int untrue = 0;
typedef union {
  __v4sf v;
  float f[4];
} u;
void foo (u, u) __attribute__((noinline));
void foo (u a, u b) {
  if (b.f[0] != 7.0 || b.f[1] != 8.0 || b.f[2] != 3.0 || b.f[3] != 4.0)
    abort();
}
void bar (__v4sf, __v4sf) __attribute__((noinline));
void bar (__v4sf a __attribute((unused)), __v4sf b __attribute((unused))) { untrue = 0;}
__v4sf setupa () __attribute((noinline));
__v4sf setupa () { __v4sf t = { 1.0, 2.0, 3.0, 4.0 }; return t; }
__v4sf setupb () __attribute((noinline));
__v4sf setupb () { __v4sf t = { 5.0, 6.0, 7.0, 8.0 }; return t; }
void __attribute__((noinline))
sse2_test(void) {
  u a, b;
  a.v = setupa ();
  b.v = setupb ();
  if (untrue)
    bar(a.v, b.v);
  b.v = (__v4sf) _mm_movehl_ps ((__m128)a.v, (__m128)b.v);
  foo (a, b);
}
","/* { dg-do run } */
/* { dg-options ""-O2 -msse2"" } */
/* { dg-require-effective-target sse2 } */
#include ""sse2-check.h""
#include <xmmintrin.h>
extern void abort();
int untrue = 0;
typedef union {
  __v4sf v;
  float f[4];
} u;
void foo (u, u) __attribute__((noinline));
void foo (u a, u b) {
  if (b.f[0] != 7.0 || b.f[1] != 8.0 || b.f[2] != 3.0 || b.f[3] != 4.0)
    abort();
}
void bar (__v4sf, __v4sf) __attribute__((noinline));
void bar (__v4sf a __attribute((unused)), __v4sf b __attribute((unused))) { untrue = 0;}
__v4sf setupa () __attribute((noinline));
__v4sf setupa () { __v4sf t = { 1.0, 2.0, 3.0, 4.0 }; return t; }
__v4sf setupb () __attribute((noinline));
__v4sf setupb () { __v4sf t = { 5.0, 6.0, 7.0, 8.0 }; return t; }
void __attribute__((noinline))
sse2_test(void) {
  u a, b;
  a.v = setupa ();
  b.v = setupb ();
  if (untrue)
    bar(a.v, b.v);
  b.v = (__v4sf) _mm_movehl_ps ((__m128)a.v, (__m128)b.v);
  foo (a, b);
}
"
"/* { dg-do run } */
/* { dg-options ""-O2 -msse"" } */
/* { dg-require-effective-target sse } */

#include ""sse-check.h""

#ifdef DEBUG
#include <stdio.h>
#endif

#include <xmmintrin.h>

static void
__attribute__((noinline))
check (__m128 x, float *v, int j)
{
  union
    {
      __m128 x;
      float f[4];
    } u;
  unsigned int i;

  u.x = x;
  
  for (i = 0; i < sizeof (u) / sizeof (v[0]); i++)
    if (i == j)
      {
	if (v[i] != u.f[i])
	  {
#ifdef DEBUG
	    printf (""%i: %f != %f\n"", i, v[i], u.f[i]);
#endif
	    abort ();
	  }
      }
    else if (u.f[i] != 0)
      {
#ifdef DEBUG
	printf (""%i: %f != 0\n"", i, u.f[i]);
#endif
	abort ();
      }
}

static void
__attribute__((noinline))
test (float *v)
{
  __m128 x;

  x = _mm_set_ps (0, 0, 0, v[0]);
  check (x, v, 0);
  x = _mm_set_ps (0, 0, v[1], 0);
  check (x, v, 1);
  x = _mm_set_ps (0, v[2], 0, 0);
  check (x, v, 2);
  x = _mm_set_ps (v[3], 0, 0, 0);
  check (x, v, 3);
}

static void
sse_test (void)
{
  float v[4] = { -3, 2, 1, 9 };
  test (v);
}
","/* { dg-do run } */
/* { dg-options ""-O2 -msse"" } */
/* { dg-require-effective-target sse } */

#include ""sse-check.h""

#ifdef DEBUG
#include <stdio.h>
#endif

#include <xmmintrin.h>

static void
__attribute__((noinline))
check (__m128 x, float *v, int j)
{
  union
    {
      __m128 x;
      float f[4];
    } u;
  unsigned int i;

  u.x = x;
  
  for (i = 0; i < sizeof (u) / sizeof (v[0]); i++)
    if (i == j)
      {
	if (v[i] != u.f[i])
	  {
#ifdef DEBUG
	    printf (""%i: %f != %f\n"", i, v[i], u.f[i]);
#endif
	    abort ();
	  }
      }
    else if (u.f[i] != 0)
      {
#ifdef DEBUG
	printf (""%i: %f != 0\n"", i, u.f[i]);
#endif
	abort ();
      }
}

static void
__attribute__((noinline))
test (float *v)
{
  __m128 x;

  x = _mm_set_ps (0, 0, 0, v[0]);
  check (x, v, 0);
  x = _mm_set_ps (0, 0, v[1], 0);
  check (x, v, 1);
  x = _mm_set_ps (0, v[2], 0, 0);
  check (x, v, 2);
  x = _mm_set_ps (v[3], 0, 0, 0);
  check (x, v, 3);
}

static void
sse_test (void)
{
  float v[4] = { -3, 2, 1, 9 };
  test (v);
}
"
"/* Test that {,x,e,p,t,s,w,a,b,i}mmintrin.h, mm3dnow.h, fma4intrin.h,
   xopintrin.h, abmintrin.h, bmiintrin.h, tbmintrin.h, lwpintrin.h,
   popcntintrin.h gfniintrin.h and mm_malloc.h are usable
   with -O -std=c89 -pedantic-errors.  */
/* { dg-do compile } */
/* { dg-options ""-O -std=c89 -pedantic-errors -march=k8 -msse4a -m3dnow -mavx -mavx2 -mfma4 -mxop -maes -mpclmul -mpopcnt -mabm -mlzcnt -mbmi -mbmi2 -mtbm -mlwp -mfsgsbase -mrdrnd -mf16c -mfma -mrtm -mrdseed -mprfchw -madx -mfxsr -mxsaveopt -mavx512f -mavx512er -mavx512cd -mavx512pf -msha -mprefetchwt1 -mxsavec -mxsaves -mclflushopt -mavx512bw -mavx512dq -mavx512vl -mavx512vbmi -mavx512ifma -mavx5124fmaps -mavx5124vnniw -mavx512vpopcntdq -mclwb -mmwaitx -mclzero -mpku -msgx -mrdpid -mgfni -mavx512bitalg -mpconfig -mwbnoinvd"" } */

#include <x86intrin.h>

int dummy;
","/* Test that {,x,e,p,t,s,w,a,b,i}mmintrin.h, mm3dnow.h, fma4intrin.h,
   xopintrin.h, abmintrin.h, bmiintrin.h, tbmintrin.h, lwpintrin.h,
   popcntintrin.h gfniintrin.h and mm_malloc.h are usable
   with -O -std=c89 -pedantic-errors.  */
/* { dg-do compile } */
/* { dg-options ""-O -std=c89 -pedantic-errors -march=k8 -msse4a -m3dnow -mavx -mavx2 -mfma4 -mxop -maes -mpclmul -mpopcnt -mabm -mlzcnt -mbmi -mbmi2 -mtbm -mlwp -mfsgsbase -mrdrnd -mf16c -mfma -mrtm -mrdseed -mprfchw -madx -mfxsr -mxsaveopt -mavx512f -mavx512er -mavx512cd -mavx512pf -msha -mprefetchwt1 -mxsavec -mxsaves -mclflushopt -mavx512bw -mavx512dq -mavx512vl -mavx512vbmi -mavx512ifma -mavx5124fmaps -mavx5124vnniw -mavx512vpopcntdq -mclwb -mmwaitx -mclzero -mpku -msgx -mrdpid -mgfni -mavx512bitalg -mpconfig -mwbnoinvd"" } */

#include <x86intrin.h>

int dummy;
"
"/* { dg-skip-if ""not yet"" { c++ } } */

void
f (void)
{
  struct { int i; } *p;
#pragma acc data copyout(p) if(1) if(1) /* { dg-error ""too many 'if' clauses"" } */
  ;
#pragma acc update device(p) if(*p) /* { dg-error ""used struct type value where scalar is required"" } */
}
","/* { dg-skip-if ""not yet"" { c++ } } */

void
f (void)
{
  struct { int i; } *p;
#pragma acc data copyout(p) if(1) if(1) /* { dg-error ""too many 'if' clauses"" } */
  ;
#pragma acc update device(p) if(*p) /* { dg-error ""used struct type value where scalar is required"" } */
}
"
"/* { dg-do compile } */
/* { dg-options ""-w -Wno-psabi"" } */

typedef int v4si __attribute__ ((vector_size (16)));

int
foo (v4si v)
{
  return v[~0UL];
}
","/* { dg-do compile } */
/* { dg-options ""-w -Wno-psabi"" } */

typedef int v4si __attribute__ ((vector_size (16)));

int
foo (v4si v)
{
  return v[~0UL];
}
"
"#include <arm_neon.h>

/* { dg-do compile } */
/* { dg-skip-if """" { *-*-* } { ""-fno-fat-lto-objects"" } } */

void
f_vst3_lane_s8 (int8_t * p, int8x8x3_t v)
{
  /* { dg-error ""lane 8 out of range 0 - 7"" """" { target *-*-* } 0 } */
  vst3_lane_s8 (p, v, 8);
  /* { dg-error ""lane -1 out of range 0 - 7"" """" { target *-*-* } 0 } */
  vst3_lane_s8 (p, v, -1);
  return;
}
","#include <arm_neon.h>

/* { dg-do compile } */
/* { dg-skip-if """" { *-*-* } { ""-fno-fat-lto-objects"" } } */

void
f_vst3_lane_s8 (int8_t * p, int8x8x3_t v)
{
  /* { dg-error ""lane 8 out of range 0 - 7"" """" { target *-*-* } 0 } */
  vst3_lane_s8 (p, v, 8);
  /* { dg-error ""lane -1 out of range 0 - 7"" """" { target *-*-* } 0 } */
  vst3_lane_s8 (p, v, -1);
  return;
}
"
"/* { dg-do compile } */
/* { dg-require-effective-target arm_crypto_ok } */
/* { dg-add-options arm_crypto } */

#include ""arm_neon.h""

int
foo (void)
{
  uint32x4_t a = {0xd, 0xe, 0xa, 0xd};
  uint32x4_t b = {0, 1, 2, 3};
  uint32x4_t c = {3, 2, 1, 0};

  uint32x4_t res = vsha256hq_u32 (a, b, c);
  return res[0];
}

/* { dg-final { scan-assembler ""sha256h.32\tq\[0-9\]+, q\[0-9\]+, q\[0-9\]"" } } */
","/* { dg-do compile } */
/* { dg-require-effective-target arm_crypto_ok } */
/* { dg-add-options arm_crypto } */

#include ""arm_neon.h""

int
foo (void)
{
  uint32x4_t a = {0xd, 0xe, 0xa, 0xd};
  uint32x4_t b = {0, 1, 2, 3};
  uint32x4_t c = {3, 2, 1, 0};

  uint32x4_t res = vsha256hq_u32 (a, b, c);
  return res[0];
}

/* { dg-final { scan-assembler ""sha256h.32\tq\[0-9\]+, q\[0-9\]+, q\[0-9\]"" } } */
"
"/* { dg-do run { target { powerpc*-*-* && vmx_hw } } } */
/* { dg-do compile { target { powerpc*-*-* && { ! vmx_hw } } } } */
/* { dg-require-effective-target powerpc_altivec_ok } */
/* { dg-options ""-maltivec"" } */
/* Test the vec_splats and vec_promote VMX intrinsics.  */
#include <altivec.h>
    
extern void abort (void);
        
vector int a = {0, 0, 0, 0};
int main1(int t) __attribute__((noinline));
int main1(int t)
{ 
  int i;
  vector int b = vec_splats(0);
  if (__builtin_memcmp (&a, &b, sizeof(vector int)))
    abort ();
  
  b = vec_splats(t);
  if (__builtin_memcmp (&a, &b, sizeof(vector int)))
    abort ();
  
  b = vec_promote(0, 1);
  if (vec_extract (b, 1) != 0)
    abort ();
  
  b = vec_promote(t, t);
  if (vec_extract (b, t) != 0)
    abort ();
  
  return 0;
} 
    
int main(void)
{ 
  return main1 (0);
}
","/* { dg-do run { target { powerpc*-*-* && vmx_hw } } } */
/* { dg-do compile { target { powerpc*-*-* && { ! vmx_hw } } } } */
/* { dg-require-effective-target powerpc_altivec_ok } */
/* { dg-options ""-maltivec"" } */
/* Test the vec_splats and vec_promote VMX intrinsics.  */
#include <altivec.h>
    
extern void abort (void);
        
vector int a = {0, 0, 0, 0};
int main1(int t) __attribute__((noinline));
int main1(int t)
{ 
  int i;
  vector int b = vec_splats(0);
  if (__builtin_memcmp (&a, &b, sizeof(vector int)))
    abort ();
  
  b = vec_splats(t);
  if (__builtin_memcmp (&a, &b, sizeof(vector int)))
    abort ();
  
  b = vec_promote(0, 1);
  if (vec_extract (b, 1) != 0)
    abort ();
  
  b = vec_promote(t, t);
  if (vec_extract (b, t) != 0)
    abort ();
  
  return 0;
} 
    
int main(void)
{ 
  return main1 (0);
}
"
"/* PR30949 */
/* { dg-do compile } */
/* { dg-options ""-pedantic-errors"" } */

int func (int x);
void recv (int (* funcptr) (double x)); /* { dg-message ""note: expected 'int .\\\*..double.' but argument is of type 'int .\\\*..int.'"" } */
void call (void)
{
  recv (func); /* { dg-error ""passing argument 1 of 'recv' from incompatible pointer type"" } */
}

","/* PR30949 */
/* { dg-do compile } */
/* { dg-options ""-pedantic-errors"" } */

int func (int x);
void recv (int (* funcptr) (double x)); /* { dg-message ""note: expected 'int .\\\*..double.' but argument is of type 'int .\\\*..int.'"" } */
void call (void)
{
  recv (func); /* { dg-error ""passing argument 1 of 'recv' from incompatible pointer type"" } */
}

"
"/* { dg-do compile } */
/* { dg-options ""-O2 -ffast-math"" } */
/* { dg-prune-output ""non-standard ABI extension"" } */
/* { dg-additional-options ""-fno-common"" { target hppa*-*-hpux* } } */
/* { dg-additional-options ""-msse"" { target { i?86-*-* x86_64-*-* } } } */
/* { dg-require-effective-target int32plus } */

typedef float __m128 __attribute__ ((__vector_size__ (16)));
__m128 a, d, e;
int b;
struct dt_interpolation c;
__m128
fn1 (float p1)
{
  return (__attribute__ ((__vector_size__ (4 * sizeof 0))) float){ p1 };
}
__m128
fn2 (float p1)
{
  return fn1 (p1);
}
struct dt_interpolation
{
  int width;
};
void
fn3 (struct dt_interpolation *p1, int *p2)
{
  int i = 0, n = 0;
  while (i < 2 * p1->width)
    n = i++;
  *p2 = n;
}
void
fn4 ()
{
  __m128 f;
  fn3 (&c, &b);
  __m128 g = fn2 (1.f / b);
  e = (__m128){};
  __m128 h = e;
  for (int i = 0; i < 2 * c.width; i++)
    {
      for (; c.width;)
	f = a;
      h = f;
    }
  d = h * g;
}
","/* { dg-do compile } */
/* { dg-options ""-O2 -ffast-math"" } */
/* { dg-prune-output ""non-standard ABI extension"" } */
/* { dg-additional-options ""-fno-common"" { target hppa*-*-hpux* } } */
/* { dg-additional-options ""-msse"" { target { i?86-*-* x86_64-*-* } } } */
/* { dg-require-effective-target int32plus } */

typedef float __m128 __attribute__ ((__vector_size__ (16)));
__m128 a, d, e;
int b;
struct dt_interpolation c;
__m128
fn1 (float p1)
{
  return (__attribute__ ((__vector_size__ (4 * sizeof 0))) float){ p1 };
}
__m128
fn2 (float p1)
{
  return fn1 (p1);
}
struct dt_interpolation
{
  int width;
};
void
fn3 (struct dt_interpolation *p1, int *p2)
{
  int i = 0, n = 0;
  while (i < 2 * p1->width)
    n = i++;
  *p2 = n;
}
void
fn4 ()
{
  __m128 f;
  fn3 (&c, &b);
  __m128 g = fn2 (1.f / b);
  e = (__m128){};
  __m128 h = e;
  for (int i = 0; i < 2 * c.width; i++)
    {
      for (; c.width;)
	f = a;
      h = f;
    }
  d = h * g;
}
"
"/* PR c/68657 */
/* { dg-options ""-Werror=sign-conversion -Werror=float-conversion -Werror=frame-larger-than=65536"" } */
/* { dg-require-effective-target ptr32plus } */

void
f1 (void)
{
  unsigned int a = -5;	/* { dg-error ""unsigned conversion from .int. to .unsigned int. changes value from .-5. to .\[0-9\]+."" } */
  (void) a;
}

int
f2 (void)
{
  return 3.1f;	/* { dg-error ""conversion from .float. to .int. changes value"" } */
}

int f3 (char *);

int
f4 (void)
{
  char buf[131072];
  return f3 (buf);
}		/* { dg-error ""the frame size of 1\[0-9]* bytes is larger than 65536 bytes"" } */

/* { dg-prune-output ""treated as errors"" } */
","/* PR c/68657 */
/* { dg-options ""-Werror=sign-conversion -Werror=float-conversion -Werror=frame-larger-than=65536"" } */
/* { dg-require-effective-target ptr32plus } */

void
f1 (void)
{
  unsigned int a = -5;	/* { dg-error ""unsigned conversion from .int. to .unsigned int. changes value from .-5. to .\[0-9\]+."" } */
  (void) a;
}

int
f2 (void)
{
  return 3.1f;	/* { dg-error ""conversion from .float. to .int. changes value"" } */
}

int f3 (char *);

int
f4 (void)
{
  char buf[131072];
  return f3 (buf);
}		/* { dg-error ""the frame size of 1\[0-9]* bytes is larger than 65536 bytes"" } */

/* { dg-prune-output ""treated as errors"" } */
"
"/* { dg-do run } */
/* { dg-options ""-O2 -mavx512vl"" } */
/* { dg-require-effective-target avx512vl } */

#define AVX512VL
#define AVX512F_LEN 256
#define AVX512F_LEN_HALF 128
#include ""avx512f-vpxord-2.c""

#undef AVX512F_LEN
#undef AVX512F_LEN_HALF

#define AVX512F_LEN 128
#define AVX512F_LEN_HALF 128
#include ""avx512f-vpxord-2.c""
","/* { dg-do run } */
/* { dg-options ""-O2 -mavx512vl"" } */
/* { dg-require-effective-target avx512vl } */

#define AVX512VL
#define AVX512F_LEN 256
#define AVX512F_LEN_HALF 128
#include ""avx512f-vpxord-2.c""

#undef AVX512F_LEN
#undef AVX512F_LEN_HALF

#define AVX512F_LEN 128
#define AVX512F_LEN_HALF 128
#include ""avx512f-vpxord-2.c""
"
"/* Test generation of nmacchw on 440.  */
/* Origin: Joseph Myers <joseph@codesourcery.com> */
/* { dg-do compile } */
/* { dg-require-effective-target ilp32 } */
/* { dg-skip-if ""do not override -mcpu"" { powerpc*-*-* } { ""-mcpu=*"" } { ""-mcpu=440"" } } */
/* { dg-options ""-O2 -mcpu=440"" } */

/* { dg-final { scan-assembler ""nmacchw "" } } */

int
f(int a, int b, int c)
{
  a -= (short)b * (c >> 16);
  return a;
}
","/* Test generation of nmacchw on 440.  */
/* Origin: Joseph Myers <joseph@codesourcery.com> */
/* { dg-do compile } */
/* { dg-require-effective-target ilp32 } */
/* { dg-skip-if ""do not override -mcpu"" { powerpc*-*-* } { ""-mcpu=*"" } { ""-mcpu=440"" } } */
/* { dg-options ""-O2 -mcpu=440"" } */

/* { dg-final { scan-assembler ""nmacchw "" } } */

int
f(int a, int b, int c)
{
  a -= (short)b * (c >> 16);
  return a;
}
"
"/* { dg-do compile { target { powerpc*-*-* } } } */
/* { dg-skip-if ""do not override -mcpu"" { powerpc*-*-* } { ""-mcpu=*"" } { ""-mcpu=power8"" } } */
/* { dg-require-effective-target powerpc_p9vector_ok } */
/* { dg-options ""-mcpu=power8"" } */

#include <altivec.h>
#include <stdbool.h>

bool
test_data_class (float *p)
{
  float source = *p;

  return __builtin_vec_scalar_test_data_class (source, 3); /* { dg-error ""builtin function '__builtin_vsx_scalar_test_data_class_sp' requires"" } */
}
","/* { dg-do compile { target { powerpc*-*-* } } } */
/* { dg-skip-if ""do not override -mcpu"" { powerpc*-*-* } { ""-mcpu=*"" } { ""-mcpu=power8"" } } */
/* { dg-require-effective-target powerpc_p9vector_ok } */
/* { dg-options ""-mcpu=power8"" } */

#include <altivec.h>
#include <stdbool.h>

bool
test_data_class (float *p)
{
  float source = *p;

  return __builtin_vec_scalar_test_data_class (source, 3); /* { dg-error ""builtin function '__builtin_vsx_scalar_test_data_class_sp' requires"" } */
}
"
"/* { dg-do compile } */
/* { dg-options ""-O -fdump-tree-cddce1"" } */

__UINT8_TYPE__
f(__UINT16_TYPE__ b)
{
  __UINT8_TYPE__ a;
#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
  __builtin_memcpy(&a, &b, sizeof a);
#elif __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
  __builtin_memcpy(&a, (char *)&b + sizeof a, sizeof a);
#else
  a = b;
#endif
  return a;
}

/* { dg-final { scan-tree-dump ""_\[0-9\]+ = \\(\[^)\]+\\) b"" ""cddce1"" } } */
","/* { dg-do compile } */
/* { dg-options ""-O -fdump-tree-cddce1"" } */

__UINT8_TYPE__
f(__UINT16_TYPE__ b)
{
  __UINT8_TYPE__ a;
#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
  __builtin_memcpy(&a, &b, sizeof a);
#elif __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
  __builtin_memcpy(&a, (char *)&b + sizeof a, sizeof a);
#else
  a = b;
#endif
  return a;
}

/* { dg-final { scan-tree-dump ""_\[0-9\]+ = \\(\[^)\]+\\) b"" ""cddce1"" } } */
"
"/* { dg-do compile } */
/* { dg-options ""-fgimple"" } */

void __GIMPLE () foo (int a)
{
bb_2:
  a = *b; /* { dg-error ""undeclared"" } */

bb_3:
  return;
}
","/* { dg-do compile } */
/* { dg-options ""-fgimple"" } */

void __GIMPLE () foo (int a)
{
bb_2:
  a = *b; /* { dg-error ""undeclared"" } */

bb_3:
  return;
}
"
"/* From PR 7872, test for optabs segfault when strict low part is present.  */
/* { dg-do compile { target m68k-*-* } }  */
/* { dg-options ""-O0"" }  */
extern void (**table)(void);

typedef unsigned short uw16;
typedef unsigned int gshort;

register uw16 *pc asm(""%a4"");
register gshort code asm(""%d6"");

void QMExecuteLoop(uw16 *oldPC)
{
  table[code=(*(uw16*)(pc++))]();
}
","/* From PR 7872, test for optabs segfault when strict low part is present.  */
/* { dg-do compile { target m68k-*-* } }  */
/* { dg-options ""-O0"" }  */
extern void (**table)(void);

typedef unsigned short uw16;
typedef unsigned int gshort;

register uw16 *pc asm(""%a4"");
register gshort code asm(""%d6"");

void QMExecuteLoop(uw16 *oldPC)
{
  table[code=(*(uw16*)(pc++))]();
}
"
"foo (a)
{
  return ((int *)0)[a];
}
","foo (a)
{
  return ((int *)0)[a];
}
"
"/* { dg-options ""-O -fgraphite-identity -fno-tree-scev-cprop"" } */

int l[200];

void
foo (void)
{
  int i = 0;
  for (; i < 100; i++)
    ;
  for (; i; i--)
    l[i];
}
","/* { dg-options ""-O -fgraphite-identity -fno-tree-scev-cprop"" } */

int l[200];

void
foo (void)
{
  int i = 0;
  for (; i < 100; i++)
    ;
  for (; i; i--)
    l[i];
}
"
"/* { dg-do run { target { powerpc*-*-* } } } */
/* { dg-skip-if ""do not override -mcpu"" { powerpc*-*-* } { ""-mcpu=*"" } { ""-mcpu=power9"" } } */
/* { dg-require-effective-target p9vector_hw } */
/* { dg-options ""-mcpu=power9"" } */

#include <altivec.h>
#include <stdlib.h>

__vector unsigned int
get_exponents (__vector float *p)
{
  __vector float source = *p;

  return vec_extract_exp (source);
}

unsigned int bias_float_exp (int unbiased_exp)
{
  return (unsigned int) (unbiased_exp + 127);
}

int
main ()
{
  __vector float argument;
  __vector unsigned int result;

  argument[0] = (float) (0x1 << 10);
  argument[1] = (float) (0x1 << 9);
  argument[2] = (float) (0x1 << 8);
  argument[3] = (float) (0x1 << 7);

  result = get_exponents (&argument);
  if ((result[0] != bias_float_exp (10)) ||
      (result[1] != bias_float_exp (9)) ||
      (result[2] != bias_float_exp (8)) || (result[3] != bias_float_exp (7)))
    abort();
  return 0;
}
","/* { dg-do run { target { powerpc*-*-* } } } */
/* { dg-skip-if ""do not override -mcpu"" { powerpc*-*-* } { ""-mcpu=*"" } { ""-mcpu=power9"" } } */
/* { dg-require-effective-target p9vector_hw } */
/* { dg-options ""-mcpu=power9"" } */

#include <altivec.h>
#include <stdlib.h>

__vector unsigned int
get_exponents (__vector float *p)
{
  __vector float source = *p;

  return vec_extract_exp (source);
}

unsigned int bias_float_exp (int unbiased_exp)
{
  return (unsigned int) (unbiased_exp + 127);
}

int
main ()
{
  __vector float argument;
  __vector unsigned int result;

  argument[0] = (float) (0x1 << 10);
  argument[1] = (float) (0x1 << 9);
  argument[2] = (float) (0x1 << 8);
  argument[3] = (float) (0x1 << 7);

  result = get_exponents (&argument);
  if ((result[0] != bias_float_exp (10)) ||
      (result[1] != bias_float_exp (9)) ||
      (result[2] != bias_float_exp (8)) || (result[3] != bias_float_exp (7)))
    abort();
  return 0;
}
"
"/* { dg-do assemble } */
/* { dg-options ""-std=c99"" } */
#include <arm_neon.h>

int
main (int argc, char **argv)
{
  uint64x1_t base_a = vcreate_u64 (0x1111222233334444ULL);
  uint64x1_t base_b = vcreate_u64 (0x5555666677778888ULL);
  uint64x2_t baseq_a = vcombine_u64 (base_a, base_b);
  uint64x1_t base_c = vcreate_u64 (0x9999aaaabbbbccccULL);
  uint64x2_t baseq_b = vcombine_u64 (base_b, base_c);
  int16x8_t int16x8_a = vreinterpretq_s16_u64 (baseq_a);
  int16x8_t int16x8_b = vreinterpretq_s16_u64 (baseq_b);

  /* { dg-error ""lane -1 out of range 0 - 7"" """" {target *-*-*} 0 } */
  vqdmull_high_laneq_s16 (int16x8_a, int16x8_b, -1);
  /* { dg-error ""lane 8 out of range 0 - 7"" """" {target *-*-*} 0 } */
  vqdmull_high_laneq_s16 (int16x8_a, int16x8_b, 8);
}
","/* { dg-do assemble } */
/* { dg-options ""-std=c99"" } */
#include <arm_neon.h>

int
main (int argc, char **argv)
{
  uint64x1_t base_a = vcreate_u64 (0x1111222233334444ULL);
  uint64x1_t base_b = vcreate_u64 (0x5555666677778888ULL);
  uint64x2_t baseq_a = vcombine_u64 (base_a, base_b);
  uint64x1_t base_c = vcreate_u64 (0x9999aaaabbbbccccULL);
  uint64x2_t baseq_b = vcombine_u64 (base_b, base_c);
  int16x8_t int16x8_a = vreinterpretq_s16_u64 (baseq_a);
  int16x8_t int16x8_b = vreinterpretq_s16_u64 (baseq_b);

  /* { dg-error ""lane -1 out of range 0 - 7"" """" {target *-*-*} 0 } */
  vqdmull_high_laneq_s16 (int16x8_a, int16x8_b, -1);
  /* { dg-error ""lane 8 out of range 0 - 7"" """" {target *-*-*} 0 } */
  vqdmull_high_laneq_s16 (int16x8_a, int16x8_b, 8);
}
"
"/* Test diagnostics for addresses of labels and computed gotos.  Test
   with -pedantic.  */
/* Origin: Joseph Myers <joseph@codesourcery.com> */
/* { dg-do compile } */
/* { dg-options ""-pedantic"" } */
/* { dg-require-effective-target indirect_jumps } */
/* { dg-require-effective-target label_values } */

void
f (void)
{
  void *p = &&a; /* { dg-warning ""taking the address of a label is non-standard"" } */
  goto *p; /* { dg-warning ""ISO C forbids 'goto \\*expr;'"" } */
 a: ;
}
","/* Test diagnostics for addresses of labels and computed gotos.  Test
   with -pedantic.  */
/* Origin: Joseph Myers <joseph@codesourcery.com> */
/* { dg-do compile } */
/* { dg-options ""-pedantic"" } */
/* { dg-require-effective-target indirect_jumps } */
/* { dg-require-effective-target label_values } */

void
f (void)
{
  void *p = &&a; /* { dg-warning ""taking the address of a label is non-standard"" } */
  goto *p; /* { dg-warning ""ISO C forbids 'goto \\*expr;'"" } */
 a: ;
}
"
"/* { dg-require-effective-target vect_int } */
/* PR tree-optimization/67682.  */

#include ""tree-vect.h""

int __attribute__((__aligned__(8))) a[8];
int __attribute__((__aligned__(8))) b[4];

__attribute__ ((noinline)) void
test ()
{
    a[0] = b[0];
    a[1] = b[1];
    a[2] = b[2];
    a[3] = b[3];
    a[4] = 0;
    a[5] = 0;
    a[6] = 0;
    a[7] = 0;
}

int
main (int argc, char **argv)
{
  check_vect ();

  for (int i = 0; i < 8; i++)
    a[i] = 1;
  for (int i = 0; i < 4; i++)
    b[i] = i + 4;
  __asm__ volatile ("""" : : : ""memory"");
  test (a, b);
  __asm__ volatile ("""" : : : ""memory"");
  for (int i = 0; i < 4; i++)
    if (a[i] != i+4)
      abort ();
  for (int i = 4; i < 8; i++)
    if (a[i] != 0)
      abort ();
  return 0;
}

/* { dg-final { scan-tree-dump-times ""Basic block will be vectorized using SLP"" 1 ""slp2"" } } */
/* { dg-final { scan-tree-dump-times ""basic block vectorized"" 1 ""slp2"" } } */
","/* { dg-require-effective-target vect_int } */
/* PR tree-optimization/67682.  */

#include ""tree-vect.h""

int __attribute__((__aligned__(8))) a[8];
int __attribute__((__aligned__(8))) b[4];

__attribute__ ((noinline)) void
test ()
{
    a[0] = b[0];
    a[1] = b[1];
    a[2] = b[2];
    a[3] = b[3];
    a[4] = 0;
    a[5] = 0;
    a[6] = 0;
    a[7] = 0;
}

int
main (int argc, char **argv)
{
  check_vect ();

  for (int i = 0; i < 8; i++)
    a[i] = 1;
  for (int i = 0; i < 4; i++)
    b[i] = i + 4;
  __asm__ volatile ("""" : : : ""memory"");
  test (a, b);
  __asm__ volatile ("""" : : : ""memory"");
  for (int i = 0; i < 4; i++)
    if (a[i] != i+4)
      abort ();
  for (int i = 4; i < 8; i++)
    if (a[i] != 0)
      abort ();
  return 0;
}

/* { dg-final { scan-tree-dump-times ""Basic block will be vectorized using SLP"" 1 ""slp2"" } } */
/* { dg-final { scan-tree-dump-times ""basic block vectorized"" 1 ""slp2"" } } */
"
"/* { dg-do run } */
/* { dg-options ""-O2"" } */

struct S0 {
  __INT32_TYPE__ f0 : 24;
  __INT32_TYPE__ f1;
  __INT32_TYPE__ f74;
} a, *c = &a;
struct S0 fn1() {
  struct S0 b = {4, 3};
  return b;
}

int main() {
  *c = fn1();

  if (a.f1 != 3)
    __builtin_abort ();
  return 0;
}
","/* { dg-do run } */
/* { dg-options ""-O2"" } */

struct S0 {
  __INT32_TYPE__ f0 : 24;
  __INT32_TYPE__ f1;
  __INT32_TYPE__ f74;
} a, *c = &a;
struct S0 fn1() {
  struct S0 b = {4, 3};
  return b;
}

int main() {
  *c = fn1();

  if (a.f1 != 3)
    __builtin_abort ();
  return 0;
}
"
"/* { dg-do compile } */
/* { dg-require-effective-target arm_thumb1_ok } */
/* { dg-skip-if ""do not override -mcpu"" { *-*-* } { ""-mcpu=*"" ""-march=*"" } { ""-mcpu=cortex-m1.small-multiply"" } } */
/* { dg-options ""-mcpu=cortex-m1.small-multiply -mthumb -Os"" } */

int
test (int a)
{
  return a * 0x123456;
}

/* { dg-final { scan-assembler ""\[\\t \]+mul"" } } */
","/* { dg-do compile } */
/* { dg-require-effective-target arm_thumb1_ok } */
/* { dg-skip-if ""do not override -mcpu"" { *-*-* } { ""-mcpu=*"" ""-march=*"" } { ""-mcpu=cortex-m1.small-multiply"" } } */
/* { dg-options ""-mcpu=cortex-m1.small-multiply -mthumb -Os"" } */

int
test (int a)
{
  return a * 0x123456;
}

/* { dg-final { scan-assembler ""\[\\t \]+mul"" } } */
"
"#if defined (__ARCHS__) || defined (__ARCEM__)
#define RILINK ""ilink""
#else
#define RILINK ""ilink1""
#endif

extern int gpio_int;
extern int read_reg (int);

void __attribute__ ((interrupt(RILINK)))
isr_handler (void)
{
  gpio_int = read_reg (1);
}
/* { dg-final { scan-assembler-times ""blink"" 2 } } */
","#if defined (__ARCHS__) || defined (__ARCEM__)
#define RILINK ""ilink""
#else
#define RILINK ""ilink1""
#endif

extern int gpio_int;
extern int read_reg (int);

void __attribute__ ((interrupt(RILINK)))
isr_handler (void)
{
  gpio_int = read_reg (1);
}
/* { dg-final { scan-assembler-times ""blink"" 2 } } */
"
"/* { dg-do compile } */
/* { dg-options ""-O2 -fdump-tree-optimized"" } */

volatile int count;
void bar(int);
void foo()
{
 bar(count++);
}

/* { dg-final { scan-tree-dump-times ""count ="" 1 ""optimized""} } */
","/* { dg-do compile } */
/* { dg-options ""-O2 -fdump-tree-optimized"" } */

volatile int count;
void bar(int);
void foo()
{
 bar(count++);
}

/* { dg-final { scan-tree-dump-times ""count ="" 1 ""optimized""} } */
"
"/* { dg-do compile { target arm*-*-symbianelf* } } */
/* { dg-options ""-fno-short-wchar"" } */
/* Check that wchar_t is a 4-byte type when -fno-short-wchar is
   used.  */

extern int i[sizeof (L'a')];
int i[4];

","/* { dg-do compile { target arm*-*-symbianelf* } } */
/* { dg-options ""-fno-short-wchar"" } */
/* Check that wchar_t is a 4-byte type when -fno-short-wchar is
   used.  */

extern int i[sizeof (L'a')];
int i[4];

"
"/* { dg-require-effective-target size32plus } */
/* { dg-require-effective-target run_expensive_tests }  PR testsuite/48283 */

#define DEBUG 0
#if DEBUG
#include <stdio.h>
#endif

#define N 200

int A[N][N], B[N][N], C[N][N];

static void __attribute__((noinline))
matmult (void)
{
  int i, j, k;

  /* This should be blocked.  */
  for (i = 0; i < N; i++)
    for (j = 0; j < N; j++)
      {
        A[i][j] = 0;
        for (k = 0; k < N; k++)
          A[i][j] += B[i][k] * C[k][j];
      }
}

extern void abort ();

int
main (void)
{
  int i, j, res = 0;

  for (i = 0; i < N; i++)
    for (j = 0; j < N; j++)
      {
	B[i][j] = j;
	C[i][j] = i;
      }

  matmult ();

  for (i = 0; i < N; i++)
    res += A[i][i];

#if DEBUG
  fprintf (stderr, ""res = %d \n"", res);
#endif

  if (res != 529340000)
    abort ();

  return 0;
}

/* { dg-final { scan-tree-dump ""tiled by"" ""graphite"" } } */
","/* { dg-require-effective-target size32plus } */
/* { dg-require-effective-target run_expensive_tests }  PR testsuite/48283 */

#define DEBUG 0
#if DEBUG
#include <stdio.h>
#endif

#define N 200

int A[N][N], B[N][N], C[N][N];

static void __attribute__((noinline))
matmult (void)
{
  int i, j, k;

  /* This should be blocked.  */
  for (i = 0; i < N; i++)
    for (j = 0; j < N; j++)
      {
        A[i][j] = 0;
        for (k = 0; k < N; k++)
          A[i][j] += B[i][k] * C[k][j];
      }
}

extern void abort ();

int
main (void)
{
  int i, j, res = 0;

  for (i = 0; i < N; i++)
    for (j = 0; j < N; j++)
      {
	B[i][j] = j;
	C[i][j] = i;
      }

  matmult ();

  for (i = 0; i < N; i++)
    res += A[i][i];

#if DEBUG
  fprintf (stderr, ""res = %d \n"", res);
#endif

  if (res != 529340000)
    abort ();

  return 0;
}

/* { dg-final { scan-tree-dump ""tiled by"" ""graphite"" } } */
"
"/* PR tree-optimization/41661 */
/* { dg-do compile } */
/* { dg-options ""-fno-early-inlining"" } */

int g;

void foo (int x)
{
  g = x;
}

void bar (double d)
{
  foo (d == 1);
}

void baz (int a)
{
  bar (1);
}
","/* PR tree-optimization/41661 */
/* { dg-do compile } */
/* { dg-options ""-fno-early-inlining"" } */

int g;

void foo (int x)
{
  g = x;
}

void bar (double d)
{
  foo (d == 1);
}

void baz (int a)
{
  bar (1);
}
"
"/* { dg-do run { target cet } } */
/* { dg-options ""-O2 -fcf-protection=branch"" } */

void callme (void (*callback) (void));

int
main (void)
{
  int ok = 0;
  void callback (void) { ok = 1; }

  callme (&callback);

  if (!ok)
   __builtin_abort ();
  return 0;
}

__attribute__((noinline, noclone))
void
callme (void (*callback) (void))
{
  (*callback) ();
}
","/* { dg-do run { target cet } } */
/* { dg-options ""-O2 -fcf-protection=branch"" } */

void callme (void (*callback) (void));

int
main (void)
{
  int ok = 0;
  void callback (void) { ok = 1; }

  callme (&callback);

  if (!ok)
   __builtin_abort ();
  return 0;
}

__attribute__((noinline, noclone))
void
callme (void (*callback) (void))
{
  (*callback) ();
}
"
"/* Verify that the fsrra insn is not used when specifying -mno-fsrra and
  -funsafe-math-optimizations and -ffinite-math-only.  */
/* { dg-do compile { target { has_fsrra } } }  */
/* { dg-options ""-O1 -mno-fsrra -funsafe-math-optimizations -ffinite-math-only"" } */
/* { dg-final { scan-assembler-not ""fsrra"" } } */

#include <math.h>

float
test_func_00 (float x)
{
  return 1 / sqrtf (x);
}
","/* Verify that the fsrra insn is not used when specifying -mno-fsrra and
  -funsafe-math-optimizations and -ffinite-math-only.  */
/* { dg-do compile { target { has_fsrra } } }  */
/* { dg-options ""-O1 -mno-fsrra -funsafe-math-optimizations -ffinite-math-only"" } */
/* { dg-final { scan-assembler-not ""fsrra"" } } */

#include <math.h>

float
test_func_00 (float x)
{
  return 1 / sqrtf (x);
}
"
"/* { dg-do run } */
/* { dg-options ""-O2 -msse2"" } */
/* { dg-require-effective-target sse2 } */

#ifndef CHECK_H
#define CHECK_H ""sse2-check.h""
#endif

#ifndef TEST
#define TEST sse2_test
#endif

#include CHECK_H

#include <emmintrin.h>

static __m128i
__attribute__((noinline, unused))
test (__m128i s1, __m128i s2)
{
  return _mm_adds_epu8 (s1, s2); 
}

static void
TEST (void)
{
  union128i_b u, s1, s2;
  char e[16] = {0};
  int i, tmp;
   
  s1.x = _mm_set_epi8 (30, 2,  3,  4,  10, 20, 30, 90,   80, 40, 100, 15, 98, 25, 98, 7);
  s2.x = _mm_set_epi8 (88, 44, 33, 22, 11, 98, 76, 100,  34, 78, 39,   6,  3,  4,  5,  119);
  u.x = test (s1.x, s2.x); 
   
  for (i = 0; i < 16; i++)
    {
      tmp = s1.a[i] + s2.a[i];

      if (tmp > 255)
        tmp = -1;
      if (tmp < 0)
        tmp = 0; 

      e[i] = tmp; 
    }

  if (check_union128i_b (u, e))
    abort ();
}
","/* { dg-do run } */
/* { dg-options ""-O2 -msse2"" } */
/* { dg-require-effective-target sse2 } */

#ifndef CHECK_H
#define CHECK_H ""sse2-check.h""
#endif

#ifndef TEST
#define TEST sse2_test
#endif

#include CHECK_H

#include <emmintrin.h>

static __m128i
__attribute__((noinline, unused))
test (__m128i s1, __m128i s2)
{
  return _mm_adds_epu8 (s1, s2); 
}

static void
TEST (void)
{
  union128i_b u, s1, s2;
  char e[16] = {0};
  int i, tmp;
   
  s1.x = _mm_set_epi8 (30, 2,  3,  4,  10, 20, 30, 90,   80, 40, 100, 15, 98, 25, 98, 7);
  s2.x = _mm_set_epi8 (88, 44, 33, 22, 11, 98, 76, 100,  34, 78, 39,   6,  3,  4,  5,  119);
  u.x = test (s1.x, s2.x); 
   
  for (i = 0; i < 16; i++)
    {
      tmp = s1.a[i] + s2.a[i];

      if (tmp > 255)
        tmp = -1;
      if (tmp < 0)
        tmp = 0; 

      e[i] = tmp; 
    }

  if (check_union128i_b (u, e))
    abort ();
}
"
"/* { dg-do compile } */
/* { dg-options ""-O2"" } */

typedef union tree_node *tree;

struct tree_base
{
  int code;
};

struct tree_typed
{
  struct tree_base base;
  tree type;
};

struct tree_common
{
  struct tree_typed typed;
};

struct tree_type_common
{
  tree main_variant;
};

union tree_node
{
  struct tree_base base;
  struct tree_typed typed;
  struct tree_type_common type_common;
};

int std_canonical_va_list_type (tree type)
{
  if (type->base.code)
    type = type->typed.type;
  else
    if (type->typed.type->base.code)
      type = type->typed.type;

  if (type->type_common.main_variant)
    return 1;

  return 0;
}
","/* { dg-do compile } */
/* { dg-options ""-O2"" } */

typedef union tree_node *tree;

struct tree_base
{
  int code;
};

struct tree_typed
{
  struct tree_base base;
  tree type;
};

struct tree_common
{
  struct tree_typed typed;
};

struct tree_type_common
{
  tree main_variant;
};

union tree_node
{
  struct tree_base base;
  struct tree_typed typed;
  struct tree_type_common type_common;
};

int std_canonical_va_list_type (tree type)
{
  if (type->base.code)
    type = type->typed.type;
  else
    if (type->typed.type->base.code)
      type = type->typed.type;

  if (type->type_common.main_variant)
    return 1;

  return 0;
}
"
"/* { dg-do compile } */
/* { dg-options ""-mavx512f -O2"" } */
/* { dg-final { scan-assembler-times ""vmovdqu(?:32|64)\[ \\t\]+\[^\{\n\]*\\)\[^\n\]*%zmm\[0-9\]+(?:\n|\[ \\t\]+#)"" 1 } } */
/* { dg-final { scan-assembler-times ""vmovdqu32\[ \\t\]+\[^\{\n\]*\\)\[^\n\]*%zmm\[0-9\]+\{%k\[1-7\]\}(?:\n|\[ \\t\]+#)"" 1 } } */
/* { dg-final { scan-assembler-times ""vmovdqu32\[ \\t\]+\[^\{\n\]*\\)\[^\n\]*%zmm\[0-9\]+\{%k\[1-7\]\}\{z\}(?:\n|\[ \\t\]+#)"" 1 } } */
/* { dg-final { scan-assembler-times ""vmovdqu(?:32|64)\[ \\t\]+\[^\{\n\]*%zmm\[0-9\]+\[^\n\]*\\)(?:\n|\[ \\t\]+#)"" 1 } } */
/* { dg-final { scan-assembler-times ""vmovdqu32\[ \\t\]+\[^\{\n\]*%zmm\[0-9\]+\[^\n\]*\\)\{%k\[1-7\]\}(?:\n|\[ \\t\]+#)"" 1 } } */

#include <immintrin.h>

int *p;
volatile __m512i x;
volatile __mmask16 m;

void extern
avx512f_test (void)
{
  x = _mm512_loadu_si512 (p);
  x = _mm512_mask_loadu_epi32 (x, m, p);
  x = _mm512_maskz_loadu_epi32 (m, p);

  _mm512_storeu_si512 (p, x);
  _mm512_mask_storeu_epi32 (p, m, x);
}
","/* { dg-do compile } */
/* { dg-options ""-mavx512f -O2"" } */
/* { dg-final { scan-assembler-times ""vmovdqu(?:32|64)\[ \\t\]+\[^\{\n\]*\\)\[^\n\]*%zmm\[0-9\]+(?:\n|\[ \\t\]+#)"" 1 } } */
/* { dg-final { scan-assembler-times ""vmovdqu32\[ \\t\]+\[^\{\n\]*\\)\[^\n\]*%zmm\[0-9\]+\{%k\[1-7\]\}(?:\n|\[ \\t\]+#)"" 1 } } */
/* { dg-final { scan-assembler-times ""vmovdqu32\[ \\t\]+\[^\{\n\]*\\)\[^\n\]*%zmm\[0-9\]+\{%k\[1-7\]\}\{z\}(?:\n|\[ \\t\]+#)"" 1 } } */
/* { dg-final { scan-assembler-times ""vmovdqu(?:32|64)\[ \\t\]+\[^\{\n\]*%zmm\[0-9\]+\[^\n\]*\\)(?:\n|\[ \\t\]+#)"" 1 } } */
/* { dg-final { scan-assembler-times ""vmovdqu32\[ \\t\]+\[^\{\n\]*%zmm\[0-9\]+\[^\n\]*\\)\{%k\[1-7\]\}(?:\n|\[ \\t\]+#)"" 1 } } */

#include <immintrin.h>

int *p;
volatile __m512i x;
volatile __mmask16 m;

void extern
avx512f_test (void)
{
  x = _mm512_loadu_si512 (p);
  x = _mm512_mask_loadu_epi32 (x, m, p);
  x = _mm512_maskz_loadu_epi32 (m, p);

  _mm512_storeu_si512 (p, x);
  _mm512_mask_storeu_epi32 (p, m, x);
}
"
"/* { dg-do compile } */
/* { dg-options ""-Waddress -Werror -Wno-error=address -Wattributes"" } */
/* { dg-message ""warnings being treated as errors"" """" {target ""*-*-*""} 0 } */

/* Make sure -Wno-error= overrides -Werror.  */

void grill ();
void __attribute__((dj)) bar() { }	/* { dg-error "".* attribute directive ignored"" } */

int i;

void
foo ()
{
  if (&i)	/* { dg-warning "".* will always evaluate as 'true'"" } */
    grill ();
}
","/* { dg-do compile } */
/* { dg-options ""-Waddress -Werror -Wno-error=address -Wattributes"" } */
/* { dg-message ""warnings being treated as errors"" """" {target ""*-*-*""} 0 } */

/* Make sure -Wno-error= overrides -Werror.  */

void grill ();
void __attribute__((dj)) bar() { }	/* { dg-error "".* attribute directive ignored"" } */

int i;

void
foo ()
{
  if (&i)	/* { dg-warning "".* will always evaluate as 'true'"" } */
    grill ();
}
"
"/* { dg-do run } */
/* { dg-require-effective-target tls_runtime } */
/* { dg-add-options tls } */

extern int printf (char *,...);
extern void abort() ;

int test_code(int b)
{
static __thread int fstat = 1;
  fstat += b ;
  return fstat;
}

int main (int ac, char *av[])
{
  int a = test_code(1);
  
  if ( a != 2 )
    {
      printf (""a=%d\n"", a) ;
      abort ();
    }
  
  return 0;
}
","/* { dg-do run } */
/* { dg-require-effective-target tls_runtime } */
/* { dg-add-options tls } */

extern int printf (char *,...);
extern void abort() ;

int test_code(int b)
{
static __thread int fstat = 1;
  fstat += b ;
  return fstat;
}

int main (int ac, char *av[])
{
  int a = test_code(1);
  
  if ( a != 2 )
    {
      printf (""a=%d\n"", a) ;
      abort ();
    }
  
  return 0;
}
"
"/* { dg-do compile } */
/* { dg-options ""-O2 -fdump-tree-pre-stats"" } */

typedef union {
  int i;
  float f;
} U;

int foo(U *u, int b, int i)
{
  u->i = 0;
  if (b)
    u->i = i;
  return u->i;
}

/* { dg-final { scan-tree-dump ""Eliminated: 1"" ""pre"" } } */
","/* { dg-do compile } */
/* { dg-options ""-O2 -fdump-tree-pre-stats"" } */

typedef union {
  int i;
  float f;
} U;

int foo(U *u, int b, int i)
{
  u->i = 0;
  if (b)
    u->i = i;
  return u->i;
}

/* { dg-final { scan-tree-dump ""Eliminated: 1"" ""pre"" } } */
"
"/* { dg-do run } */
/* { dg-options ""-O"" } */

#if __SIZEOF_INT__ == 2
#define int __INT32_TYPE__
#endif

struct A
{
  int b;
  int c;
  int d;
};

struct E
{
  int f;
  int g:18;
  struct A h;
};

struct I
{
  int b;
  int j;
  struct E k;
};

int l, *m = &l;

struct A n;
struct I o;

void __attribute__ ((noipa))
test_l (void)
{
  if (l != 1)
    __builtin_abort ();
}

#undef int

int main ()
{
  while (1)
    {
      struct I q = { 0, 0, {0, 0, {1, 1, 1}}}, p = q, r = p, *s = &q;
      if (p.k.h.c)
        o = p;
      *m = r.k.h.d;
      n = (*s).k.h;
      break;
    }
  test_l ();
  return 0;
}
","/* { dg-do run } */
/* { dg-options ""-O"" } */

#if __SIZEOF_INT__ == 2
#define int __INT32_TYPE__
#endif

struct A
{
  int b;
  int c;
  int d;
};

struct E
{
  int f;
  int g:18;
  struct A h;
};

struct I
{
  int b;
  int j;
  struct E k;
};

int l, *m = &l;

struct A n;
struct I o;

void __attribute__ ((noipa))
test_l (void)
{
  if (l != 1)
    __builtin_abort ();
}

#undef int

int main ()
{
  while (1)
    {
      struct I q = { 0, 0, {0, 0, {1, 1, 1}}}, p = q, r = p, *s = &q;
      if (p.k.h.c)
        o = p;
      *m = r.k.h.d;
      n = (*s).k.h;
      break;
    }
  test_l ();
  return 0;
}
"
"/* Test dead code strip support.  */
/* Contributed by Devang Patel  <dpatel@apple.com>  */
 
/* { dg-do compile { target *-*-darwin* } } */

const char my_version_string[] __attribute__((__used__))
  = ""Do not remove this string\n"";
 
 static int
 __attribute__((__used__))
      static_debug_routine()
{
   int i;
   i = 42;
}
 
int
main ()
{
   return 0;
}
 
/* { dg-final { scan-assembler "".no_dead_strip _my_version_string"" } } */
/* { dg-final { scan-assembler "".no_dead_strip _static_debug_routine"" } } */
","/* Test dead code strip support.  */
/* Contributed by Devang Patel  <dpatel@apple.com>  */
 
/* { dg-do compile { target *-*-darwin* } } */

const char my_version_string[] __attribute__((__used__))
  = ""Do not remove this string\n"";
 
 static int
 __attribute__((__used__))
      static_debug_routine()
{
   int i;
   i = 42;
}
 
int
main ()
{
   return 0;
}
 
/* { dg-final { scan-assembler "".no_dead_strip _my_version_string"" } } */
/* { dg-final { scan-assembler "".no_dead_strip _static_debug_routine"" } } */
"
"/* Test for bogus diagnostics for dremf definition.  Although this
   definition is formally incorrect in ISO C, a GNU extension permits
   a prototype followed by unpromoted types in a function definition,
   so it should be permitted when the function is built in.  Bug
   16666.  Test with -pedantic, where the problem should still be
   diagnosed.  */
/* { dg-do compile } */
/* { dg-options ""-pedantic"" } */

float dremf (float, float); /* { dg-warning ""prototype declaration"" } */

float
dremf (x, y)
     float x; /* { dg-warning ""promoted argument 'x' doesn't match prototype"" } */
     float y; /* { dg-warning ""promoted argument 'y' doesn't match prototype"" } */
{
  return x + y;
}
","/* Test for bogus diagnostics for dremf definition.  Although this
   definition is formally incorrect in ISO C, a GNU extension permits
   a prototype followed by unpromoted types in a function definition,
   so it should be permitted when the function is built in.  Bug
   16666.  Test with -pedantic, where the problem should still be
   diagnosed.  */
/* { dg-do compile } */
/* { dg-options ""-pedantic"" } */

float dremf (float, float); /* { dg-warning ""prototype declaration"" } */

float
dremf (x, y)
     float x; /* { dg-warning ""promoted argument 'x' doesn't match prototype"" } */
     float y; /* { dg-warning ""promoted argument 'y' doesn't match prototype"" } */
{
  return x + y;
}
"
"/* { dg-do run } */
/* { dg-options ""-O2"" } */
/* { dg-additional-options ""-DMAX_COPY=1025"" { target { { simulator } || { nvptx-*-* } } } } */
/* { dg-additional-options ""-minline-stringops-dynamically"" { target { i?86-*-* x86_64-*-* } } } */

#include ""pr59605.c""
","/* { dg-do run } */
/* { dg-options ""-O2"" } */
/* { dg-additional-options ""-DMAX_COPY=1025"" { target { { simulator } || { nvptx-*-* } } } } */
/* { dg-additional-options ""-minline-stringops-dynamically"" { target { i?86-*-* x86_64-*-* } } } */

#include ""pr59605.c""
"
"/* { dg-do compile { target cris-*-* crisv32-*-* } } */
/* { dg-skip-if """" { cris*-*-* } { ""-march*"" } { """" } } */
/* { dg-options ""-O2 -march=v10"" } */
/* { dg-final { scan-assembler ""in-asm: .mof"" } } */
/* { dg-final { scan-assembler ""out-asm: .mof"" } } */
/* { dg-final { scan-assembler ""in2-asm: .mof"" } } */
/* { dg-final { scan-assembler ""out2-asm: .mof"" } } */

unsigned int
in (unsigned int i)
{
  register int i0 asm (""mof"") = i;
  asm (""in-asm: %0"" : : ""x"" (i0));
}

unsigned int
out (void)
{
  register int o asm (""mof"");
  asm (""out-asm: %0"" : ""=x"" (o));
  return o;
}

unsigned int
in2 (unsigned int i)
{
  asm (""in2-asm: %0"" : : ""h"" (i));
}

unsigned int
out2 (void)
{
  unsigned int o;
  asm (""out2-asm: %0"" : ""=h"" (o));
  return o;
}
","/* { dg-do compile { target cris-*-* crisv32-*-* } } */
/* { dg-skip-if """" { cris*-*-* } { ""-march*"" } { """" } } */
/* { dg-options ""-O2 -march=v10"" } */
/* { dg-final { scan-assembler ""in-asm: .mof"" } } */
/* { dg-final { scan-assembler ""out-asm: .mof"" } } */
/* { dg-final { scan-assembler ""in2-asm: .mof"" } } */
/* { dg-final { scan-assembler ""out2-asm: .mof"" } } */

unsigned int
in (unsigned int i)
{
  register int i0 asm (""mof"") = i;
  asm (""in-asm: %0"" : : ""x"" (i0));
}

unsigned int
out (void)
{
  register int o asm (""mof"");
  asm (""out-asm: %0"" : ""=x"" (o));
  return o;
}

unsigned int
in2 (unsigned int i)
{
  asm (""in2-asm: %0"" : : ""h"" (i));
}

unsigned int
out2 (void)
{
  unsigned int o;
  asm (""out2-asm: %0"" : ""=h"" (o));
  return o;
}
"
"/* { dg-do run } */
/* { dg-require-effective-target avx } */
/* { dg-options ""-O2 -mavx"" } */

#include ""avx-check.h""

void static
avx_test (void)
{
  int i;
  union128 s1;
  union256d u;
  double e [4];

  s1.x = _mm_set_ps (2.43, 68.46, 23.35, 536.46);
  u.x = _mm256_cvtps_pd (s1.x);

  for (i = 0; i < 4; i++)
    e[i] = (double)s1.a[i];

  if (check_union256d (u, e))
    abort ();
}
","/* { dg-do run } */
/* { dg-require-effective-target avx } */
/* { dg-options ""-O2 -mavx"" } */

#include ""avx-check.h""

void static
avx_test (void)
{
  int i;
  union128 s1;
  union256d u;
  double e [4];

  s1.x = _mm_set_ps (2.43, 68.46, 23.35, 536.46);
  u.x = _mm256_cvtps_pd (s1.x);

  for (i = 0; i < 4; i++)
    e[i] = (double)s1.a[i];

  if (check_union256d (u, e))
    abort ();
}
"
"/* PR c/36489 */
/* { dg-do compile } */
/* { dg-options ""-Woverride-init"" } */

struct A { int a; int b[3]; };
union B { int a; int b[3]; };
int t1[10][10]
  = { [1][2] = 11, [1][3] = 12 };
int t2[10][10]
  = { [1][2] = 11, [1] = { [3] = 12 } };	/* { dg-warning ""initializ"" } */
int t3[10][10]
  = { [1][2] = 11, [1][2] = 12 };		/* { dg-warning ""initializ"" } */
struct A t4[2]
  = { [0].b[0] = 1, [0].b[1] = 2, [0].b[2] = 3 };
struct A t5[2]
  = { [0].b[0] = 1, [0].b[1] = 2, [0].b = { 3 } }; /* { dg-warning ""initializ"" } */
union B t6
  = { .b[0] = 1, .b[1] = 2, .b[2] = 3 };
union B t7
  = { .b[0] = 1, .b[1] = 2, .b = { 2 } };	/* { dg-warning ""initializ"" } */
union B t8
  = { .b[0] = 1, .b[1] = 2, .b[1] = 3 };	/* { dg-warning ""initializ"" } */
","/* PR c/36489 */
/* { dg-do compile } */
/* { dg-options ""-Woverride-init"" } */

struct A { int a; int b[3]; };
union B { int a; int b[3]; };
int t1[10][10]
  = { [1][2] = 11, [1][3] = 12 };
int t2[10][10]
  = { [1][2] = 11, [1] = { [3] = 12 } };	/* { dg-warning ""initializ"" } */
int t3[10][10]
  = { [1][2] = 11, [1][2] = 12 };		/* { dg-warning ""initializ"" } */
struct A t4[2]
  = { [0].b[0] = 1, [0].b[1] = 2, [0].b[2] = 3 };
struct A t5[2]
  = { [0].b[0] = 1, [0].b[1] = 2, [0].b = { 3 } }; /* { dg-warning ""initializ"" } */
union B t6
  = { .b[0] = 1, .b[1] = 2, .b[2] = 3 };
union B t7
  = { .b[0] = 1, .b[1] = 2, .b = { 2 } };	/* { dg-warning ""initializ"" } */
union B t8
  = { .b[0] = 1, .b[1] = 2, .b[1] = 3 };	/* { dg-warning ""initializ"" } */
"
"/* PR target/69969 */
/* { dg-do compile } */
/* { dg-skip-if ""do not override -mcpu"" { powerpc*-*-* } { ""-mcpu=*"" } { ""-mcpu=power8"" } } */
/* { dg-options ""-mcpu=power8"" } */

int bar (int x) { return x; }
__attribute__((__target__(""no-vsx""))) int foo (int x) { return x; } /* { dg-bogus ""-mallow-movmisalign requires -mvsx"" } */
","/* PR target/69969 */
/* { dg-do compile } */
/* { dg-skip-if ""do not override -mcpu"" { powerpc*-*-* } { ""-mcpu=*"" } { ""-mcpu=power8"" } } */
/* { dg-options ""-mcpu=power8"" } */

int bar (int x) { return x; }
__attribute__((__target__(""no-vsx""))) int foo (int x) { return x; } /* { dg-bogus ""-mallow-movmisalign requires -mvsx"" } */
"
"extern void baz (int, int, int);

int j;

int
bar (void)
{
  int n = 0, *np = &n;
  if (j)
    baz (0, 0, 0);
  if (j)
    baz (0, 0, 0);
  return n;
}

void
foo (void)
{
  bar ();
  bar ();
}

","extern void baz (int, int, int);

int j;

int
bar (void)
{
  int n = 0, *np = &n;
  if (j)
    baz (0, 0, 0);
  if (j)
    baz (0, 0, 0);
  return n;
}

void
foo (void)
{
  bar ();
  bar ();
}

"
"f ()
{
  struct { char a, b; } x;
  g (x, x, x, x);
}
","f ()
{
  struct { char a, b; } x;
  g (x, x, x, x);
}
"
"/* Test __builtin_{add,sub,mul,{s,u}add,{s,u}sub,{s,u}mul}_overflow.  */
/* { dg-do run } */
/* { dg-skip-if """" { ! run_expensive_tests }  { ""*"" } { ""-O0"" ""-O2"" } } */

#include ""builtin-arith-overflow-1.h""

#define U(s, op) s##op
TESTS (int, INT_MIN, INT_MAX)
#undef U
#define U(s, op) op
TESTS (int, INT_MIN, INT_MAX)

#undef T
#define T(n, t1, t2, tr, v1, v2, vr, b, o) t##n##b ();

int
main ()
{
  TESTS (int, INT_MIN, INT_MAX)
#undef U
#define U(s, op) s##op
  TESTS (int, INT_MIN, INT_MAX)
  return 0;
}
","/* Test __builtin_{add,sub,mul,{s,u}add,{s,u}sub,{s,u}mul}_overflow.  */
/* { dg-do run } */
/* { dg-skip-if """" { ! run_expensive_tests }  { ""*"" } { ""-O0"" ""-O2"" } } */

#include ""builtin-arith-overflow-1.h""

#define U(s, op) s##op
TESTS (int, INT_MIN, INT_MAX)
#undef U
#define U(s, op) op
TESTS (int, INT_MIN, INT_MAX)

#undef T
#define T(n, t1, t2, tr, v1, v2, vr, b, o) t##n##b ();

int
main ()
{
  TESTS (int, INT_MIN, INT_MAX)
#undef U
#define U(s, op) s##op
  TESTS (int, INT_MIN, INT_MAX)
  return 0;
}
"
"/* { dg-do run } */
/* { dg-require-effective-target avx2 } */
/* { dg-options ""-O2 -mavx2"" } */

#include <string.h>
#include ""avx2-check.h""

static void
compute_i64gatherps256 (int *s1, long long *s2, int scale, int *r)
{
  int i;

  for (i = 0; i < 4; ++i)
    r[i] = *(int *) (((unsigned char *) s1) + s2[i] * scale);
}

void static
avx2_test (void)
{
  int i;
  union256i_q idx;
  union128i_d res;
  int s1[8], res_ref[4] = { 0 };

  for (i = 0; i < 4; ++i)
    {
      /* Set some stuff */
      s1[i] = 1973 * (i + 1) * (i + 2);

      /* About to gather in reverse order,
         divide by 2 to demonstrate scale */
      idx.a[i] = (16 - (i + 1) * 4) >> 1;
    }

  res.x = _mm256_i64gather_epi32 (s1, idx.x, 2);

  compute_i64gatherps256 (s1, idx.a, 2, res_ref);

  if (check_union128i_d (res, res_ref) != 0)
    abort ();
}
","/* { dg-do run } */
/* { dg-require-effective-target avx2 } */
/* { dg-options ""-O2 -mavx2"" } */

#include <string.h>
#include ""avx2-check.h""

static void
compute_i64gatherps256 (int *s1, long long *s2, int scale, int *r)
{
  int i;

  for (i = 0; i < 4; ++i)
    r[i] = *(int *) (((unsigned char *) s1) + s2[i] * scale);
}

void static
avx2_test (void)
{
  int i;
  union256i_q idx;
  union128i_d res;
  int s1[8], res_ref[4] = { 0 };

  for (i = 0; i < 4; ++i)
    {
      /* Set some stuff */
      s1[i] = 1973 * (i + 1) * (i + 2);

      /* About to gather in reverse order,
         divide by 2 to demonstrate scale */
      idx.a[i] = (16 - (i + 1) * 4) >> 1;
    }

  res.x = _mm256_i64gather_epi32 (s1, idx.x, 2);

  compute_i64gatherps256 (s1, idx.a, 2, res_ref);

  if (check_union128i_d (res, res_ref) != 0)
    abort ();
}
"
"/* { dg-do compile } */
/* { dg-options ""-fgnu-tm -O2"" } */

int foo(int *arr, int v)
{
  int r = 0;
  int i;
  __transaction_atomic {
    for (i = 0; i < 10; ++i)
      if (arr[i] < 27)
	r += arr[i] += v;
  }
  return r;
}
","/* { dg-do compile } */
/* { dg-options ""-fgnu-tm -O2"" } */

int foo(int *arr, int v)
{
  int r = 0;
  int i;
  __transaction_atomic {
    for (i = 0; i < 10; ++i)
      if (arr[i] < 27)
	r += arr[i] += v;
  }
  return r;
}
"
"struct s
{
  int a;
  int b;
  short c;
  int d[3];
};

struct s s = { .b = 3, .d = {2,0,0} };

main ()
{
  if (s.b != 3)
    abort ();
  exit (0);
}
","struct s
{
  int a;
  int b;
  short c;
  int d[3];
};

struct s s = { .b = 3, .d = {2,0,0} };

main ()
{
  if (s.b != 3)
    abort ();
  exit (0);
}
"
"/* { dg-do compile } */
/* { dg-options ""-Wc++-compat"" } */
const int v1;			/* { dg-warning ""invalid in C\[+\]\[+\]"" } */
const char * const v2;		/* { dg-warning ""invalid in C\[+\]\[+\]"" } */
struct s { int f1; int f2; };
const struct s v3;		/* { dg-warning ""invalid in C\[+\]\[+\]"" } */
const int v4 = 1;
const char * const v5 = 0;
const struct s v6 = { 0, 0 };
const struct s v7 = { 0 };
void
f()
{
  const int v11;		/* { dg-warning ""invalid in C\[+\]\[+\]"" } */
  const char * const v12;	/* { dg-warning ""invalid in C\[+\]\[+\]"" } */
  const struct s v13;		/* { dg-warning ""invalid in C\[+\]\[+\]"" } */
  const int v14 = 1;
  const char * const v15 = 0;
  const struct s v16 = { 0, 0 };
  const struct s v17 = { 0 };
}
","/* { dg-do compile } */
/* { dg-options ""-Wc++-compat"" } */
const int v1;			/* { dg-warning ""invalid in C\[+\]\[+\]"" } */
const char * const v2;		/* { dg-warning ""invalid in C\[+\]\[+\]"" } */
struct s { int f1; int f2; };
const struct s v3;		/* { dg-warning ""invalid in C\[+\]\[+\]"" } */
const int v4 = 1;
const char * const v5 = 0;
const struct s v6 = { 0, 0 };
const struct s v7 = { 0 };
void
f()
{
  const int v11;		/* { dg-warning ""invalid in C\[+\]\[+\]"" } */
  const char * const v12;	/* { dg-warning ""invalid in C\[+\]\[+\]"" } */
  const struct s v13;		/* { dg-warning ""invalid in C\[+\]\[+\]"" } */
  const int v14 = 1;
  const char * const v15 = 0;
  const struct s v16 = { 0, 0 };
  const struct s v17 = { 0 };
}
"
"/* { dg-do compile } */
/* { dg-options ""-O2 -fdump-tree-vrp1"" } */

unsigned char c[0xFF];
void f(void)
{
  unsigned char i;
  c[128] = 128;
  i = 0;
  while (1)
  {
    /* This predicate should not be folded out.  */
    if (((signed char) i) < 0) break;
    c[i] = ' ';
    i++;
  }
}

/* { dg-final { scan-tree-dump-times ""Folding predicate "" 0 ""vrp1"" } } */
","/* { dg-do compile } */
/* { dg-options ""-O2 -fdump-tree-vrp1"" } */

unsigned char c[0xFF];
void f(void)
{
  unsigned char i;
  c[128] = 128;
  i = 0;
  while (1)
  {
    /* This predicate should not be folded out.  */
    if (((signed char) i) < 0) break;
    c[i] = ' ';
    i++;
  }
}

/* { dg-final { scan-tree-dump-times ""Folding predicate "" 0 ""vrp1"" } } */
"
"/* { dg-require-effective-target vect_float } */
/* { dg-require-effective-target vect_intfloat_cvt } */
#include <stdarg.h>
#include ""tree-vect.h""

#define N 160
float image[2*N][2*N][N] __attribute__ ((__aligned__(__BIGGEST_ALIGNMENT__)));

__attribute__ ((noinline)) void
foo (){
  int i,j,k;

 for (k=0; k<N; k++) {
  for (i = 0; i < N; i++) {
    for (j = 0; j < N; j+=2) {
      image[k][j][i] = j+i+k;
    }
  }
 }
}

int main (void)
{
  check_vect ();
  int i, j, k;

  foo ();

 for (k=0; k<N; k++) {
  for (i = 0; i < N; i++) {
    for (j = 0; j < N; j+=2) {
      if (image[k][j][i] != j+i+k)
	abort ();
    }
  }
 }

  return 0;
}

/* { dg-final { scan-tree-dump-times ""OUTER LOOP VECTORIZED"" 1 ""vect"" } } */
","/* { dg-require-effective-target vect_float } */
/* { dg-require-effective-target vect_intfloat_cvt } */
#include <stdarg.h>
#include ""tree-vect.h""

#define N 160
float image[2*N][2*N][N] __attribute__ ((__aligned__(__BIGGEST_ALIGNMENT__)));

__attribute__ ((noinline)) void
foo (){
  int i,j,k;

 for (k=0; k<N; k++) {
  for (i = 0; i < N; i++) {
    for (j = 0; j < N; j+=2) {
      image[k][j][i] = j+i+k;
    }
  }
 }
}

int main (void)
{
  check_vect ();
  int i, j, k;

  foo ();

 for (k=0; k<N; k++) {
  for (i = 0; i < N; i++) {
    for (j = 0; j < N; j+=2) {
      if (image[k][j][i] != j+i+k)
	abort ();
    }
  }
 }

  return 0;
}

/* { dg-final { scan-tree-dump-times ""OUTER LOOP VECTORIZED"" 1 ""vect"" } } */
"
"/* { dg-do compile } */
/* { dg-options ""-O3 -mcpu=cortex-a72+crypto -dp"" } */

#include <arm_neon.h>

#define AESE(r, v, key) (r = vaesdq_u8 ((v), (key)));
#define AESMC(r, i) (r = vaesimcq_u8 (i))

uint8x16_t dummy;
uint8x16_t a;
uint8x16_t b;
uint8x16_t c;
uint8x16_t d;
uint8x16_t e;

void
foo (void)
{
  AESE (a, a, e);
  dummy = vaddq_u8 (dummy, dummy);
  dummy = vaddq_u8 (dummy, dummy);
  AESE (b, b, e);
  dummy = vaddq_u8 (dummy, dummy);
  dummy = vaddq_u8 (dummy, dummy);
  AESE (c, c, e);
  dummy = vaddq_u8 (dummy, dummy);
  dummy = vaddq_u8 (dummy, dummy);
  AESE (d, d, e);
  dummy = vaddq_u8 (dummy, dummy);
  dummy = vaddq_u8 (dummy, dummy);

  AESMC (a, a);
  dummy = vaddq_u8 (dummy, dummy);
  dummy = vaddq_u8 (dummy, dummy);
  AESMC (b, b);
  dummy = vaddq_u8 (dummy, dummy);
  dummy = vaddq_u8 (dummy, dummy);
  AESMC (c, c);
  dummy = vaddq_u8 (dummy, dummy);
  dummy = vaddq_u8 (dummy, dummy);
  AESMC (d, d);
}

/* { dg-final { scan-assembler-times ""crypto_aesd_fused"" 4 } } */

","/* { dg-do compile } */
/* { dg-options ""-O3 -mcpu=cortex-a72+crypto -dp"" } */

#include <arm_neon.h>

#define AESE(r, v, key) (r = vaesdq_u8 ((v), (key)));
#define AESMC(r, i) (r = vaesimcq_u8 (i))

uint8x16_t dummy;
uint8x16_t a;
uint8x16_t b;
uint8x16_t c;
uint8x16_t d;
uint8x16_t e;

void
foo (void)
{
  AESE (a, a, e);
  dummy = vaddq_u8 (dummy, dummy);
  dummy = vaddq_u8 (dummy, dummy);
  AESE (b, b, e);
  dummy = vaddq_u8 (dummy, dummy);
  dummy = vaddq_u8 (dummy, dummy);
  AESE (c, c, e);
  dummy = vaddq_u8 (dummy, dummy);
  dummy = vaddq_u8 (dummy, dummy);
  AESE (d, d, e);
  dummy = vaddq_u8 (dummy, dummy);
  dummy = vaddq_u8 (dummy, dummy);

  AESMC (a, a);
  dummy = vaddq_u8 (dummy, dummy);
  dummy = vaddq_u8 (dummy, dummy);
  AESMC (b, b);
  dummy = vaddq_u8 (dummy, dummy);
  dummy = vaddq_u8 (dummy, dummy);
  AESMC (c, c);
  dummy = vaddq_u8 (dummy, dummy);
  dummy = vaddq_u8 (dummy, dummy);
  AESMC (d, d);
}

/* { dg-final { scan-assembler-times ""crypto_aesd_fused"" 4 } } */

"
"/* PR target/82145 */
/* { dg-do compile { target { pie && lp64 } } } */
/* { dg-options ""-O2 -fpie -mcmodel=large -march=haswell"" } */

int l;

int
main ()
{
  l++;
  return 0;
}
","/* PR target/82145 */
/* { dg-do compile { target { pie && lp64 } } } */
/* { dg-options ""-O2 -fpie -mcmodel=large -march=haswell"" } */

int l;

int
main ()
{
  l++;
  return 0;
}
"
"/* { dg-do compile { target fpic } } */
/* { dg-options ""-fpic -O2"" } */

void f (char *s)
{
  for (;;)
    {
      int t = 6;
      switch (t)
	{
	case 2:
	  *s = '2';
	case 6: case 4: case 3: case 1:
	  break;
	}
    }
}
","/* { dg-do compile { target fpic } } */
/* { dg-options ""-fpic -O2"" } */

void f (char *s)
{
  for (;;)
    {
      int t = 6;
      switch (t)
	{
	case 2:
	  *s = '2';
	case 6: case 4: case 3: case 1:
	  break;
	}
    }
}
"
"/* { dg-do compile } */

void
flarm(void)
{
  static void foo();  /* { dg-error ""invalid storage class"" } */

  foo();
}
","/* { dg-do compile } */

void
flarm(void)
{
  static void foo();  /* { dg-error ""invalid storage class"" } */

  foo();
}
"
"/* { dg-do compile { target { double_fpu } } }  */
/* { dg-options ""-O2 -fomit-frame-pointer"" } */
/* { dg-final { scan-assembler ""mov #?0,r.*; mov #?20,r"" } } */
/* { dg-final { scan-assembler ""mov #?1077149696,r.*; mov #?0,r"" } } */
double
f ()
{
  double r;

  asm (""mov %S1,%S0; mov %R1,%R0"" : ""=r"" (r) : ""i"" (20));
  asm (""mov %S1,%S0; mov %R1,%R0"" : ""+r"" (r) : ""i"" (20.));
  return r;
}
","/* { dg-do compile { target { double_fpu } } }  */
/* { dg-options ""-O2 -fomit-frame-pointer"" } */
/* { dg-final { scan-assembler ""mov #?0,r.*; mov #?20,r"" } } */
/* { dg-final { scan-assembler ""mov #?1077149696,r.*; mov #?0,r"" } } */
double
f ()
{
  double r;

  asm (""mov %S1,%S0; mov %R1,%R0"" : ""=r"" (r) : ""i"" (20));
  asm (""mov %S1,%S0; mov %R1,%R0"" : ""+r"" (r) : ""i"" (20.));
  return r;
}
"
"/* { dg-do run } */
/* { dg-require-effective-target tls_native } */
/* { dg-require-effective-target aarch64_tlsle32 } */
/* { dg-options ""-O2 -fpic -ftls-model=local-exec -mtls-size=32 --save-temps"" } */

#include ""tls_1.x""

/* { dg-final { scan-assembler-times ""#:tprel_g1"" 2 } } */
/* { dg-final { scan-assembler-times ""#:tprel_g0_nc"" 2 } } */
/* { dg-final { cleanup-saved-temps } } */
","/* { dg-do run } */
/* { dg-require-effective-target tls_native } */
/* { dg-require-effective-target aarch64_tlsle32 } */
/* { dg-options ""-O2 -fpic -ftls-model=local-exec -mtls-size=32 --save-temps"" } */

#include ""tls_1.x""

/* { dg-final { scan-assembler-times ""#:tprel_g1"" 2 } } */
/* { dg-final { scan-assembler-times ""#:tprel_g0_nc"" 2 } } */
/* { dg-final { cleanup-saved-temps } } */
"
"/* { dg-do compile } */
/* { dg-options ""-O -fno-trapping-math -fdump-tree-ifcombine-details-blocks"" } */

double test1 (double i, double j)
{
  if (i >= j)
    if (i <= j)
      goto plif;
    else
      goto plouf;
  else
    goto plif;

plif:
  return 0;
plouf:
  return -1;
}

/* The above should be optimized to a i > j test by ifcombine.
   The transformation would also be legal with -ftrapping-math.
   Instead we get u<=, which is acceptable with -fno-trapping-math.  */

/* { dg-final { scan-tree-dump "" u<= "" ""ifcombine"" } } */
/* { dg-final { scan-tree-dump-not ""Invalid sum"" ""ifcombine"" } } */
","/* { dg-do compile } */
/* { dg-options ""-O -fno-trapping-math -fdump-tree-ifcombine-details-blocks"" } */

double test1 (double i, double j)
{
  if (i >= j)
    if (i <= j)
      goto plif;
    else
      goto plouf;
  else
    goto plif;

plif:
  return 0;
plouf:
  return -1;
}

/* The above should be optimized to a i > j test by ifcombine.
   The transformation would also be legal with -ftrapping-math.
   Instead we get u<=, which is acceptable with -fno-trapping-math.  */

/* { dg-final { scan-tree-dump "" u<= "" ""ifcombine"" } } */
/* { dg-final { scan-tree-dump-not ""Invalid sum"" ""ifcombine"" } } */
"
"/* Verify that overloaded built-ins for vec_add with float and
   double inputs for VSX produce the right results.  */

/* { dg-do compile } */
/* { dg-require-effective-target powerpc_vsx_ok } */
/* { dg-options ""-maltivec -mvsx"" } */

#include <altivec.h>

vector float
test1 (vector float x, vector float y)
{
  return vec_add (x, y);
}

vector double
test2 (vector double x, vector double y)
{
  return vec_add (x, y);
}

/* { dg-final { scan-assembler-times ""xvaddsp"" 1 } } */
/* { dg-final { scan-assembler-times ""xvadddp"" 1 } } */
","/* Verify that overloaded built-ins for vec_add with float and
   double inputs for VSX produce the right results.  */

/* { dg-do compile } */
/* { dg-require-effective-target powerpc_vsx_ok } */
/* { dg-options ""-maltivec -mvsx"" } */

#include <altivec.h>

vector float
test1 (vector float x, vector float y)
{
  return vec_add (x, y);
}

vector double
test2 (vector double x, vector double y)
{
  return vec_add (x, y);
}

/* { dg-final { scan-assembler-times ""xvaddsp"" 1 } } */
/* { dg-final { scan-assembler-times ""xvadddp"" 1 } } */
"
"/* { dg-do compile } */
/* { dg-options ""-std=gnu99"" } */
/* Check that 'noreturn' and 'volatile extern' are compatible.  
   The testsuite uses -ansi -pedantic-errors by default, so this has
   to override.  */
extern void xxx (int) __attribute__((noreturn));
typedef void voidfn (int);
__volatile extern voidfn xxx;
","/* { dg-do compile } */
/* { dg-options ""-std=gnu99"" } */
/* Check that 'noreturn' and 'volatile extern' are compatible.  
   The testsuite uses -ansi -pedantic-errors by default, so this has
   to override.  */
extern void xxx (int) __attribute__((noreturn));
typedef void voidfn (int);
__volatile extern voidfn xxx;
"
"/* { dg-do run } */
/* { dg-require-effective-target arm_v8_2a_fp16_scalar_hw } */
/* { dg-add-options arm_v8_2a_fp16_scalar }  */
/* { dg-skip-if """" { arm*-*-* } } */

#include <arm_fp16.h>

/* Input values.  */
float16_t input[] = { 123.9, -56.8, 0.7, 24.6, -63.5, 169.4, -4.3, 77.0 };
int16_t expected[] = { 124, -57, 1, 25, -64, 169, -4, 77 };

#define TEST_MSG ""VCVTAH_S16_F16""
#define INSN_NAME vcvtah_s16_f16

#define INPUT input
#define EXPECTED expected

#define INPUT_TYPE float16_t
#define OUTPUT_TYPE int16_t
#define OUTPUT_TYPE_SIZE 16

/* Include the template for unary scalar operations.  */
#include ""unary_scalar_op.inc""
","/* { dg-do run } */
/* { dg-require-effective-target arm_v8_2a_fp16_scalar_hw } */
/* { dg-add-options arm_v8_2a_fp16_scalar }  */
/* { dg-skip-if """" { arm*-*-* } } */

#include <arm_fp16.h>

/* Input values.  */
float16_t input[] = { 123.9, -56.8, 0.7, 24.6, -63.5, 169.4, -4.3, 77.0 };
int16_t expected[] = { 124, -57, 1, 25, -64, 169, -4, 77 };

#define TEST_MSG ""VCVTAH_S16_F16""
#define INSN_NAME vcvtah_s16_f16

#define INPUT input
#define EXPECTED expected

#define INPUT_TYPE float16_t
#define OUTPUT_TYPE int16_t
#define OUTPUT_TYPE_SIZE 16

/* Include the template for unary scalar operations.  */
#include ""unary_scalar_op.inc""
"
"/* { dg-do run { target { powerpc*-*-linux* } } } */
/* { dg-options ""-mlong-double-128"" } */

/* Check if adding a qNAN and a normal long double does not generate a
   inexact exception.  */

#define _GNU_SOURCE
#include <fenv.h>

int main(void)
{
  double x = __builtin_nan ("""");
  long double y = 1.1L;

  feenableexcept (FE_INEXACT);
  feclearexcept (FE_ALL_EXCEPT);
  x = x + y;
  return fetestexcept(FE_INEXACT);
}
","/* { dg-do run { target { powerpc*-*-linux* } } } */
/* { dg-options ""-mlong-double-128"" } */

/* Check if adding a qNAN and a normal long double does not generate a
   inexact exception.  */

#define _GNU_SOURCE
#include <fenv.h>

int main(void)
{
  double x = __builtin_nan ("""");
  long double y = 1.1L;

  feenableexcept (FE_INEXACT);
  feclearexcept (FE_ALL_EXCEPT);
  x = x + y;
  return fetestexcept(FE_INEXACT);
}
"
"/* Test AAPCS layout (alignment) for callee.  */

/* { dg-do run { target arm_eabi } } */
/* { dg-require-effective-target arm32 } */
/* { dg-options ""-O2 -fno-inline"" } */

extern void abort (void);

typedef __attribute__((aligned (8))) int alignedint;

alignedint a = 11;
alignedint b = 13;
alignedint c = 17;
alignedint d = 19;
alignedint e = 23;
alignedint f = 29;

void
foo (alignedint r0, alignedint r1, alignedint r2, alignedint r3,
     alignedint stack, alignedint stack4)
{
  if (r0 != a
      || r1 != b
      || r2 != c
      || r3 != d
      || stack != e
      || stack4 !=f)
    abort ();
}

int
main (int argc, char **argv)
{
  foo (a, b, c, d, e, f);
  return 0;
}
","/* Test AAPCS layout (alignment) for callee.  */

/* { dg-do run { target arm_eabi } } */
/* { dg-require-effective-target arm32 } */
/* { dg-options ""-O2 -fno-inline"" } */

extern void abort (void);

typedef __attribute__((aligned (8))) int alignedint;

alignedint a = 11;
alignedint b = 13;
alignedint c = 17;
alignedint d = 19;
alignedint e = 23;
alignedint f = 29;

void
foo (alignedint r0, alignedint r1, alignedint r2, alignedint r3,
     alignedint stack, alignedint stack4)
{
  if (r0 != a
      || r1 != b
      || r2 != c
      || r3 != d
      || stack != e
      || stack4 !=f)
    abort ();
}

int
main (int argc, char **argv)
{
  foo (a, b, c, d, e, f);
  return 0;
}
"
"foo (a)
     double a;
{
  if (a >= 0)
    return 1;
  return a;
}
","foo (a)
     double a;
{
  if (a >= 0)
    return 1;
  return a;
}
"
"char a;
short b, d = 5, h;
char c[1];
int e, f = 4, g, j;
int main() {
  int i;
  for (; f; f = a) {
    g = 0;
    for (; g <= 32; ++g) {
      i = 0;
      for (; i < 3; i++)
        while (1 > d)
          if (c[b])
            break;
    L:
      if (j)
        break;
    }
  }
  e = 0;
  for (; e; e = 0) {
    d++;
    for (; h;)
      goto L;
  }
  return 0;
}

","char a;
short b, d = 5, h;
char c[1];
int e, f = 4, g, j;
int main() {
  int i;
  for (; f; f = a) {
    g = 0;
    for (; g <= 32; ++g) {
      i = 0;
      for (; i < 3; i++)
        while (1 > d)
          if (c[b])
            break;
    L:
      if (j)
        break;
    }
  }
  e = 0;
  for (; e; e = 0) {
    d++;
    for (; h;)
      goto L;
  }
  return 0;
}

"
"/* PR tree-optimization/72824 */

typedef float V __attribute__((vector_size (4 * sizeof (float))));

static inline void
foo (V *x, V value)
{
  int i;
  for (i = 0; i < 32; ++i)
    x[i] = value;
}

int
main ()
{
  V x[32];
  foo (x, (V) { 0.f, -0.f, 0.f, -0.f });
  if (__builtin_copysignf (1.0, x[3][1]) != -1.0f)
    __builtin_abort ();
  return 0;
}
","/* PR tree-optimization/72824 */

typedef float V __attribute__((vector_size (4 * sizeof (float))));

static inline void
foo (V *x, V value)
{
  int i;
  for (i = 0; i < 32; ++i)
    x[i] = value;
}

int
main ()
{
  V x[32];
  foo (x, (V) { 0.f, -0.f, 0.f, -0.f });
  if (__builtin_copysignf (1.0, x[3][1]) != -1.0f)
    __builtin_abort ();
  return 0;
}
"
"/* { dg-do compile } */
/* { dg-options ""-O -funroll-loops -fcompare-debug"" } */

struct S {
 int i;
};

extern void baz(int);

static inline void bar(struct S *s)
{
  baz(s->i);
}

void foo(int *w, int cond, struct S *s)
{
  int i, n = 0;
  while (*w++ != 0) n++;
  for (i = 0; i < n; i++)
    if (cond == 0)
      bar(s + i);
}
","/* { dg-do compile } */
/* { dg-options ""-O -funroll-loops -fcompare-debug"" } */

struct S {
 int i;
};

extern void baz(int);

static inline void bar(struct S *s)
{
  baz(s->i);
}

void foo(int *w, int cond, struct S *s)
{
  int i, n = 0;
  while (*w++ != 0) n++;
  for (i = 0; i < n; i++)
    if (cond == 0)
      bar(s + i);
}
"
"/* { dg-lto-do run } */
/* { dg-lto-options ""-O3"" } */

/* By C standard Each enumerated type shall be compatible with char, a  signed
   integer, type, or an unsigned integer type. The choice of type is
   implementation-defined.  Check that enum and unsigned int match.  */
unsigned int a;
unsigned int *b;
void t();

void reset ()
{
  asm("""":""=r""(a):""0""(0));
}
int
main()
{
  asm("""":""=r""(a):""0""(1));
  asm("""":""=r""(b):""0""(&a));
  t();
  return 0;
}
","/* { dg-lto-do run } */
/* { dg-lto-options ""-O3"" } */

/* By C standard Each enumerated type shall be compatible with char, a  signed
   integer, type, or an unsigned integer type. The choice of type is
   implementation-defined.  Check that enum and unsigned int match.  */
unsigned int a;
unsigned int *b;
void t();

void reset ()
{
  asm("""":""=r""(a):""0""(0));
}
int
main()
{
  asm("""":""=r""(a):""0""(1));
  asm("""":""=r""(b):""0""(&a));
  t();
  return 0;
}
"
"/* { dg-do assemble } */
/* { dg-options ""-std=c99"" } */
#include <arm_neon.h>

int
main (int argc, char **argv)
{
  uint64x1_t base_b = vcreate_u64 (0x5555666677778888ULL);
  uint64x1_t base_a = vcreate_u64 (0x1111222233334444ULL);
  uint64x1_t base_c = vcreate_u64 (0x9999aaaabbbbccccULL);
  uint64x2_t baseq_c = vcombine_u64 (base_c, base_a);
  uint64x2_t baseq_a = vcombine_u64 (base_a, base_b);
  int32x2_t int32x2_b = vreinterpret_s32_u64 (base_b);
  int32x4_t int32x4_c = vreinterpretq_s32_u64 (baseq_c);
  int64x2_t int64x2_a = vreinterpretq_s64_u64 (baseq_a);

  /* { dg-error ""lane -1 out of range 0 - 3"" """" {target *-*-*} 0 } */
  vqdmlsl_laneq_s32 (int64x2_a, int32x2_b, int32x4_c, -1);
  /* { dg-error ""lane 4 out of range 0 - 3"" """" {target *-*-*} 0 } */
  vqdmlsl_laneq_s32 (int64x2_a, int32x2_b, int32x4_c, 4);
}
","/* { dg-do assemble } */
/* { dg-options ""-std=c99"" } */
#include <arm_neon.h>

int
main (int argc, char **argv)
{
  uint64x1_t base_b = vcreate_u64 (0x5555666677778888ULL);
  uint64x1_t base_a = vcreate_u64 (0x1111222233334444ULL);
  uint64x1_t base_c = vcreate_u64 (0x9999aaaabbbbccccULL);
  uint64x2_t baseq_c = vcombine_u64 (base_c, base_a);
  uint64x2_t baseq_a = vcombine_u64 (base_a, base_b);
  int32x2_t int32x2_b = vreinterpret_s32_u64 (base_b);
  int32x4_t int32x4_c = vreinterpretq_s32_u64 (baseq_c);
  int64x2_t int64x2_a = vreinterpretq_s64_u64 (baseq_a);

  /* { dg-error ""lane -1 out of range 0 - 3"" """" {target *-*-*} 0 } */
  vqdmlsl_laneq_s32 (int64x2_a, int32x2_b, int32x4_c, -1);
  /* { dg-error ""lane 4 out of range 0 - 3"" """" {target *-*-*} 0 } */
  vqdmlsl_laneq_s32 (int64x2_a, int32x2_b, int32x4_c, 4);
}
"
"extern void abort (void);
int __attribute__((noinline,noclone))
foo (char *p)
{
  int h = 0;
  do
    {
      if (*p == '\0')
	break;
      ++h;
      if (p == 0)
	abort ();
      ++p;
    }
  while (1);
  return h;
}
int main()
{
  if (foo(""a"") != 1)
    abort ();
  return 0;
}
","extern void abort (void);
int __attribute__((noinline,noclone))
foo (char *p)
{
  int h = 0;
  do
    {
      if (*p == '\0')
	break;
      ++h;
      if (p == 0)
	abort ();
      ++p;
    }
  while (1);
  return h;
}
int main()
{
  if (foo(""a"") != 1)
    abort ();
  return 0;
}
"
"/* Test that the compiler properly optimizes vector shift instructions into
   psha/pshl on XOP systems.  */

/* { dg-do compile { target { ! ia32 } } } */
/* { dg-options ""-O2 -mxop -mno-avx2 -ftree-vectorize"" } */

extern void exit (int);

typedef long __m128i  __attribute__ ((__vector_size__ (16), __may_alias__));

#define SIZE 10240

union {
  __m128i i_align;
  int i32[SIZE];
  unsigned u32[SIZE];
} a, b, c;

void
right_uns_shift32 (void)
{
  int i;

  for (i = 0; i < SIZE; i++)
    a.u32[i] = b.u32[i] >> c.i32[i];
}

int main ()
{
  right_uns_shift32 ();
  exit (0);
}

/* { dg-final { scan-assembler ""vpshld"" } } */
","/* Test that the compiler properly optimizes vector shift instructions into
   psha/pshl on XOP systems.  */

/* { dg-do compile { target { ! ia32 } } } */
/* { dg-options ""-O2 -mxop -mno-avx2 -ftree-vectorize"" } */

extern void exit (int);

typedef long __m128i  __attribute__ ((__vector_size__ (16), __may_alias__));

#define SIZE 10240

union {
  __m128i i_align;
  int i32[SIZE];
  unsigned u32[SIZE];
} a, b, c;

void
right_uns_shift32 (void)
{
  int i;

  for (i = 0; i < SIZE; i++)
    a.u32[i] = b.u32[i] >> c.i32[i];
}

int main ()
{
  right_uns_shift32 ();
  exit (0);
}

/* { dg-final { scan-assembler ""vpshld"" } } */
"
"/* { dg-do run } */
/* { dg-options ""-O3 -std=gnu99"" } */

int a, b, c, d, e, h;

int
fn1 (int p1)
{
  {
    int g[2];
    for (int i = 0; i < 1; i++)
      g[i] = 0;
    if (g[0] < c)
      {
	a = (unsigned) (1 ^ p1) % 2;
	return 0;
      }
  }
  return 0;
}

void
fn2 ()
{
  for (h = 0; h < 1; h++)
    {
      for (int j = 0; j < 2; j++)
	{
	  for (b = 1; b; b = 0)
	    a = 1;
	  for (; b < 1; b++)
	    ;
	  if (e)
	    continue;
	  a = 2;
	}
      fn1 (h);
      short k = -16;
      d = k > a;
    }
}

int
main ()
{
  fn2 ();

  if (a != 2)
    __builtin_abort ();

  return 0;
}

","/* { dg-do run } */
/* { dg-options ""-O3 -std=gnu99"" } */

int a, b, c, d, e, h;

int
fn1 (int p1)
{
  {
    int g[2];
    for (int i = 0; i < 1; i++)
      g[i] = 0;
    if (g[0] < c)
      {
	a = (unsigned) (1 ^ p1) % 2;
	return 0;
      }
  }
  return 0;
}

void
fn2 ()
{
  for (h = 0; h < 1; h++)
    {
      for (int j = 0; j < 2; j++)
	{
	  for (b = 1; b; b = 0)
	    a = 1;
	  for (; b < 1; b++)
	    ;
	  if (e)
	    continue;
	  a = 2;
	}
      fn1 (h);
      short k = -16;
      d = k > a;
    }
}

int
main ()
{
  fn2 ();

  if (a != 2)
    __builtin_abort ();

  return 0;
}

"
"/* { dg-do compile { target { ! ia32 } } } */
/* { dg-options ""-O2 -mavx512vl -mno-avx512bw"" } */

#include <x86intrin.h>

void
f1 (__m128i x, __m128i y)
{
  register __m128i a __asm (""xmm16""), b __asm (""xmm17"");
  a = x;
  b = y;
  asm volatile ("""" : ""+v"" (a), ""+v"" (b));
  a = _mm_mulhrs_epi16 (a, b);
  asm volatile ("""" : ""+v"" (a));
}

/* { dg-final { scan-assembler-not ""vpmulhrsw\[^\n\r]*xmm1\[67]"" } } */

void
f2 (__m256i x, __m256i y)
{
  register __m256i a __asm (""xmm16""), b __asm (""xmm17"");
  a = x;
  b = y;
  asm volatile ("""" : ""+v"" (a), ""+v"" (b));
  a = _mm256_mulhrs_epi16 (a, b);
  asm volatile ("""" : ""+v"" (a));
}

/* { dg-final { scan-assembler-not ""vpmulhrsw\[^\n\r]*ymm1\[67]"" } } */
","/* { dg-do compile { target { ! ia32 } } } */
/* { dg-options ""-O2 -mavx512vl -mno-avx512bw"" } */

#include <x86intrin.h>

void
f1 (__m128i x, __m128i y)
{
  register __m128i a __asm (""xmm16""), b __asm (""xmm17"");
  a = x;
  b = y;
  asm volatile ("""" : ""+v"" (a), ""+v"" (b));
  a = _mm_mulhrs_epi16 (a, b);
  asm volatile ("""" : ""+v"" (a));
}

/* { dg-final { scan-assembler-not ""vpmulhrsw\[^\n\r]*xmm1\[67]"" } } */

void
f2 (__m256i x, __m256i y)
{
  register __m256i a __asm (""xmm16""), b __asm (""xmm17"");
  a = x;
  b = y;
  asm volatile ("""" : ""+v"" (a), ""+v"" (b));
  a = _mm256_mulhrs_epi16 (a, b);
  asm volatile ("""" : ""+v"" (a));
}

/* { dg-final { scan-assembler-not ""vpmulhrsw\[^\n\r]*ymm1\[67]"" } } */
"
"/* PR target/59880 */
/* { dg-do compile { target { ! ia32 } } } */
/* { dg-options ""-O2 -mtune=silvermont"" } */

register unsigned int r13 __asm (""r13"");
unsigned long long
foo (void)
{
  return r13;
}

/* Ensure we don't emit a useless zero-extension after another
   zero-extension.  */
/* { dg-final { scan-assembler-not ""%eax, %eax"" } } */
","/* PR target/59880 */
/* { dg-do compile { target { ! ia32 } } } */
/* { dg-options ""-O2 -mtune=silvermont"" } */

register unsigned int r13 __asm (""r13"");
unsigned long long
foo (void)
{
  return r13;
}

/* Ensure we don't emit a useless zero-extension after another
   zero-extension.  */
/* { dg-final { scan-assembler-not ""%eax, %eax"" } } */
"
"/* { dg-do run { target aarch64_sve_hw } } */
/* { dg-options ""-O2 -ftree-vectorize"" } */

#include ""pack_1.c""

#define ARRAY_SIZE 57

#define TEST_LOOP(TYPED, TYPES)					\
  {								\
    TYPED arrayd[ARRAY_SIZE];					\
    TYPES arrays[ARRAY_SIZE];					\
    for (int i = 0; i < ARRAY_SIZE; i++)			\
      {								\
	arrays[i] = (i - 10) * 3;				\
	asm volatile ("""" ::: ""memory"");				\
      }								\
    pack_##TYPED##_##TYPES (arrayd, arrays, ARRAY_SIZE);	\
    for (int i = 0; i < ARRAY_SIZE; i++)			\
      if (arrayd[i] != (TYPED) ((TYPES) ((i - 10) * 3) + 1))	\
	__builtin_abort ();					\
  }

int __attribute__ ((optimize (1)))
main (void)
{
  TEST_ALL (TEST_LOOP)
  return 0;
}
","/* { dg-do run { target aarch64_sve_hw } } */
/* { dg-options ""-O2 -ftree-vectorize"" } */

#include ""pack_1.c""

#define ARRAY_SIZE 57

#define TEST_LOOP(TYPED, TYPES)					\
  {								\
    TYPED arrayd[ARRAY_SIZE];					\
    TYPES arrays[ARRAY_SIZE];					\
    for (int i = 0; i < ARRAY_SIZE; i++)			\
      {								\
	arrays[i] = (i - 10) * 3;				\
	asm volatile ("""" ::: ""memory"");				\
      }								\
    pack_##TYPED##_##TYPES (arrayd, arrays, ARRAY_SIZE);	\
    for (int i = 0; i < ARRAY_SIZE; i++)			\
      if (arrayd[i] != (TYPED) ((TYPES) ((i - 10) * 3) + 1))	\
	__builtin_abort ();					\
  }

int __attribute__ ((optimize (1)))
main (void)
{
  TEST_ALL (TEST_LOOP)
  return 0;
}
"
"/* PR target/pr78794 */
/* { dg-do compile { target ia32 } } */
/* { dg-options ""-O2 -march=slm -mno-bmi -mno-stackrealign"" } */
/* { dg-final { scan-assembler ""pandn"" } } */

typedef unsigned long long ull;

struct S1
{
  float x;
  ull y;
};


struct S2
{
  int a1;
  struct S1 *node;
  int *a2;
};

void
foo(int c1, int c2, int c3, struct S2 *reg)
{
  int i;
  for(i=0; i<reg->a1; i++)
    if(reg->node[i].y & ((ull) 1 << c1))
      {
	if(reg->node[i].y & ((ull) 1 << c2))
	  reg->node[i].y ^= ((ull) 1 << c3);
      }
}
","/* PR target/pr78794 */
/* { dg-do compile { target ia32 } } */
/* { dg-options ""-O2 -march=slm -mno-bmi -mno-stackrealign"" } */
/* { dg-final { scan-assembler ""pandn"" } } */

typedef unsigned long long ull;

struct S1
{
  float x;
  ull y;
};


struct S2
{
  int a1;
  struct S1 *node;
  int *a2;
};

void
foo(int c1, int c2, int c3, struct S2 *reg)
{
  int i;
  for(i=0; i<reg->a1; i++)
    if(reg->node[i].y & ((ull) 1 << c1))
      {
	if(reg->node[i].y & ((ull) 1 << c2))
	  reg->node[i].y ^= ((ull) 1 << c3);
      }
}
"
"/* { dg-do preprocess } */
/* { dg-options ""-nostdinc -P -dU"" } */
/* { dg-final { scan-file cmdlne-dU-4.i ""^\n*#undef A\n*$"" } } */
#if defined(A)
#endif
","/* { dg-do preprocess } */
/* { dg-options ""-nostdinc -P -dU"" } */
/* { dg-final { scan-file cmdlne-dU-4.i ""^\n*#undef A\n*$"" } } */
#if defined(A)
#endif
"
"/* { dg-do compile } */ 
/* { dg-options ""-O2 -fno-tree-vrp -fdump-tree-dom2-details"" } */
void t(void);
void q(void);
void q1(void);
void
threading(int a,int b)
{
	if (a>b)
	  t();
	else
	  q();
	if (a<=b)
	  q1();
}
/* We should thread the jump twice and elliminate it.  */
/* { dg-final { scan-tree-dump-times ""Threaded"" 2 ""dom2""} } */
","/* { dg-do compile } */ 
/* { dg-options ""-O2 -fno-tree-vrp -fdump-tree-dom2-details"" } */
void t(void);
void q(void);
void q1(void);
void
threading(int a,int b)
{
	if (a>b)
	  t();
	else
	  q();
	if (a<=b)
	  q1();
}
/* We should thread the jump twice and elliminate it.  */
/* { dg-final { scan-tree-dump-times ""Threaded"" 2 ""dom2""} } */
"
"/* { dg-require-effective-target vect_condition } */

#include ""tree-vect.h""

#define N 16

int c[N] = {3,2,1,10,1,42,3,4,50,9,32,8,11,10,1,2};
int a[N+1] = {0,16,32,48,64,128,256,512,0,16,32,48,64,128,256,512,1024};

__attribute__ ((noinline)) void 
foo (int *x)
{
  int i;
  int curr_a, flag, next_a;

  curr_a = a[0];

  for (i = 0; i < N; i++) 
    {
      flag = *x > c[i];
      next_a = a[i+1];
      curr_a = flag ? curr_a : next_a;
    }

  *x = curr_a;
}

int main (void)
{
  int x = 7;

  check_vect ();

  foo (&x);

  if (x != 256)
    abort ();

  return 0;
}

/* { dg-final { scan-tree-dump-times ""vectorized 1 loops"" 1 ""vect"" } } */
","/* { dg-require-effective-target vect_condition } */

#include ""tree-vect.h""

#define N 16

int c[N] = {3,2,1,10,1,42,3,4,50,9,32,8,11,10,1,2};
int a[N+1] = {0,16,32,48,64,128,256,512,0,16,32,48,64,128,256,512,1024};

__attribute__ ((noinline)) void 
foo (int *x)
{
  int i;
  int curr_a, flag, next_a;

  curr_a = a[0];

  for (i = 0; i < N; i++) 
    {
      flag = *x > c[i];
      next_a = a[i+1];
      curr_a = flag ? curr_a : next_a;
    }

  *x = curr_a;
}

int main (void)
{
  int x = 7;

  check_vect ();

  foo (&x);

  if (x != 256)
    abort ();

  return 0;
}

/* { dg-final { scan-tree-dump-times ""vectorized 1 loops"" 1 ""vect"" } } */
"
"/* { dg-options ""-mshared -mabi=64 -mmicromips"" } */
/* { dg-final { scan-assembler ""\tdaddiu\t\\\$3,\\\$3,%lo\\(%neg\\(%gp_rel\\(foo\\)\\)\\)\n"" } } */
/* { dg-final { scan-assembler ""\tld\t\\\$1,%got_page\\(\[^)\]*\\)\\(\\\$3\\)\\n"" } } */
/* { dg-final { scan-assembler ""\tjr\t\\\$1\n"" } } */
/* { dg-final { scan-assembler-not ""\\\$28"" } } */

#include ""branch-helper.h""

NOMIPS16 void
foo (volatile int *x)
{
  if (__builtin_expect (*x == 0, 1))
    OCCUPY_0x10000;
}
","/* { dg-options ""-mshared -mabi=64 -mmicromips"" } */
/* { dg-final { scan-assembler ""\tdaddiu\t\\\$3,\\\$3,%lo\\(%neg\\(%gp_rel\\(foo\\)\\)\\)\n"" } } */
/* { dg-final { scan-assembler ""\tld\t\\\$1,%got_page\\(\[^)\]*\\)\\(\\\$3\\)\\n"" } } */
/* { dg-final { scan-assembler ""\tjr\t\\\$1\n"" } } */
/* { dg-final { scan-assembler-not ""\\\$28"" } } */

#include ""branch-helper.h""

NOMIPS16 void
foo (volatile int *x)
{
  if (__builtin_expect (*x == 0, 1))
    OCCUPY_0x10000;
}
"
"/* { dg-do compile } */

#define N       50
#define CHUNKSIZE   5

int
main ()
{
  int i, chunk;
  float c[N];

  chunk = CHUNKSIZE;
#pragma omp parallel for shared (c, chunk) schedule (dynamic, chunk)
  for (i = 0; i < N; i++)
    c[i] = i;

  return 0;
}
","/* { dg-do compile } */

#define N       50
#define CHUNKSIZE   5

int
main ()
{
  int i, chunk;
  float c[N];

  chunk = CHUNKSIZE;
#pragma omp parallel for shared (c, chunk) schedule (dynamic, chunk)
  for (i = 0; i < N; i++)
    c[i] = i;

  return 0;
}
"
"/* PR middle-end/37248 */
/* { dg-do compile } */
/* { dg-options ""-O2 -fdump-tree-optimized"" } */

struct S
{
  unsigned char a : 1;
  unsigned char b : 1;
  unsigned char c : 1;
} s;

int
foo (struct S x)
{
  return x.a && x.b && x.c;
}

/* { dg-final { scan-tree-dump ""& 7;"" ""optimized"" } } */
/* { dg-final { scan-tree-dump ""== 7;"" ""optimized"" } } */
","/* PR middle-end/37248 */
/* { dg-do compile } */
/* { dg-options ""-O2 -fdump-tree-optimized"" } */

struct S
{
  unsigned char a : 1;
  unsigned char b : 1;
  unsigned char c : 1;
} s;

int
foo (struct S x)
{
  return x.a && x.b && x.c;
}

/* { dg-final { scan-tree-dump ""& 7;"" ""optimized"" } } */
/* { dg-final { scan-tree-dump ""== 7;"" ""optimized"" } } */
"
"/* Test for string translation.  */
/* { dg-do compile }
   { dg-require-iconv ""IBM1047"" } 
   { dg-final { scan-assembler ""foo"" } } */
int main()
{
  unsigned long int *ptr;
  ptr = ((unsigned long int *)
         ( { void *stack_ptr;
           __asm__ __volatile__ ( ""foo %0"" : ""=r"" (stack_ptr) );
           (stack_ptr); } ) );
  return 0;
}
","/* Test for string translation.  */
/* { dg-do compile }
   { dg-require-iconv ""IBM1047"" } 
   { dg-final { scan-assembler ""foo"" } } */
int main()
{
  unsigned long int *ptr;
  ptr = ((unsigned long int *)
         ( { void *stack_ptr;
           __asm__ __volatile__ ( ""foo %0"" : ""=r"" (stack_ptr) );
           (stack_ptr); } ) );
  return 0;
}
"
"/* PR middle-end/58564 */

extern void abort (void);
int a, b;
short *c, **d = &c;

int
main ()
{
  b = (0, 0 > ((&c == d) & (1 && (a ^ 1)))) | 0U;
  if (b != 0)
    abort ();
  return 0;
}
","/* PR middle-end/58564 */

extern void abort (void);
int a, b;
short *c, **d = &c;

int
main ()
{
  b = (0, 0 > ((&c == d) & (1 && (a ^ 1)))) | 0U;
  if (b != 0)
    abort ();
  return 0;
}
"
"/* { dg-do compile { target { powerpc*-*-darwin* && lp64 } } } */
/* { dg-options ""-O1 -static"" } */
typedef unsigned long long uint64_t;

static int
match(name, pat)
 uint64_t *name, *pat;
{
 int ok=0, negate_range;
 uint64_t c, k;

  c = *pat++;
  switch (c & 0xffffffffffULL) {
  case ((uint64_t)(('[')|0x8000000000ULL)):
   if ((negate_range = ((*pat & 0xffffffffffULL) == ((uint64_t)(('!')|0x8000000000ULL)) )) != '\0')
    ++pat;
   while (((c = *pat++) & 0xffffffffffULL) )
    if ((*pat & 0xffffffffffULL) == ((uint64_t)(('-')|0x8000000000ULL))) 
      {
       pat += 2;
      } 

   if (ok == negate_range)
    return(0);
   break;
  }
 return(*name == '\0');
}

","/* { dg-do compile { target { powerpc*-*-darwin* && lp64 } } } */
/* { dg-options ""-O1 -static"" } */
typedef unsigned long long uint64_t;

static int
match(name, pat)
 uint64_t *name, *pat;
{
 int ok=0, negate_range;
 uint64_t c, k;

  c = *pat++;
  switch (c & 0xffffffffffULL) {
  case ((uint64_t)(('[')|0x8000000000ULL)):
   if ((negate_range = ((*pat & 0xffffffffffULL) == ((uint64_t)(('!')|0x8000000000ULL)) )) != '\0')
    ++pat;
   while (((c = *pat++) & 0xffffffffffULL) )
    if ((*pat & 0xffffffffffULL) == ((uint64_t)(('-')|0x8000000000ULL))) 
      {
       pat += 2;
      } 

   if (ok == negate_range)
    return(0);
   break;
  }
 return(*name == '\0');
}

"
"/* { dg-do run } */
/* { dg-options ""-fsanitize=unreachable"" } */
/* { dg-shouldfail ""ubsan"" } */

int
main (void)
{
  __builtin_unreachable ();
}
 /* { dg-output ""execution reached a __builtin_unreachable\\(\\) call"" } */
","/* { dg-do run } */
/* { dg-options ""-fsanitize=unreachable"" } */
/* { dg-shouldfail ""ubsan"" } */

int
main (void)
{
  __builtin_unreachable ();
}
 /* { dg-output ""execution reached a __builtin_unreachable\\(\\) call"" } */
"
"/* Test the vqdmlal_laneq_s32 AArch64 SIMD intrinsic.  */

/* { dg-do compile } */
/* { dg-options ""-save-temps -O3 -fno-inline"" } */

#include ""arm_neon.h""

int64x2_t
t_vqdmlal_laneq_s32 (int64x2_t a, int32x2_t b, int32x4_t c)
{
  return vqdmlal_laneq_s32 (a, b, c, 0);
}

/* { dg-final { scan-assembler-times ""sqdmlal\[ \t\]+\[vV\]\[0-9\]+\.2\[dD\], ?\[vV\]\[0-9\]+\.2\[sS\], ?\[vV\]\[0-9\]+\.\[sS\]\\\[0\\\]\n"" 1 } } */
","/* Test the vqdmlal_laneq_s32 AArch64 SIMD intrinsic.  */

/* { dg-do compile } */
/* { dg-options ""-save-temps -O3 -fno-inline"" } */

#include ""arm_neon.h""

int64x2_t
t_vqdmlal_laneq_s32 (int64x2_t a, int32x2_t b, int32x4_t c)
{
  return vqdmlal_laneq_s32 (a, b, c, 0);
}

/* { dg-final { scan-assembler-times ""sqdmlal\[ \t\]+\[vV\]\[0-9\]+\.2\[dD\], ?\[vV\]\[0-9\]+\.2\[sS\], ?\[vV\]\[0-9\]+\.\[sS\]\\\[0\\\]\n"" 1 } } */
"
"/* { dg-do run } */
/* { dg-require-effective-target sse4 } */
/* { dg-options ""-O2 -msse4.1"" } */
/* { dg-skip-if ""no M_PI"" { vxworks_kernel } } */

#include ""sse4_1-check.h""

#define VEC_T __m128d
#define FP_T double

#define ROUND_INTRIN(x, mode) _mm_ceil_sd(x, x)
#define ROUND_MODE _MM_FROUND_CEIL
#define CHECK_ROUND_MODE 0x02

#define LOOP_INCREMENT 2
#define CHECK_LOOP_INCREMENT 2

#include ""sse4_1-round.h""
","/* { dg-do run } */
/* { dg-require-effective-target sse4 } */
/* { dg-options ""-O2 -msse4.1"" } */
/* { dg-skip-if ""no M_PI"" { vxworks_kernel } } */

#include ""sse4_1-check.h""

#define VEC_T __m128d
#define FP_T double

#define ROUND_INTRIN(x, mode) _mm_ceil_sd(x, x)
#define ROUND_MODE _MM_FROUND_CEIL
#define CHECK_ROUND_MODE 0x02

#define LOOP_INCREMENT 2
#define CHECK_LOOP_INCREMENT 2

#include ""sse4_1-round.h""
"
"/* { dg-do compile } */
/* { dg-options ""-march=octeon2 -mgp64"" } */
/* { dg-skip-if ""code quality test"" { *-*-* } { ""-O0"" } { """" } } */

#define TEST(N, T) \
  T f##N (T *p, int i) { return p[i]; } \
  unsigned T g##N (unsigned T *p, int i) { return p[i]; }

TEST (1, char)
/* { dg-final { scan-assembler-times ""\tlbu?x\t"" 2 } } */
TEST (2, short)
/* { dg-final { scan-assembler-times ""\tlhu?x\t"" 2 } } */
TEST (3, int)
/* { dg-final { scan-assembler-times ""\tlwx\t"" 2 } } */
TEST (4, long long)
/* { dg-final { scan-assembler-times ""\tldx\t"" 2 } } */
","/* { dg-do compile } */
/* { dg-options ""-march=octeon2 -mgp64"" } */
/* { dg-skip-if ""code quality test"" { *-*-* } { ""-O0"" } { """" } } */

#define TEST(N, T) \
  T f##N (T *p, int i) { return p[i]; } \
  unsigned T g##N (unsigned T *p, int i) { return p[i]; }

TEST (1, char)
/* { dg-final { scan-assembler-times ""\tlbu?x\t"" 2 } } */
TEST (2, short)
/* { dg-final { scan-assembler-times ""\tlhu?x\t"" 2 } } */
TEST (3, int)
/* { dg-final { scan-assembler-times ""\tlwx\t"" 2 } } */
TEST (4, long long)
/* { dg-final { scan-assembler-times ""\tldx\t"" 2 } } */
"
"/* { dg-require-alias """" } */
#include ""20081222_0.h""

extern void abort (void);

int
main ()
{
  if (x () == 7)
    return 0;
  abort ();
}
","/* { dg-require-alias """" } */
#include ""20081222_0.h""

extern void abort (void);

int
main ()
{
  if (x () == 7)
    return 0;
  abort ();
}
"
"/* { dg-do compile { target { powerpc*-*-* } } } */
/* { dg-skip-if ""do not override -mcpu"" { powerpc*-*-* } { ""-mcpu=*"" } { ""-mcpu=power9"" } } */
/* { dg-require-effective-target powerpc_p9vector_ok } */
/* { dg-skip-if """" { powerpc*-*-aix* } } */
/* { dg-options ""-mcpu=power9"" } */

/* This test should succeed on both 32- and 64-bit configurations.  */
#include <altivec.h>

int get_random ()
{
  return __builtin_darn_32 ();
}

/* { dg-final { scan-assembler	   ""darn"" } } */
","/* { dg-do compile { target { powerpc*-*-* } } } */
/* { dg-skip-if ""do not override -mcpu"" { powerpc*-*-* } { ""-mcpu=*"" } { ""-mcpu=power9"" } } */
/* { dg-require-effective-target powerpc_p9vector_ok } */
/* { dg-skip-if """" { powerpc*-*-aix* } } */
/* { dg-options ""-mcpu=power9"" } */

/* This test should succeed on both 32- and 64-bit configurations.  */
#include <altivec.h>

int get_random ()
{
  return __builtin_darn_32 ();
}

/* { dg-final { scan-assembler	   ""darn"" } } */
"
"/* { dg-do link } */
/* { dg-options ""-O2"" } */

extern void link_error (void);

void test1(int i)
{
  if (i >= -5 && i <= 8)
    {
      unsigned int j = i + 1;
      if (j == -5)
	link_error ();
      if (j == 10)
	link_error ();
    }
}

void test2(unsigned int i)
{
  if (i >= -5 || i <= 8)
    {
      int j = i;
      if (j == -6)
	link_error ();
      if (j == 9)
	link_error ();
    }
}

int main() { return 0; }
","/* { dg-do link } */
/* { dg-options ""-O2"" } */

extern void link_error (void);

void test1(int i)
{
  if (i >= -5 && i <= 8)
    {
      unsigned int j = i + 1;
      if (j == -5)
	link_error ();
      if (j == 10)
	link_error ();
    }
}

void test2(unsigned int i)
{
  if (i >= -5 || i <= 8)
    {
      int j = i;
      if (j == -6)
	link_error ();
      if (j == 9)
	link_error ();
    }
}

int main() { return 0; }
"
"extern void abort (void);

typedef short  __v2hi __attribute ((vector_size(4)));
typedef __v2hi fract2x16;
typedef short fract16;

int main ()
{
  fract2x16 a, t;
  fract16 t1, t2;

  a = __builtin_bfin_compose_2x16 (0x1001, 0x0001);

  t = __builtin_bfin_shl_fr2x16 (a, 4);
  t1 = __builtin_bfin_extract_hi (t);
  t2 = __builtin_bfin_extract_lo (t);
  if (t1 != 0x7fff || t2 != 0x10)
    abort ();

  return 0;
}

","extern void abort (void);

typedef short  __v2hi __attribute ((vector_size(4)));
typedef __v2hi fract2x16;
typedef short fract16;

int main ()
{
  fract2x16 a, t;
  fract16 t1, t2;

  a = __builtin_bfin_compose_2x16 (0x1001, 0x0001);

  t = __builtin_bfin_shl_fr2x16 (a, 4);
  t1 = __builtin_bfin_extract_hi (t);
  t2 = __builtin_bfin_extract_lo (t);
  if (t1 != 0x7fff || t2 != 0x10)
    abort ();

  return 0;
}

"
"typedef struct {
    unsigned char mbxCommand;
} MAILBOX_t;
void lpfc_sli_brdrestart(void)
{
  volatile unsigned int word0;
  MAILBOX_t *mb;
  mb = (MAILBOX_t *) &word0;
  mb->mbxCommand = 0x1A;
  __writel((*(unsigned int *) mb));
}
","typedef struct {
    unsigned char mbxCommand;
} MAILBOX_t;
void lpfc_sli_brdrestart(void)
{
  volatile unsigned int word0;
  MAILBOX_t *mb;
  mb = (MAILBOX_t *) &word0;
  mb->mbxCommand = 0x1A;
  __writel((*(unsigned int *) mb));
}
"
"/* { dg-do compile } */
/* { dg-require-effective-target vect_int } */

void test(int* input, int* out, unsigned x1, unsigned x2)
{
  unsigned i, j;
  unsigned end = x1;

  for(i = j = 0; i < 1000; i++) {
      int sum = 0;
      end += x2;
      for( ; j < end; j++)
	sum += input[j];
      out[i] = sum;
  }
}

/* { dg-final { scan-tree-dump ""vectorized 1 loops"" ""vect"" } } */
","/* { dg-do compile } */
/* { dg-require-effective-target vect_int } */

void test(int* input, int* out, unsigned x1, unsigned x2)
{
  unsigned i, j;
  unsigned end = x1;

  for(i = j = 0; i < 1000; i++) {
      int sum = 0;
      end += x2;
      for( ; j < end; j++)
	sum += input[j];
      out[i] = sum;
  }
}

/* { dg-final { scan-tree-dump ""vectorized 1 loops"" ""vect"" } } */
"
"/* { dg-do compile } */
/* { dg-options ""-pedantic-errors -Wsystem-headers"" } */
#include ""pr36901-system.h""
void foo(void)
{
  int s = sc;
}
/* { dg-message ""from "" ""In file included"" { target *-*-* } 0 } */
/* { dg-error ""ordered comparison of pointer with integer zero"" ""pedantic error"" { target *-*-* } 0 } */
","/* { dg-do compile } */
/* { dg-options ""-pedantic-errors -Wsystem-headers"" } */
#include ""pr36901-system.h""
void foo(void)
{
  int s = sc;
}
/* { dg-message ""from "" ""In file included"" { target *-*-* } 0 } */
/* { dg-error ""ordered comparison of pointer with integer zero"" ""pedantic error"" { target *-*-* } 0 } */
"
"void p1 (p) int *p;
{ *p &= ~0xff;
}
void p2 (p) int *p;
{ *p &= ~0xff00;
}
void p3 (p) int *p;
{ *p &= ~0xffff0000;
}
void p4 (p) int *p;
{ *p &= ~0xffff;
}

main ()
{
  int a;

  a = 0x12345678;  p1 (&a);  printf (""%x\n"", a);
  a = 0x12345678;  p2 (&a);  printf (""%x\n"", a);
  a = 0x12345678;  p3 (&a);  printf (""%x\n"", a);
  a = 0x12345678;  p4 (&a);  printf (""%x\n"", a);
}
","void p1 (p) int *p;
{ *p &= ~0xff;
}
void p2 (p) int *p;
{ *p &= ~0xff00;
}
void p3 (p) int *p;
{ *p &= ~0xffff0000;
}
void p4 (p) int *p;
{ *p &= ~0xffff;
}

main ()
{
  int a;

  a = 0x12345678;  p1 (&a);  printf (""%x\n"", a);
  a = 0x12345678;  p2 (&a);  printf (""%x\n"", a);
  a = 0x12345678;  p3 (&a);  printf (""%x\n"", a);
  a = 0x12345678;  p4 (&a);  printf (""%x\n"", a);
}
"
"/* { dg-do compile } */
/* { dg-options ""-O2 -mcpu=thunderx"" } */

struct noldp
{
  int a, b;
};


int f(struct noldp *a)
{
  return a->a + a->b;
}

/* We know the alignement of a->a to be 4 byte aligned so it is not profitable
   to do ldp. */
/* { dg-final { scan-assembler-not ""ldp\tw\[0-9\]+, w\[0-9\]"" } } */
","/* { dg-do compile } */
/* { dg-options ""-O2 -mcpu=thunderx"" } */

struct noldp
{
  int a, b;
};


int f(struct noldp *a)
{
  return a->a + a->b;
}

/* We know the alignement of a->a to be 4 byte aligned so it is not profitable
   to do ldp. */
/* { dg-final { scan-assembler-not ""ldp\tw\[0-9\]+, w\[0-9\]"" } } */
"
"/* { dg-do compile } */
/* { dg-options ""-mavx2 -O2"" } */
/* { dg-final { scan-assembler ""vpmovmskb\[ \\t\]+\[^\n\]*%ymm\[0-9\]"" } } */

#include <immintrin.h>

volatile __m256i x;
int res;

void extern
avx2_test (void)
{
  res = _mm256_movemask_epi8 (x);
}
","/* { dg-do compile } */
/* { dg-options ""-mavx2 -O2"" } */
/* { dg-final { scan-assembler ""vpmovmskb\[ \\t\]+\[^\n\]*%ymm\[0-9\]"" } } */

#include <immintrin.h>

volatile __m256i x;
int res;

void extern
avx2_test (void)
{
  res = _mm256_movemask_epi8 (x);
}
"
"/* { dg-do run } */
/* { dg-options ""-O3 -mpower8-vector"" } */
/* { dg-require-effective-target lp64 } */
/* { dg-require-effective-target p8vector_hw } */

#define NO_WARN_X86_INTRINSICS 1

#ifndef CHECK_H
#define CHECK_H ""sse-check.h""
#endif

#include CHECK_H

#ifndef TEST
#define TEST sse_test_ucomiss_5
#endif

#include <xmmintrin.h>

static int 
__attribute__((noinline, unused))
test (__m128 s1, __m128 s2)
{
  return _mm_ucomige_ss (s1, s2); 
}

static void
TEST (void)
{
  union128  s1, s2;
  int d[1];
  int e[1];

  s1.x = _mm_set_ps (24.43, 68.346, 43.35, 546.46);
  s2.x = _mm_set_ps (1.17, 2.16, 3.15, 4.14);
  d[0] = test (s1.x, s2.x); 
  e[0] = s1.a[0] >= s2.a[0];

  if (checkVi (d, e, 1))
    abort ();
}
","/* { dg-do run } */
/* { dg-options ""-O3 -mpower8-vector"" } */
/* { dg-require-effective-target lp64 } */
/* { dg-require-effective-target p8vector_hw } */

#define NO_WARN_X86_INTRINSICS 1

#ifndef CHECK_H
#define CHECK_H ""sse-check.h""
#endif

#include CHECK_H

#ifndef TEST
#define TEST sse_test_ucomiss_5
#endif

#include <xmmintrin.h>

static int 
__attribute__((noinline, unused))
test (__m128 s1, __m128 s2)
{
  return _mm_ucomige_ss (s1, s2); 
}

static void
TEST (void)
{
  union128  s1, s2;
  int d[1];
  int e[1];

  s1.x = _mm_set_ps (24.43, 68.346, 43.35, 546.46);
  s2.x = _mm_set_ps (1.17, 2.16, 3.15, 4.14);
  d[0] = test (s1.x, s2.x); 
  e[0] = s1.a[0] >= s2.a[0];

  if (checkVi (d, e, 1))
    abort ();
}
"
"/* { dg-do compile } */
/* { dg-options ""-O2 -fdump-tree-forwprop1-details"" } */

int foo(int z0, unsigned z1)
{
  int t0 = (z0 != -1);
  int t1 = (z1 != -1U);
  int t2 = (t0 | t1);
  return t2;
}

/* { dg-final { scan-tree-dump ""gimple_simplified to _\[0-9\]* = \\(int\\) z1_\[0-9\]*\\(D\\);"" ""forwprop1"" } } */
","/* { dg-do compile } */
/* { dg-options ""-O2 -fdump-tree-forwprop1-details"" } */

int foo(int z0, unsigned z1)
{
  int t0 = (z0 != -1);
  int t1 = (z1 != -1U);
  int t2 = (t0 | t1);
  return t2;
}

/* { dg-final { scan-tree-dump ""gimple_simplified to _\[0-9\]* = \\(int\\) z1_\[0-9\]*\\(D\\);"" ""forwprop1"" } } */
"
"/* PR c/32041 */
/* { dg-do compile } */

struct S
{
  int c;
  struct { float f; } sa[2];
};

char a[__builtin_offsetof (struct S, sa->f)
       == __builtin_offsetof (struct S, sa[0].f) ? 1 : -1];

","/* PR c/32041 */
/* { dg-do compile } */

struct S
{
  int c;
  struct { float f; } sa[2];
};

char a[__builtin_offsetof (struct S, sa->f)
       == __builtin_offsetof (struct S, sa[0].f) ? 1 : -1];

"
"/* Verify that overloaded built-ins for vec_eqv with float and
   double inputs for VSX produce the right results.  */

/* { dg-do compile } */
/* { dg-require-effective-target powerpc_p8vector_ok } */
/* { dg-options ""-mpower8-vector -O2"" } */

#include <altivec.h>

vector float
test1 (vector float x, vector float y)
{
  return vec_eqv (x, y);
}

vector double
test2 (vector double x, vector double y)
{
  return vec_eqv (x, y);
}

/* { dg-final { scan-assembler-times ""xxleqv"" 2 } } */
","/* Verify that overloaded built-ins for vec_eqv with float and
   double inputs for VSX produce the right results.  */

/* { dg-do compile } */
/* { dg-require-effective-target powerpc_p8vector_ok } */
/* { dg-options ""-mpower8-vector -O2"" } */

#include <altivec.h>

vector float
test1 (vector float x, vector float y)
{
  return vec_eqv (x, y);
}

vector double
test2 (vector double x, vector double y)
{
  return vec_eqv (x, y);
}

/* { dg-final { scan-assembler-times ""xxleqv"" 2 } } */
"
"/* { dg-do compile { target { powerpc*-*-* } } } */
/* { dg-skip-if ""do not override -mcpu"" { powerpc*-*-* } { ""-mcpu=*"" } { ""-mcpu=power9"" } } */
/* { dg-require-effective-target powerpc_p9vector_ok } */
/* { dg-options ""-mcpu=power9"" } */

#include <altivec.h>

vector bool short
fetch_data (vector signed short *arg1_p, vector signed short *arg2_p)
{
  vector signed short arg_1 = *arg1_p;
  vector signed short arg_2 = *arg2_p;

  return vec_cmpnez (arg_1, arg_2);
}

/* { dg-final { scan-assembler ""vcmpnezh"" } } */
","/* { dg-do compile { target { powerpc*-*-* } } } */
/* { dg-skip-if ""do not override -mcpu"" { powerpc*-*-* } { ""-mcpu=*"" } { ""-mcpu=power9"" } } */
/* { dg-require-effective-target powerpc_p9vector_ok } */
/* { dg-options ""-mcpu=power9"" } */

#include <altivec.h>

vector bool short
fetch_data (vector signed short *arg1_p, vector signed short *arg2_p)
{
  vector signed short arg_1 = *arg1_p;
  vector signed short arg_2 = *arg2_p;

  return vec_cmpnez (arg_1, arg_2);
}

/* { dg-final { scan-assembler ""vcmpnezh"" } } */
"
"/* { dg-do run { target aarch64_sve_hw } } */
/* { dg-options ""-O2 -ftree-vectorize"" } */

#include ""vcond_14.c""

#define TEST_LOOP(INV, TYPE, CMPTYPE, SUFFIX)		\
  {							\
    TYPE a[N], b[N], c[N], d[N];			\
    CMPTYPE cond[N];					\
    for (int i = 0; i < N; ++i)				\
      {							\
	b[i] = i % 15;					\
	c[i] = i % 9 + 11;				\
	d[i] = i % 13 + 14;				\
	cond[i] = i % 17;				\
	asm volatile ("""" ::: ""memory"");			\
      }							\
    f_##INV##_##SUFFIX (a, b, c, d, cond);		\
    for (int i = 0; i < N; ++i)				\
      {							\
	double mb = (INV & 1 ? -b[i] : b[i]);		\
	double mc = c[i];				\
	double md = (INV & 2 ? -d[i] : d[i]);		\
	double fma = __builtin_fma (mb, mc, md);	\
	double truev = (INV & 4 ? -fma : fma);		\
	if (a[i] != (i % 17 < 10 ? truev : c[i]))	\
	  __builtin_abort ();				\
	asm volatile ("""" ::: ""memory"");			\
      }							\
  }

int
main (void)
{
  FOR_EACH_INV (TEST_LOOP)
  return 0;
}
","/* { dg-do run { target aarch64_sve_hw } } */
/* { dg-options ""-O2 -ftree-vectorize"" } */

#include ""vcond_14.c""

#define TEST_LOOP(INV, TYPE, CMPTYPE, SUFFIX)		\
  {							\
    TYPE a[N], b[N], c[N], d[N];			\
    CMPTYPE cond[N];					\
    for (int i = 0; i < N; ++i)				\
      {							\
	b[i] = i % 15;					\
	c[i] = i % 9 + 11;				\
	d[i] = i % 13 + 14;				\
	cond[i] = i % 17;				\
	asm volatile ("""" ::: ""memory"");			\
      }							\
    f_##INV##_##SUFFIX (a, b, c, d, cond);		\
    for (int i = 0; i < N; ++i)				\
      {							\
	double mb = (INV & 1 ? -b[i] : b[i]);		\
	double mc = c[i];				\
	double md = (INV & 2 ? -d[i] : d[i]);		\
	double fma = __builtin_fma (mb, mc, md);	\
	double truev = (INV & 4 ? -fma : fma);		\
	if (a[i] != (i % 17 < 10 ? truev : c[i]))	\
	  __builtin_abort ();				\
	asm volatile ("""" ::: ""memory"");			\
      }							\
  }

int
main (void)
{
  FOR_EACH_INV (TEST_LOOP)
  return 0;
}
"
"/* Test atomic_load routines for existence and proper execution on
   1-byte values with each valid memory model.  */
/* { dg-do run } */
/* { dg-options ""-std=c11 -pedantic-errors"" } */

#include <stdatomic.h>

extern void abort (void);

_Atomic char v;
char count;

int
main ()
{
  v = 0;
  count = 0;

  if (atomic_load_explicit (&v, memory_order_relaxed) != count++)
    abort ();
  else
    v++;

  if (atomic_load_explicit (&v, memory_order_acquire) != count++)
    abort ();
  else
    v++;

  if (atomic_load_explicit (&v, memory_order_consume) != count++)
    abort ();
  else
    v++;

  if (atomic_load_explicit (&v, memory_order_seq_cst) != count++)
    abort ();
  else
    v++;

  if (atomic_load (&v) != count)
    abort ();

  return 0;
}

","/* Test atomic_load routines for existence and proper execution on
   1-byte values with each valid memory model.  */
/* { dg-do run } */
/* { dg-options ""-std=c11 -pedantic-errors"" } */

#include <stdatomic.h>

extern void abort (void);

_Atomic char v;
char count;

int
main ()
{
  v = 0;
  count = 0;

  if (atomic_load_explicit (&v, memory_order_relaxed) != count++)
    abort ();
  else
    v++;

  if (atomic_load_explicit (&v, memory_order_acquire) != count++)
    abort ();
  else
    v++;

  if (atomic_load_explicit (&v, memory_order_consume) != count++)
    abort ();
  else
    v++;

  if (atomic_load_explicit (&v, memory_order_seq_cst) != count++)
    abort ();
  else
    v++;

  if (atomic_load (&v) != count)
    abort ();

  return 0;
}

"
"/* { dg-do compile } */
/* { dg-options ""-O"" } */
/* Verify that a cleanup marked ""inline"" gets inlined.  */

static inline void xyzzy(void *p __attribute__((unused)))
{
}

void doit(void)
{
  int x __attribute__((cleanup (xyzzy)));
}

/* { dg-final { scan-assembler-not ""xyzzy"" } } */
","/* { dg-do compile } */
/* { dg-options ""-O"" } */
/* Verify that a cleanup marked ""inline"" gets inlined.  */

static inline void xyzzy(void *p __attribute__((unused)))
{
}

void doit(void)
{
  int x __attribute__((cleanup (xyzzy)));
}

/* { dg-final { scan-assembler-not ""xyzzy"" } } */
"
"/* { dg-do compile } */
/* { dg-options ""-mavx2 -O2"" } */
/* { dg-final { scan-assembler ""vpermd\[ \\t\]+\[^\n\]*%ymm\[0-9\]"" } } */

#include <immintrin.h>

volatile __m256i x;

void extern
avx2_test (void)
{
  x = _mm256_permutevar8x32_epi32 (x, x);
}
","/* { dg-do compile } */
/* { dg-options ""-mavx2 -O2"" } */
/* { dg-final { scan-assembler ""vpermd\[ \\t\]+\[^\n\]*%ymm\[0-9\]"" } } */

#include <immintrin.h>

volatile __m256i x;

void extern
avx2_test (void)
{
  x = _mm256_permutevar8x32_epi32 (x, x);
}
"
"struct WView
{
  int hexedit_mode:1;
};
toggle_hexedit_mode (struct WView *view)
{
  if (view->hexedit_mode)
    {
    }
  else
    {
      view->hexedit_mode = !view->hexedit_mode;
    }
}
","struct WView
{
  int hexedit_mode:1;
};
toggle_hexedit_mode (struct WView *view)
{
  if (view->hexedit_mode)
    {
    }
  else
    {
      view->hexedit_mode = !view->hexedit_mode;
    }
}
"
"/* { dg-options { -nostartfiles below100.o -Tbelow100.ld -O2 } } */
/* { dg-final { scan-assembler ""mov.w r.,32532"" } } */

#define SFRA (*((volatile unsigned short*)0x7f14))
unsigned short *pA = (unsigned short *) 0x7f14;
#define SFRB (*((volatile unsigned short*)0x7f10))
unsigned short *pB = (unsigned short *) 0x7f10;

char *
Do (void)
{
  if (!(SFRA & 0x0001))
    {
      if (!(SFRB & 0x0001))
	return ""Fail"";
      else
	return ""Success"";
    }
  else
    return ""Fail"";
}

int
main (void)
{
  *pA = 0x1234;
  *pB = 0xedcb;
  return Do ()[0] == 'F';
}
","/* { dg-options { -nostartfiles below100.o -Tbelow100.ld -O2 } } */
/* { dg-final { scan-assembler ""mov.w r.,32532"" } } */

#define SFRA (*((volatile unsigned short*)0x7f14))
unsigned short *pA = (unsigned short *) 0x7f14;
#define SFRB (*((volatile unsigned short*)0x7f10))
unsigned short *pB = (unsigned short *) 0x7f10;

char *
Do (void)
{
  if (!(SFRA & 0x0001))
    {
      if (!(SFRB & 0x0001))
	return ""Fail"";
      else
	return ""Success"";
    }
  else
    return ""Fail"";
}

int
main (void)
{
  *pA = 0x1234;
  *pB = 0xedcb;
  return Do ()[0] == 'F';
}
"
"/* { dg-do compile } */
/* { dg-require-effective-target arm32 } */
/* { dg-options ""-O2"" } */

signed long long zero_extendsidi_negsi (unsigned int x)
{
  return -x;
}
/*
Expected output:
	rsb	r0, r0, #0
	mov	r1, #0
*/
/* { dg-final { scan-assembler-times ""rsbs?\\t...?, ...?, #0"" 1 } } */
/* { dg-final { scan-assembler-times ""mov"" 1 } } */
","/* { dg-do compile } */
/* { dg-require-effective-target arm32 } */
/* { dg-options ""-O2"" } */

signed long long zero_extendsidi_negsi (unsigned int x)
{
  return -x;
}
/*
Expected output:
	rsb	r0, r0, #0
	mov	r1, #0
*/
/* { dg-final { scan-assembler-times ""rsbs?\\t...?, ...?, #0"" 1 } } */
/* { dg-final { scan-assembler-times ""mov"" 1 } } */
"
"static inline int foo (unsigned _si1)
{
  if (_si1 != 0)
    if (_si1 > 2147483647)
      return 1;
  return 0;
}

static inline unsigned bar (unsigned _left, int _right)
{
  return (unsigned) _right >= 8 ? 1 : _left >> _right;
}

unsigned g_2;
unsigned g_67;
volatile unsigned g_162;

static inline int func_62 (unsigned p_63)
{
  p_63 = g_2 & g_67;
  if (g_2)
    ;
  else if (p_63)
    return 1;
  g_67 = bar (p_63, g_2);
  return 0;
}

unsigned baz (void)
{
  if (g_2)
    for (; g_2 <= -16; g_2 = foo (g_2))
      {
        for (; g_162; g_162)
          func_62 (func_62 (0));
        if (g_67)
          break;
      }
  return g_2;
}

","static inline int foo (unsigned _si1)
{
  if (_si1 != 0)
    if (_si1 > 2147483647)
      return 1;
  return 0;
}

static inline unsigned bar (unsigned _left, int _right)
{
  return (unsigned) _right >= 8 ? 1 : _left >> _right;
}

unsigned g_2;
unsigned g_67;
volatile unsigned g_162;

static inline int func_62 (unsigned p_63)
{
  p_63 = g_2 & g_67;
  if (g_2)
    ;
  else if (p_63)
    return 1;
  g_67 = bar (p_63, g_2);
  return 0;
}

unsigned baz (void)
{
  if (g_2)
    for (; g_2 <= -16; g_2 = foo (g_2))
      {
        for (; g_162; g_162)
          func_62 (func_62 (0));
        if (g_67)
          break;
      }
  return g_2;
}

"
"/* { dg-do compile } */
/* { dg-require-effective-target arm_fp16_alternative_ok } */
/* { dg-options ""-mfp16-format=alternative"" } */

float xx __attribute__((mode(HF))) = 0.0;

/* { dg-final { scan-assembler ""\t.eabi_attribute 38, 2"" } } */
/* { dg-final { scan-assembler ""\t.size\txx, 2"" } } */
/* { dg-final { scan-assembler ""\t.space\t2"" } } */
","/* { dg-do compile } */
/* { dg-require-effective-target arm_fp16_alternative_ok } */
/* { dg-options ""-mfp16-format=alternative"" } */

float xx __attribute__((mode(HF))) = 0.0;

/* { dg-final { scan-assembler ""\t.eabi_attribute 38, 2"" } } */
/* { dg-final { scan-assembler ""\t.size\txx, 2"" } } */
/* { dg-final { scan-assembler ""\t.space\t2"" } } */
"
"/* { dg-do compile } */
/* { dg-require-effective-target arm_unaligned } */
/* { dg-options ""-O2"" } */

#include <string.h>

char dest[16] = { 0 };

void aligned_dest (char *src)
{
  memcpy (dest, src, 15);
}

/* Expect a multi-word store for the main part of the copy, but subword
   loads/stores for the remainder.  */

/* { dg-final { scan-assembler-times ""ldmia"" 0 } } */
/* { dg-final { scan-assembler-times ""ldrd"" 0 } } */
/* { dg-final { scan-assembler-times ""stmia"" 1 { target { ! { arm_prefer_ldrd_strd } } } } } */
/* { dg-final { scan-assembler-times ""strd"" 1 { target { arm_prefer_ldrd_strd } } } } */
/* { dg-final { scan-assembler-times ""ldrh"" 1 } } */
/* { dg-final { scan-assembler-times ""strh"" 1 } } */
/* { dg-final { scan-assembler-times ""ldrb"" 1 } } */
/* { dg-final { scan-assembler-times ""strb"" 1 } } */
","/* { dg-do compile } */
/* { dg-require-effective-target arm_unaligned } */
/* { dg-options ""-O2"" } */

#include <string.h>

char dest[16] = { 0 };

void aligned_dest (char *src)
{
  memcpy (dest, src, 15);
}

/* Expect a multi-word store for the main part of the copy, but subword
   loads/stores for the remainder.  */

/* { dg-final { scan-assembler-times ""ldmia"" 0 } } */
/* { dg-final { scan-assembler-times ""ldrd"" 0 } } */
/* { dg-final { scan-assembler-times ""stmia"" 1 { target { ! { arm_prefer_ldrd_strd } } } } } */
/* { dg-final { scan-assembler-times ""strd"" 1 { target { arm_prefer_ldrd_strd } } } } */
/* { dg-final { scan-assembler-times ""ldrh"" 1 } } */
/* { dg-final { scan-assembler-times ""strh"" 1 } } */
/* { dg-final { scan-assembler-times ""ldrb"" 1 } } */
/* { dg-final { scan-assembler-times ""strb"" 1 } } */
"
"/* { dg-do compile } */
/* { dg-options ""-O -fdump-tree-optimized"" } */

#define INT_BITS  (sizeof (int) * __CHAR_BIT__)
#define ROL(x, y) ((x) << (y) | (x) >> (INT_BITS - (y)))
#define ROR(x, y) ((x) >> (y) | (x) << (INT_BITS - (y)))

unsigned
rol (unsigned a, unsigned b)
{
  return ~ROL (~a, b);
}

unsigned int
ror (unsigned a, unsigned b)
{
  return ~ROR (~a, b);
}

int
rol_conv1 (int a, unsigned b)
{
  return ~(int)ROL((unsigned)~a, b);
}

int
rol_conv2 (int a, unsigned b)
{
  return ~ROL((unsigned)~a, b);
}

int
rol_conv3 (unsigned a, unsigned b)
{
  return ~(int)ROL(~a, b);
}

#define LONG_BITS  (sizeof (long) * __CHAR_BIT__)
#define ROLL(x, y) ((x) << (y) | (x) >> (LONG_BITS - (y)))
#define RORL(x, y) ((x) >> (y) | (x) << (LONG_BITS - (y)))

unsigned long
roll (unsigned long a, unsigned long b)
{
  return ~ROLL (~a, b);
}

unsigned long
rorl (unsigned long a, unsigned long b)
{
  return ~RORL (~a, b);
}

/* { dg-final { scan-tree-dump-not ""~"" ""optimized"" } } */
","/* { dg-do compile } */
/* { dg-options ""-O -fdump-tree-optimized"" } */

#define INT_BITS  (sizeof (int) * __CHAR_BIT__)
#define ROL(x, y) ((x) << (y) | (x) >> (INT_BITS - (y)))
#define ROR(x, y) ((x) >> (y) | (x) << (INT_BITS - (y)))

unsigned
rol (unsigned a, unsigned b)
{
  return ~ROL (~a, b);
}

unsigned int
ror (unsigned a, unsigned b)
{
  return ~ROR (~a, b);
}

int
rol_conv1 (int a, unsigned b)
{
  return ~(int)ROL((unsigned)~a, b);
}

int
rol_conv2 (int a, unsigned b)
{
  return ~ROL((unsigned)~a, b);
}

int
rol_conv3 (unsigned a, unsigned b)
{
  return ~(int)ROL(~a, b);
}

#define LONG_BITS  (sizeof (long) * __CHAR_BIT__)
#define ROLL(x, y) ((x) << (y) | (x) >> (LONG_BITS - (y)))
#define RORL(x, y) ((x) >> (y) | (x) << (LONG_BITS - (y)))

unsigned long
roll (unsigned long a, unsigned long b)
{
  return ~ROLL (~a, b);
}

unsigned long
rorl (unsigned long a, unsigned long b)
{
  return ~RORL (~a, b);
}

/* { dg-final { scan-tree-dump-not ""~"" ""optimized"" } } */
"
"/* { dg-do preprocess } */
/* { dg-options ""-std=c99"" } */

\u00AA
\u00B7
\u0F43  /* { dg-warning ""not in NFC"" } */
a\u05B8\u05B9\u05B9\u05BBb
 a\u05BB\u05B9\u05B8\u05B9b  /* { dg-warning ""not in NFC"" } */
\u09CB
\u09C7\u09BE /* { dg-warning ""not in NFC"" } */
\u0B4B
\u0B47\u0B3E /* { dg-warning ""not in NFC"" } */
\u0BCA
\u0BC6\u0BBE /* { dg-warning ""not in NFC"" } */
\u0BCB
\u0BC7\u0BBE /* { dg-warning ""not in NFC"" } */
\u0CCA
\u0CC6\u0CC2 /* { dg-warning ""not in NFC"" } */
\u0D4A
\u0D46\u0D3E /* { dg-warning ""not in NFC"" } */
\u0D4B
\u0D47\u0D3E /* { dg-warning ""not in NFC"" } */

K
\u212A /* { dg-warning ""not in NFC"" } */

\u03AC
\u1F71 /* { dg-warning ""not in NFC"" } */

\uAC00
\u1100\u1161 /* { dg-warning ""not in NFC"" } */
\uAC01
\u1100\u1161\u11A8 /* { dg-warning ""not in NFC"" } */
\uAC00\u11A8 /* { dg-warning ""not in NFC"" } */
","/* { dg-do preprocess } */
/* { dg-options ""-std=c99"" } */

\u00AA
\u00B7
\u0F43  /* { dg-warning ""not in NFC"" } */
a\u05B8\u05B9\u05B9\u05BBb
 a\u05BB\u05B9\u05B8\u05B9b  /* { dg-warning ""not in NFC"" } */
\u09CB
\u09C7\u09BE /* { dg-warning ""not in NFC"" } */
\u0B4B
\u0B47\u0B3E /* { dg-warning ""not in NFC"" } */
\u0BCA
\u0BC6\u0BBE /* { dg-warning ""not in NFC"" } */
\u0BCB
\u0BC7\u0BBE /* { dg-warning ""not in NFC"" } */
\u0CCA
\u0CC6\u0CC2 /* { dg-warning ""not in NFC"" } */
\u0D4A
\u0D46\u0D3E /* { dg-warning ""not in NFC"" } */
\u0D4B
\u0D47\u0D3E /* { dg-warning ""not in NFC"" } */

K
\u212A /* { dg-warning ""not in NFC"" } */

\u03AC
\u1F71 /* { dg-warning ""not in NFC"" } */

\uAC00
\u1100\u1161 /* { dg-warning ""not in NFC"" } */
\uAC01
\u1100\u1161\u11A8 /* { dg-warning ""not in NFC"" } */
\uAC00\u11A8 /* { dg-warning ""not in NFC"" } */
"
"/* { dg-do link } */
/* { dg-options ""-O -fdump-tree-optimized"" } */

extern void link_error (void);
void foo(int n)
{
  int * f = (int*) __builtin_malloc (n * sizeof (int));
  int * ff = (int*) __builtin_malloc (n * sizeof (int));
  int i;

  for (i = 0; i < n; ++i)
    {
      f[i] = 1;
      ff[i] = 2;
      if (f[i] != 1)
	link_error ();
      if (ff[i] != 2)
	link_error ();
    }

  __builtin_free (f);
  __builtin_free (ff);
}
int main()
{
  return 0;
}

/* We should have removed the calls to link_error () and all stores
   to the allocated memory.  */

/* { dg-final { scan-tree-dump-times ""\\\*D"" 0 ""optimized"" } } */
","/* { dg-do link } */
/* { dg-options ""-O -fdump-tree-optimized"" } */

extern void link_error (void);
void foo(int n)
{
  int * f = (int*) __builtin_malloc (n * sizeof (int));
  int * ff = (int*) __builtin_malloc (n * sizeof (int));
  int i;

  for (i = 0; i < n; ++i)
    {
      f[i] = 1;
      ff[i] = 2;
      if (f[i] != 1)
	link_error ();
      if (ff[i] != 2)
	link_error ();
    }

  __builtin_free (f);
  __builtin_free (ff);
}
int main()
{
  return 0;
}

/* We should have removed the calls to link_error () and all stores
   to the allocated memory.  */

/* { dg-final { scan-tree-dump-times ""\\\*D"" 0 ""optimized"" } } */
"
"/* { dg-options { -nostartfiles below100.o -Tbelow100.ld -O2 } } */
/* { dg-final { scan-assembler ""b\[np\] B100A,#7,"" } } */
/* { dg-final { scan-assembler ""b\[np\] B100B,#7,"" } } */

typedef struct
{
  unsigned char b0:1;
  unsigned char b1:1;
  unsigned char b2:1;
  unsigned char b3:1;
  unsigned char b4:1;
  unsigned char b5:1;
  unsigned char b6:1;
  unsigned char b7:1;
} BitField;

char acDummy[0xf0] __attribute__ ((__BELOW100__));
BitField B100A __attribute__ ((__BELOW100__)) =
{
0, 0, 1, 0, 1, 1, 0, 0};
unsigned char *pA = (unsigned char *) &B100A;
BitField B100B __attribute__ ((__BELOW100__)) =
{
1, 1, 0, 1, 0, 0, 1, 1};
unsigned char *pB = (unsigned char *) &B100B;

char *
Do (void)
{
  if (!B100A.b7)
    {
      if (!B100B.b7)
	return ""Fail"";
      else
	return ""Success"";
    }
  else
    return ""Fail"";
}

int
main (void)
{
  return Do ()[0] == 'F';
}
","/* { dg-options { -nostartfiles below100.o -Tbelow100.ld -O2 } } */
/* { dg-final { scan-assembler ""b\[np\] B100A,#7,"" } } */
/* { dg-final { scan-assembler ""b\[np\] B100B,#7,"" } } */

typedef struct
{
  unsigned char b0:1;
  unsigned char b1:1;
  unsigned char b2:1;
  unsigned char b3:1;
  unsigned char b4:1;
  unsigned char b5:1;
  unsigned char b6:1;
  unsigned char b7:1;
} BitField;

char acDummy[0xf0] __attribute__ ((__BELOW100__));
BitField B100A __attribute__ ((__BELOW100__)) =
{
0, 0, 1, 0, 1, 1, 0, 0};
unsigned char *pA = (unsigned char *) &B100A;
BitField B100B __attribute__ ((__BELOW100__)) =
{
1, 1, 0, 1, 0, 0, 1, 1};
unsigned char *pB = (unsigned char *) &B100B;

char *
Do (void)
{
  if (!B100A.b7)
    {
      if (!B100B.b7)
	return ""Fail"";
      else
	return ""Success"";
    }
  else
    return ""Fail"";
}

int
main (void)
{
  return Do ()[0] == 'F';
}
"
"/* { dg-do assemble } */

#include <arm_neon.h>

uint16_t
test_vget_lane_u16_before (uint16x4_t in)
{
  /* { dg-error ""lane -1 out of range 0 - 3"" """" {target *-*-*} 0 } */
  return vget_lane_u16 (in, -1);
}

uint16_t
test_vget_lane_u16_beyond (uint16x4_t in)
{
  /* { dg-error ""lane 4 out of range 0 - 3"" """" {target *-*-*} 0 } */
  return vget_lane_u16 (in, 4);
}
","/* { dg-do assemble } */

#include <arm_neon.h>

uint16_t
test_vget_lane_u16_before (uint16x4_t in)
{
  /* { dg-error ""lane -1 out of range 0 - 3"" """" {target *-*-*} 0 } */
  return vget_lane_u16 (in, -1);
}

uint16_t
test_vget_lane_u16_beyond (uint16x4_t in)
{
  /* { dg-error ""lane 4 out of range 0 - 3"" """" {target *-*-*} 0 } */
  return vget_lane_u16 (in, 4);
}
"
"/* PR rtl-optimization/68670 */
/* { dg-do run } */
/* { dg-options ""-O2 -ftracer"" } */

#include ""../gcc.c-torture/execute/pr68376-2.c""
","/* PR rtl-optimization/68670 */
/* { dg-do run } */
/* { dg-options ""-O2 -ftracer"" } */

#include ""../gcc.c-torture/execute/pr68376-2.c""
"
"/* PR middle-end/64067 */

struct S { int s; };
int *const v[1] = { &((struct S) { .s = 42 }).s };

int *
foo (void)
{
  return v[0];
}
","/* PR middle-end/64067 */

struct S { int s; };
int *const v[1] = { &((struct S) { .s = 42 }).s };

int *
foo (void)
{
  return v[0];
}
"
"/* { dg-do run } */
/* { dg-options ""-O2 -mavx512f"" } */
/* { dg-require-effective-target avx512f } */

#define AVX512F

#include ""avx512f-helper.h""

#define SIZE (AVX512F_LEN / 32)
#include ""avx512f-mask-type.h""

static void
CALC (MASK_TYPE *r, int *s1, int *s2)
{
  int i;
  *r = 0;
  MASK_TYPE one = 1;

  for (i = 0; i < SIZE; i++)
    if (s1[i] >= s2[i])
      *r = *r | (one << i);
}

void
TEST (void)
{
  int i;
  UNION_TYPE (AVX512F_LEN, i_d) src1, src2;
  MASK_TYPE res_ref, res1, res2;
  res1 = 0;

  for (i = 0; i < SIZE / 2; i++)
    {
      src1.a[i * 2] = i;
      src1.a[i * 2 + 1] = i * i;
      src2.a[i * 2] = 2 * i;
      src2.a[i * 2 + 1] = i * i;
    }

  res1 = INTRINSIC (_cmpge_epi32_mask) (src1.x, src2.x);
  res2 = INTRINSIC (_mask_cmpge_epi32_mask) (MASK_VALUE, src1.x, src2.x);

  CALC (&res_ref, src1.a, src2.a);

  if (res_ref != res1)
    abort ();

  res_ref &= MASK_VALUE;

  if (res_ref != res2)
    abort ();
}
","/* { dg-do run } */
/* { dg-options ""-O2 -mavx512f"" } */
/* { dg-require-effective-target avx512f } */

#define AVX512F

#include ""avx512f-helper.h""

#define SIZE (AVX512F_LEN / 32)
#include ""avx512f-mask-type.h""

static void
CALC (MASK_TYPE *r, int *s1, int *s2)
{
  int i;
  *r = 0;
  MASK_TYPE one = 1;

  for (i = 0; i < SIZE; i++)
    if (s1[i] >= s2[i])
      *r = *r | (one << i);
}

void
TEST (void)
{
  int i;
  UNION_TYPE (AVX512F_LEN, i_d) src1, src2;
  MASK_TYPE res_ref, res1, res2;
  res1 = 0;

  for (i = 0; i < SIZE / 2; i++)
    {
      src1.a[i * 2] = i;
      src1.a[i * 2 + 1] = i * i;
      src2.a[i * 2] = 2 * i;
      src2.a[i * 2 + 1] = i * i;
    }

  res1 = INTRINSIC (_cmpge_epi32_mask) (src1.x, src2.x);
  res2 = INTRINSIC (_mask_cmpge_epi32_mask) (MASK_VALUE, src1.x, src2.x);

  CALC (&res_ref, src1.a, src2.a);

  if (res_ref != res1)
    abort ();

  res_ref &= MASK_VALUE;

  if (res_ref != res2)
    abort ();
}
"
"/* { dg-do compile { target { int128 && scheduling } } } */
/* { dg-options ""-O2 -fschedule-insns"" } */
/* { dg-additional-options ""-fstack-protector"" { target fstack_protector } } */

extern void fn2 (char *);
__int128 a, b;
int
fn1 (void)
{
  char e[32];
  fn2 (e);
  b = 9 * (a >> 1);
  return 0;
}
","/* { dg-do compile { target { int128 && scheduling } } } */
/* { dg-options ""-O2 -fschedule-insns"" } */
/* { dg-additional-options ""-fstack-protector"" { target fstack_protector } } */

extern void fn2 (char *);
__int128 a, b;
int
fn1 (void)
{
  char e[32];
  fn2 (e);
  b = 9 * (a >> 1);
  return 0;
}
"
"/* PR c/61854 */
/* { dg-do preprocess } */
/* { dg-options ""-std=iso9899:1990"" } */

void
foo (void)
{
  // 1st
  /* { dg-error ""C\\+\\+ style comments are not allowed in ISO C90"" ""comments""  { target *-*-*} .-1 } */
  /* { dg-message ""note: \[^\n\r]*reported only once"" """"  { target *-*-*} .-2 } */
  // 2nd
  // 3rd
}
","/* PR c/61854 */
/* { dg-do preprocess } */
/* { dg-options ""-std=iso9899:1990"" } */

void
foo (void)
{
  // 1st
  /* { dg-error ""C\\+\\+ style comments are not allowed in ISO C90"" ""comments""  { target *-*-*} .-1 } */
  /* { dg-message ""note: \[^\n\r]*reported only once"" """"  { target *-*-*} .-2 } */
  // 2nd
  // 3rd
}
"
"/* PR tree-optimization/45083 */
/* { dg-do compile } */
/* { dg-options ""-O2 -Wuninitialized"" } */

struct S { char *a; unsigned b; unsigned c; };
extern int foo (const char *);
extern void bar (int, int);

static void
baz (void)
{
  struct S cs[1];	/* { dg-message ""was declared here"" } */
  switch (cs->b)	/* { dg-warning ""cs\[^\n\r\]*\\.b\[^\n\r\]*is used uninitialized"" } */
    {
    case 101:
      if (foo (cs->a))	/* { dg-warning ""cs\[^\n\r\]*\\.a\[^\n\r\]*may be used uninitialized"" } */
	bar (cs->c, cs->b);	/* { dg-warning ""cs\[^\n\r\]*\\.c\[^\n\r\]*may be used uninitialized"" } */
    }
}

void
test (void)
{
  baz ();
}
","/* PR tree-optimization/45083 */
/* { dg-do compile } */
/* { dg-options ""-O2 -Wuninitialized"" } */

struct S { char *a; unsigned b; unsigned c; };
extern int foo (const char *);
extern void bar (int, int);

static void
baz (void)
{
  struct S cs[1];	/* { dg-message ""was declared here"" } */
  switch (cs->b)	/* { dg-warning ""cs\[^\n\r\]*\\.b\[^\n\r\]*is used uninitialized"" } */
    {
    case 101:
      if (foo (cs->a))	/* { dg-warning ""cs\[^\n\r\]*\\.a\[^\n\r\]*may be used uninitialized"" } */
	bar (cs->c, cs->b);	/* { dg-warning ""cs\[^\n\r\]*\\.c\[^\n\r\]*may be used uninitialized"" } */
    }
}

void
test (void)
{
  baz ();
}
"
"/* { dg-do run } */
/* { dg-options ""-O3 -mpower8-vector -Wno-psabi"" } */
/* { dg-require-effective-target lp64 } */
/* { dg-require-effective-target p8vector_hw } */

#define NO_WARN_X86_INTRINSICS 1

#ifndef CHECK_H
#define CHECK_H ""sse-check.h""
#endif

#include CHECK_H

#ifndef TEST
#define TEST sse_test_movlhps_1
#endif

#include <xmmintrin.h>

static __m128
__attribute__((noinline, unused))
test (__m128 a, __m128 b)
{
  __asm("""" : ""+v""(a), ""+v""(a));
  return _mm_movelh_ps (a, b); 
}

static void
TEST (void)
{
  union128 u, s1, s2;
  float e[4]; 

  s1.x = _mm_set_ps (24.43, 68.346, 43.35, 546.46);
  s2.x = _mm_set_ps (1.17, 2.16, 3.15, 4.14);
  u.x = _mm_set1_ps (0.0);

  u.x = test (s1.x, s2.x);

  e[0] = s1.a[0];
  e[1] = s1.a[1];
  e[2] = s2.a[0];
  e[3] = s2.a[1];

  if (check_union128 (u, e))
    abort ();
}
","/* { dg-do run } */
/* { dg-options ""-O3 -mpower8-vector -Wno-psabi"" } */
/* { dg-require-effective-target lp64 } */
/* { dg-require-effective-target p8vector_hw } */

#define NO_WARN_X86_INTRINSICS 1

#ifndef CHECK_H
#define CHECK_H ""sse-check.h""
#endif

#include CHECK_H

#ifndef TEST
#define TEST sse_test_movlhps_1
#endif

#include <xmmintrin.h>

static __m128
__attribute__((noinline, unused))
test (__m128 a, __m128 b)
{
  __asm("""" : ""+v""(a), ""+v""(a));
  return _mm_movelh_ps (a, b); 
}

static void
TEST (void)
{
  union128 u, s1, s2;
  float e[4]; 

  s1.x = _mm_set_ps (24.43, 68.346, 43.35, 546.46);
  s2.x = _mm_set_ps (1.17, 2.16, 3.15, 4.14);
  u.x = _mm_set1_ps (0.0);

  u.x = test (s1.x, s2.x);

  e[0] = s1.a[0];
  e[1] = s1.a[1];
  e[2] = s2.a[0];
  e[3] = s2.a[1];

  if (check_union128 (u, e))
    abort ();
}
"
"/* PR target/59501 */
/* { dg-do run } */
/* { dg-options ""-O2 -mavx -maccumulate-outgoing-args"" } */
/* { dg-require-effective-target avx } */

#include ""pr59501-3.c""
","/* PR target/59501 */
/* { dg-do run } */
/* { dg-options ""-O2 -mavx -maccumulate-outgoing-args"" } */
/* { dg-require-effective-target avx } */

#include ""pr59501-3.c""
"
"/* PR target/12654
   The Alpha backend tried to do a >= 1024 as (a - 1024) >= 0, which fails
   for very large negative values.  */
/* Origin: tg@swox.com  */

#include <limits.h>

extern void abort (void);

void __attribute__((noinline))
foo (long x)
{
  if (x >= 1024)
    abort ();
}

int
main ()
{
  foo (LONG_MIN);
  foo (LONG_MIN + 10000);
  return 0;
}
","/* PR target/12654
   The Alpha backend tried to do a >= 1024 as (a - 1024) >= 0, which fails
   for very large negative values.  */
/* Origin: tg@swox.com  */

#include <limits.h>

extern void abort (void);

void __attribute__((noinline))
foo (long x)
{
  if (x >= 1024)
    abort ();
}

int
main ()
{
  foo (LONG_MIN);
  foo (LONG_MIN + 10000);
  return 0;
}
"
"/* { dg-do link } */
/* { dg-options ""-O2 -fdump-tree-optimized"" } */

extern void link_error (void);
static const int my_array [3] = { 4, 5, 6 };

void f0 (void)
{
  int j, sum = 0;
  for (j = 0; j < 3; j ++)
    sum += my_array [j];
  if (15 != sum)
    link_error ();
}

int f1 (int a [])
{
  int j, sum = 0;
  for (j = 0; j < 3; j ++)
    sum += a [j] + my_array [j];
  return sum;
}

int main() { }

/* { dg-final { scan-tree-dump-not ""my_array"" ""optimized"" } } */
","/* { dg-do link } */
/* { dg-options ""-O2 -fdump-tree-optimized"" } */

extern void link_error (void);
static const int my_array [3] = { 4, 5, 6 };

void f0 (void)
{
  int j, sum = 0;
  for (j = 0; j < 3; j ++)
    sum += my_array [j];
  if (15 != sum)
    link_error ();
}

int f1 (int a [])
{
  int j, sum = 0;
  for (j = 0; j < 3; j ++)
    sum += a [j] + my_array [j];
  return sum;
}

int main() { }

/* { dg-final { scan-tree-dump-not ""my_array"" ""optimized"" } } */
"
"/* { dg-require-effective-target vect_int } */

#include ""tree-vect.h""
int arr[2048];
int res[100] = { 2148, 2146, 2144, 2142, 2140, 2138, 2136, 2134, 2132, 2130,
		 2128, 2126, 2124, 2122, 2120, 2118, 2116, 2114, 2112, 2110,
		 2108, 2106, 2104, 2102, 2100, 2098, 2096, 2094, 2092, 2090,
		 2088, 2086, 2084, 2082, 2080, 2078, 2076, 2074, 2072, 2070,
		 2068, 2066, 2064, 2062, 2060, 2058, 2056, 2054, 3078, 2050};

__attribute__ ((noinline)) int
foo (int *a, int *b, int len)
{
  int i;
  int *a1 = a;
  int *a0 = a1 - 4;
  for (i = 0; i < len; i++)
    {
      *b = *a0 + *a1;
      b--;
      a0++;
      a1++;
    }
  return 0;
}

int main (void)
{
  int *a = &arr[1027];
  int *b = &arr[1024];

  int i;
  for (i = 0; i < 2048; i++)
    arr[i] = i;

  foo (a, b, 50);

  for (i = 975; i < 1025; i++)
    if (arr[i] != res[i - 975])
      abort ();

  return 0;
}

/* { dg-final { scan-tree-dump ""improved number of alias checks from \[0-9\]* to 1"" ""vect"" { target vect_perm } } } */
","/* { dg-require-effective-target vect_int } */

#include ""tree-vect.h""
int arr[2048];
int res[100] = { 2148, 2146, 2144, 2142, 2140, 2138, 2136, 2134, 2132, 2130,
		 2128, 2126, 2124, 2122, 2120, 2118, 2116, 2114, 2112, 2110,
		 2108, 2106, 2104, 2102, 2100, 2098, 2096, 2094, 2092, 2090,
		 2088, 2086, 2084, 2082, 2080, 2078, 2076, 2074, 2072, 2070,
		 2068, 2066, 2064, 2062, 2060, 2058, 2056, 2054, 3078, 2050};

__attribute__ ((noinline)) int
foo (int *a, int *b, int len)
{
  int i;
  int *a1 = a;
  int *a0 = a1 - 4;
  for (i = 0; i < len; i++)
    {
      *b = *a0 + *a1;
      b--;
      a0++;
      a1++;
    }
  return 0;
}

int main (void)
{
  int *a = &arr[1027];
  int *b = &arr[1024];

  int i;
  for (i = 0; i < 2048; i++)
    arr[i] = i;

  foo (a, b, 50);

  for (i = 975; i < 1025; i++)
    if (arr[i] != res[i - 975])
      abort ();

  return 0;
}

/* { dg-final { scan-tree-dump ""improved number of alias checks from \[0-9\]* to 1"" ""vect"" { target vect_perm } } } */
"
"/* { dg-do run } */
/* { dg-options ""-O2 -mavx512vl"" } */
/* { dg-require-effective-target avx512vl } */

#define AVX512VL
#define AVX512F_LEN 256
#define AVX512F_LEN_HALF 128
#include ""avx512f-vpmovusdb-2.c""

#undef AVX512F_LEN
#undef AVX512F_LEN_HALF

#define AVX512F_LEN 128
#define AVX512F_LEN_HALF 128
#include ""avx512f-vpmovusdb-2.c""
","/* { dg-do run } */
/* { dg-options ""-O2 -mavx512vl"" } */
/* { dg-require-effective-target avx512vl } */

#define AVX512VL
#define AVX512F_LEN 256
#define AVX512F_LEN_HALF 128
#include ""avx512f-vpmovusdb-2.c""

#undef AVX512F_LEN
#undef AVX512F_LEN_HALF

#define AVX512F_LEN 128
#define AVX512F_LEN_HALF 128
#include ""avx512f-vpmovusdb-2.c""
"
"/* { dg-do compile } */
/* { dg-options ""-mavx2 -O2"" } */
/* { dg-final { scan-assembler ""vpsllvd\[ \\t\]+\[^\n\]*%ymm\[0-9\]"" } } */

#include <immintrin.h>

volatile __m256i x;

void extern
avx2_test (void)
{
  x = _mm256_sllv_epi32 (x, x);
}
","/* { dg-do compile } */
/* { dg-options ""-mavx2 -O2"" } */
/* { dg-final { scan-assembler ""vpsllvd\[ \\t\]+\[^\n\]*%ymm\[0-9\]"" } } */

#include <immintrin.h>

volatile __m256i x;

void extern
avx2_test (void)
{
  x = _mm256_sllv_epi32 (x, x);
}
"
"/* { dg-do compile } */

extern void bar(int);

void foo (void)
{
  #pragma omp master
    bar(0);

  #pragma omp master
  {
    bar(1);
    bar(2);
  }

  /* Yes, this is legal -- structured-block contains statement contains
     openmp-construct contains master-construct.  */
  #pragma omp master
  #pragma omp master
  #pragma omp master
    ;
}
","/* { dg-do compile } */

extern void bar(int);

void foo (void)
{
  #pragma omp master
    bar(0);

  #pragma omp master
  {
    bar(1);
    bar(2);
  }

  /* Yes, this is legal -- structured-block contains statement contains
     openmp-construct contains master-construct.  */
  #pragma omp master
  #pragma omp master
  #pragma omp master
    ;
}
"
"/* PR c/61240 */
/* { dg-do compile } */

typedef __PTRDIFF_TYPE__ ptrdiff_t;

ptrdiff_t
foo (ptrdiff_t a[4])
{
  int i[4];
  int *p = i + 2;
  static ptrdiff_t b = p - (p - 1);	/* { dg-bogus ""integer overflow in expression"" } */
  static ptrdiff_t c = (p - 1) - p;	/* { dg-bogus ""integer overflow in expression"" } */
  static ptrdiff_t d = (p - 2) - (p - 1);/* { dg-bogus ""integer overflow in expression"" } */
  static ptrdiff_t e = (p - 1) - (p - 2);/* { dg-bogus ""integer overflow in expression"" } */
  a[0] = p - (p - 1);			/* { dg-bogus ""integer overflow in expression"" } */
  a[1] = (p - 1) - p;			/* { dg-bogus ""integer overflow in expression"" } */
  a[2] = (p - 2) - (p - 1);		/* { dg-bogus ""integer overflow in expression"" } */
  a[3] = (p - 1) - (p - 2);		/* { dg-bogus ""integer overflow in expression"" } */
  return b + c + d + e;
}
","/* PR c/61240 */
/* { dg-do compile } */

typedef __PTRDIFF_TYPE__ ptrdiff_t;

ptrdiff_t
foo (ptrdiff_t a[4])
{
  int i[4];
  int *p = i + 2;
  static ptrdiff_t b = p - (p - 1);	/* { dg-bogus ""integer overflow in expression"" } */
  static ptrdiff_t c = (p - 1) - p;	/* { dg-bogus ""integer overflow in expression"" } */
  static ptrdiff_t d = (p - 2) - (p - 1);/* { dg-bogus ""integer overflow in expression"" } */
  static ptrdiff_t e = (p - 1) - (p - 2);/* { dg-bogus ""integer overflow in expression"" } */
  a[0] = p - (p - 1);			/* { dg-bogus ""integer overflow in expression"" } */
  a[1] = (p - 1) - p;			/* { dg-bogus ""integer overflow in expression"" } */
  a[2] = (p - 2) - (p - 1);		/* { dg-bogus ""integer overflow in expression"" } */
  a[3] = (p - 1) - (p - 2);		/* { dg-bogus ""integer overflow in expression"" } */
  return b + c + d + e;
}
"
"/* PR c/36507 */
/* { dg-do run } */
/* { dg-options ""-O0 -std=gnu99 -fgnu89-inline"" } */

int
main (void)
{
  int i = 2;
  auto inline int f1 (void)
  {
    return i;
  }
  inline int f2 (void)
  {
    return i;
  }
  auto inline int f3 (void);
  auto inline int f3 (void)
  {
    return i;
  }
  auto inline int f4 (void);
  inline int f4 (void)
  {
    return i;
  }
  return f1 () + f2 () + f3 () + f4 () - 8;
}
","/* PR c/36507 */
/* { dg-do run } */
/* { dg-options ""-O0 -std=gnu99 -fgnu89-inline"" } */

int
main (void)
{
  int i = 2;
  auto inline int f1 (void)
  {
    return i;
  }
  inline int f2 (void)
  {
    return i;
  }
  auto inline int f3 (void);
  auto inline int f3 (void)
  {
    return i;
  }
  auto inline int f4 (void);
  inline int f4 (void)
  {
    return i;
  }
  return f1 () + f2 () + f3 () + f4 () - 8;
}
"
"/* { dg-do compile } */

/* N1150 6: Constants.
   C99 6.4.4.2: Floating constants.  */

_Decimal32 a = 1.1df;
_Decimal32 b = -.003DF;
_Decimal64 c = 11e-1dl;
_Decimal64 d = -.3DL;
_Decimal128 e = 000.3e0dl;
_Decimal128 f = 3000300030003e0DL;
","/* { dg-do compile } */

/* N1150 6: Constants.
   C99 6.4.4.2: Floating constants.  */

_Decimal32 a = 1.1df;
_Decimal32 b = -.003DF;
_Decimal64 c = 11e-1dl;
_Decimal64 d = -.3DL;
_Decimal128 e = 000.3e0dl;
_Decimal128 f = 3000300030003e0DL;
"
"main()
{
  static char static_char_array[1];
  static char *static_char_pointer;
  static char static_char;
  char  char_array[1];
  char *char_pointer;
  char  character;

  char *cp, c;

  c = cp - static_char_array;   /* error */
  c = cp - static_char_pointer;
  c = cp - &static_char;        /* error */
  c = cp - char_array;
  c = cp - char_pointer;
  c = cp - &character;
}
","main()
{
  static char static_char_array[1];
  static char *static_char_pointer;
  static char static_char;
  char  char_array[1];
  char *char_pointer;
  char  character;

  char *cp, c;

  c = cp - static_char_array;   /* error */
  c = cp - static_char_pointer;
  c = cp - &static_char;        /* error */
  c = cp - char_array;
  c = cp - char_pointer;
  c = cp - &character;
}
"
"/* { dg-lto-options {{ -O3 -flto -flto-partition=1to1 -fgnu89-inline }} } */
/* { dg-lto-do run } */
extern void clone_me (int, int);
int a=15;
inline int inline_me ()
{
  clone_me (0,a);
}
","/* { dg-lto-options {{ -O3 -flto -flto-partition=1to1 -fgnu89-inline }} } */
/* { dg-lto-do run } */
extern void clone_me (int, int);
int a=15;
inline int inline_me ()
{
  clone_me (0,a);
}
"
"/* Test __builtin_{add,sub,mul}_overflow.  */
/* { dg-do run } */
/* { dg-skip-if """" { ! run_expensive_tests }  { ""*"" } { ""-O0"" ""-O2"" } } */

#include ""builtin-arith-overflow-1.h""

#define U(s, op) op
TESTS (char, SCHAR_MIN, SCHAR_MAX)

#undef T
#define T(n, t1, t2, tr, v1, v2, vr, b, o) t##n##b ();

int
main ()
{
  TESTS (char, SCHAR_MIN, SCHAR_MAX)
  return 0;
}
","/* Test __builtin_{add,sub,mul}_overflow.  */
/* { dg-do run } */
/* { dg-skip-if """" { ! run_expensive_tests }  { ""*"" } { ""-O0"" ""-O2"" } } */

#include ""builtin-arith-overflow-1.h""

#define U(s, op) op
TESTS (char, SCHAR_MIN, SCHAR_MAX)

#undef T
#define T(n, t1, t2, tr, v1, v2, vr, b, o) t##n##b ();

int
main ()
{
  TESTS (char, SCHAR_MIN, SCHAR_MAX)
  return 0;
}
"
"/* Check that -mrelax produces the correct error message.  */
/* { dg-do compile { target { sh-*-vxworks* && nonpic } } } */
/* { dg-error ""-mrelax is only supported for RTP PIC"" """" { target *-*-* } 0 } */
/* { dg-options ""-O1 -mrelax"" } */
int x;
","/* Check that -mrelax produces the correct error message.  */
/* { dg-do compile { target { sh-*-vxworks* && nonpic } } } */
/* { dg-error ""-mrelax is only supported for RTP PIC"" """" { target *-*-* } 0 } */
/* { dg-options ""-O1 -mrelax"" } */
int x;
"
"/* { dg-do compile } */

/* Check 'uncached' type attribute.  */

typedef volatile unsigned int RwReg  __attribute__ ((uncached));

typedef struct {
  RwReg UART_THR;
  int SIDE_DISH;
} UART;

void uart_putc(UART *port, char c)
{
    port->UART_THR = c;
    port->SIDE_DISH = c;
}

/* { dg-final { scan-assembler-times ""st\.di"" 1 } } */
","/* { dg-do compile } */

/* Check 'uncached' type attribute.  */

typedef volatile unsigned int RwReg  __attribute__ ((uncached));

typedef struct {
  RwReg UART_THR;
  int SIDE_DISH;
} UART;

void uart_putc(UART *port, char c)
{
    port->UART_THR = c;
    port->SIDE_DISH = c;
}

/* { dg-final { scan-assembler-times ""st\.di"" 1 } } */
"
"/* { dg-do compile } */
/* { dg-options ""-std=c11 -O"" } */
/* { dg-require-effective-target arm_arch_v7a_ok } */
/* { dg-add-options arm_arch_v7a } */

#include ""atomic_loaddi_relaxed.x""

/* { dg-final { scan-assembler-times ""ldrexd\tr\[0-9\]+, r\[0-9\]+, \\\[r\[0-9\]+\\\]"" 1 } } */
/* { dg-final { scan-assembler-not ""dmb\tish"" } } */
","/* { dg-do compile } */
/* { dg-options ""-std=c11 -O"" } */
/* { dg-require-effective-target arm_arch_v7a_ok } */
/* { dg-add-options arm_arch_v7a } */

#include ""atomic_loaddi_relaxed.x""

/* { dg-final { scan-assembler-times ""ldrexd\tr\[0-9\]+, r\[0-9\]+, \\\[r\[0-9\]+\\\]"" 1 } } */
/* { dg-final { scan-assembler-not ""dmb\tish"" } } */
"
"/* PR tree-optimization/52633 */
/* { dg-do compile } */
/* { dg-require-effective-target arm_neon_ok } */
/* { dg-options ""-march=armv7-a -mfloat-abi=softfp -mfpu=neon -O -ftree-vectorize"" } */

void
test (unsigned short *x, signed char *y)
{
  int i;
  for (i = 0; i < 32; i++)
    x[i] = (short) (y[i] << 5);
}

","/* PR tree-optimization/52633 */
/* { dg-do compile } */
/* { dg-require-effective-target arm_neon_ok } */
/* { dg-options ""-march=armv7-a -mfloat-abi=softfp -mfpu=neon -O -ftree-vectorize"" } */

void
test (unsigned short *x, signed char *y)
{
  int i;
  for (i = 0; i < 32; i++)
    x[i] = (short) (y[i] << 5);
}

"
"typedef struct _rec_stl rec_stl;
struct _rec_stl {
   unsigned char **strs;
};
orec_str_list(int count) {
   rec_stl *stl;
   int i, j;
   int li, lj;
   unsigned char ci, cj;
   for (i = 0; i < count; i++) {
      for (j = i + 1; j < count; j++) {
         cj = lj > 2 ? stl->strs[j][0] : (long)stl->strs[j] & 0xff;
         if ((count >= 16 && cj < ci) || (cj == ci && lj > li)) {
            stl->strs[j] = stl->strs[i];
            ci ^= cj;
            cj ^= ci;
            ci ^= cj;
         }
      }
   }
}
","typedef struct _rec_stl rec_stl;
struct _rec_stl {
   unsigned char **strs;
};
orec_str_list(int count) {
   rec_stl *stl;
   int i, j;
   int li, lj;
   unsigned char ci, cj;
   for (i = 0; i < count; i++) {
      for (j = i + 1; j < count; j++) {
         cj = lj > 2 ? stl->strs[j][0] : (long)stl->strs[j] & 0xff;
         if ((count >= 16 && cj < ci) || (cj == ci && lj > li)) {
            stl->strs[j] = stl->strs[i];
            ci ^= cj;
            cj ^= ci;
            ci ^= cj;
         }
      }
   }
}
"
"/* { dg-do run } */
/* { dg-require-effective-target indirect_jumps } */

/* The return-address was clobbered.  */
#include <stdlib.h>
#include <setjmp.h>

jmp_buf env;
extern void sub(void);
extern void sub3(void);
int called;
__attribute__ ((__noinline__))
int sjtest()
{
  int i;
  if (setjmp(env))
    return 99;

  for (i = 0; i < 10; i++)
    sub();

  longjmp(env, 1);
}

__attribute__ ((__noinline__))
void sub(void)
{
  called++;
}

int called3;
__attribute__ ((__noinline__))
int sjtest3()
{
  int i;
  if (setjmp(env))
    return 42;

  for (i = 0; i < 10; i++)
    sub3();
  return 0;
}

__attribute__ ((__noinline__))
void sub3(void)
{
  called3++;
  if (called3 == 10)
    longjmp (env, 1);
}

int main(void)
{
  if (sjtest() != 99 || called != 10)
    abort();
  if (sjtest3() != 42 || called3 != 10)
    abort();
  exit (0);
}
","/* { dg-do run } */
/* { dg-require-effective-target indirect_jumps } */

/* The return-address was clobbered.  */
#include <stdlib.h>
#include <setjmp.h>

jmp_buf env;
extern void sub(void);
extern void sub3(void);
int called;
__attribute__ ((__noinline__))
int sjtest()
{
  int i;
  if (setjmp(env))
    return 99;

  for (i = 0; i < 10; i++)
    sub();

  longjmp(env, 1);
}

__attribute__ ((__noinline__))
void sub(void)
{
  called++;
}

int called3;
__attribute__ ((__noinline__))
int sjtest3()
{
  int i;
  if (setjmp(env))
    return 42;

  for (i = 0; i < 10; i++)
    sub3();
  return 0;
}

__attribute__ ((__noinline__))
void sub3(void)
{
  called3++;
  if (called3 == 10)
    longjmp (env, 1);
}

int main(void)
{
  if (sjtest() != 99 || called != 10)
    abort();
  if (sjtest3() != 42 || called3 != 10)
    abort();
  exit (0);
}
"
"/* { dg-do compile } */
/* { dg-options ""-O2"" } */

long a;
int *b;
extern __inline __attribute__ ((__always_inline__))
__attribute__ ((__gnu_inline__)) int sprintf (int *p1, char *p2, ...)
{
  a = __builtin_object_size (0, 0);
  return __builtin___sprintf_chk (0, 0, a, p2, __builtin_va_arg_pack ());
}

void
log_bad_request ()
{
  b += sprintf (0, ""foo"");
}
","/* { dg-do compile } */
/* { dg-options ""-O2"" } */

long a;
int *b;
extern __inline __attribute__ ((__always_inline__))
__attribute__ ((__gnu_inline__)) int sprintf (int *p1, char *p2, ...)
{
  a = __builtin_object_size (0, 0);
  return __builtin___sprintf_chk (0, 0, a, p2, __builtin_va_arg_pack ());
}

void
log_bad_request ()
{
  b += sprintf (0, ""foo"");
}
"
"/* { dg-do run } */
/* { dg-options ""-O2 -mavx512bw"" } */
/* { dg-require-effective-target avx512bw } */

#define AVX512BW

#include ""avx512f-helper.h""

static __mmask32 __attribute__((noinline,noclone))
unpack (__mmask32 arg1, __mmask32 arg2)
{
  __mmask32 res;

  res = _mm512_kunpackw (arg1, arg2);

  return res;
}

void
TEST (void)
{
  if (unpack (0x07, 0x70) != 0x070070)
    __builtin_abort ();
}
","/* { dg-do run } */
/* { dg-options ""-O2 -mavx512bw"" } */
/* { dg-require-effective-target avx512bw } */

#define AVX512BW

#include ""avx512f-helper.h""

static __mmask32 __attribute__((noinline,noclone))
unpack (__mmask32 arg1, __mmask32 arg2)
{
  __mmask32 res;

  res = _mm512_kunpackw (arg1, arg2);

  return res;
}

void
TEST (void)
{
  if (unpack (0x07, 0x70) != 0x070070)
    __builtin_abort ();
}
"
"/* { dg-do compile } */
/* { dg-options ""-mavx512dq -mavx512vl -O2"" } */
/* { dg-final { scan-assembler-times ""vbroadcastf32x8\[ \\t\]+\[^\{\n\]*%zmm\[0-9\]+\[^\{\]|vshuff32x4\[ \\t\]+\[^\n\]*%zmm\[0-9\]+\[^\n\]*%zmm\[0-9\]+\[^\n\]*%zmm\[0-9\]+(?:\n|\[ \\t\]+#)"" 1 } } */
/* { dg-final { scan-assembler-times ""vbroadcastf32x8\[ \\t\]+\[^\{\n\]*%zmm\[0-9\]+\{%k\[1-7\]\}\[^\{\]|vshuff32x4\[ \\t\]+\[^\n\]*%zmm\[0-9\]+\{%k\[1-7\]\}\{z\}(?:\n|\[ \\t\]+#)"" 1 } } */
/* { dg-final { scan-assembler-times ""vbroadcastf32x8\[ \\t\]+\[^\{\n\]*%zmm\[0-9\]+\{%k\[1-7\]\}\{z\}|vshuff32x4\[ \\t\]+\[^\n\]*%zmm\[0-9\]+\{%k\[1-7\]\}(?:\n|\[ \\t\]+#)"" 1 } } */

#include <immintrin.h>

volatile __m512 x;
volatile __m256 y;
volatile __mmask16 m;

void extern
avx512dq_test (void)
{
  x = _mm512_broadcast_f32x8 (y);
  x = _mm512_mask_broadcast_f32x8 (x, m, y);
  x = _mm512_maskz_broadcast_f32x8 (m, y);
}
","/* { dg-do compile } */
/* { dg-options ""-mavx512dq -mavx512vl -O2"" } */
/* { dg-final { scan-assembler-times ""vbroadcastf32x8\[ \\t\]+\[^\{\n\]*%zmm\[0-9\]+\[^\{\]|vshuff32x4\[ \\t\]+\[^\n\]*%zmm\[0-9\]+\[^\n\]*%zmm\[0-9\]+\[^\n\]*%zmm\[0-9\]+(?:\n|\[ \\t\]+#)"" 1 } } */
/* { dg-final { scan-assembler-times ""vbroadcastf32x8\[ \\t\]+\[^\{\n\]*%zmm\[0-9\]+\{%k\[1-7\]\}\[^\{\]|vshuff32x4\[ \\t\]+\[^\n\]*%zmm\[0-9\]+\{%k\[1-7\]\}\{z\}(?:\n|\[ \\t\]+#)"" 1 } } */
/* { dg-final { scan-assembler-times ""vbroadcastf32x8\[ \\t\]+\[^\{\n\]*%zmm\[0-9\]+\{%k\[1-7\]\}\{z\}|vshuff32x4\[ \\t\]+\[^\n\]*%zmm\[0-9\]+\{%k\[1-7\]\}(?:\n|\[ \\t\]+#)"" 1 } } */

#include <immintrin.h>

volatile __m512 x;
volatile __m256 y;
volatile __mmask16 m;

void extern
avx512dq_test (void)
{
  x = _mm512_broadcast_f32x8 (y);
  x = _mm512_mask_broadcast_f32x8 (x, m, y);
  x = _mm512_maskz_broadcast_f32x8 (m, y);
}
"
"/* PR 16348: Make sure that condition-first false loops DTRT.  */

extern void abort ();

int main()
{
  for (; 0 ;)
    {
      abort ();
    label:
      return 0;
    }
  goto label;
}
","/* PR 16348: Make sure that condition-first false loops DTRT.  */

extern void abort ();

int main()
{
  for (; 0 ;)
    {
      abort ();
    label:
      return 0;
    }
  goto label;
}
"
"/* { dg-do run } */
/* { dg-options ""-O2 -mavx512vl"" } */
/* { dg-require-effective-target avx512vl } */

#define AVX512VL
#define AVX512F_LEN 256
#define AVX512F_LEN_HALF 128
#include ""avx512f-vfnmsubXXXps-2.c""

#undef AVX512F_LEN
#undef AVX512F_LEN_HALF

#define AVX512F_LEN 128
#define AVX512F_LEN_HALF 128
#include ""avx512f-vfnmsubXXXps-2.c""
","/* { dg-do run } */
/* { dg-options ""-O2 -mavx512vl"" } */
/* { dg-require-effective-target avx512vl } */

#define AVX512VL
#define AVX512F_LEN 256
#define AVX512F_LEN_HALF 128
#include ""avx512f-vfnmsubXXXps-2.c""

#undef AVX512F_LEN
#undef AVX512F_LEN_HALF

#define AVX512F_LEN 128
#define AVX512F_LEN_HALF 128
#include ""avx512f-vfnmsubXXXps-2.c""
"
"/* { dg-do compile } */
/* { dg-options ""-mcmse"" }  */

extern float bar (void);

float __attribute__ ((cmse_nonsecure_entry))
foo (void)
{
  return bar ();
}
/* { dg-final { scan-assembler ""movs\tr1, r0"" } } */
/* { dg-final { scan-assembler ""movs\tr2, r0"" } } */
/* { dg-final { scan-assembler ""movs\tr3, r0"" } } */
/* { dg-final { scan-assembler ""mov\tip, r0"" } } */
/* { dg-final { scan-assembler ""mov\tlr, r0"" } } */
/* { dg-final { scan-assembler ""msr\tAPSR_nzcvq,"" } } */
/* { dg-final { scan-assembler ""bxns"" } } */
","/* { dg-do compile } */
/* { dg-options ""-mcmse"" }  */

extern float bar (void);

float __attribute__ ((cmse_nonsecure_entry))
foo (void)
{
  return bar ();
}
/* { dg-final { scan-assembler ""movs\tr1, r0"" } } */
/* { dg-final { scan-assembler ""movs\tr2, r0"" } } */
/* { dg-final { scan-assembler ""movs\tr3, r0"" } } */
/* { dg-final { scan-assembler ""mov\tip, r0"" } } */
/* { dg-final { scan-assembler ""mov\tlr, r0"" } } */
/* { dg-final { scan-assembler ""msr\tAPSR_nzcvq,"" } } */
/* { dg-final { scan-assembler ""bxns"" } } */
"
"/* { dg-do compile } */
/* { dg-options ""-O2 -fdump-tree-ivopts-details"" } */

long last_data_offset;
int store;
char *data;
void g (long);
  
void
f ()
{
  
  long data_offset = last_data_offset;
  char *p;
  
  for (p = data; *p; p++)
    {
      data_offset++;
      g (data_offset);
      store = data_offset + 1;
    }
}

/* We should only have two IVs.  */
/* { dg-final { scan-tree-dump-not ""\\n  candidates \\d+, \\d+,\[^\\n\]*\\n\[^\\n\]*\\nFinal cost"" ""ivopts"" } }  */
","/* { dg-do compile } */
/* { dg-options ""-O2 -fdump-tree-ivopts-details"" } */

long last_data_offset;
int store;
char *data;
void g (long);
  
void
f ()
{
  
  long data_offset = last_data_offset;
  char *p;
  
  for (p = data; *p; p++)
    {
      data_offset++;
      g (data_offset);
      store = data_offset + 1;
    }
}

/* We should only have two IVs.  */
/* { dg-final { scan-tree-dump-not ""\\n  candidates \\d+, \\d+,\[^\\n\]*\\n\[^\\n\]*\\nFinal cost"" ""ivopts"" } }  */
"
"/* PR c/28286 */
/* { dg-do compile } */


#pragma pack(0.5)         /* { dg-warning ""invalid constant"" } */
#pragma pack(push,0.5)    /* { dg-warning ""invalid constant"" } */
#pragma pack(push,x,0.5)  /* { dg-warning ""invalid constant"" } */
","/* PR c/28286 */
/* { dg-do compile } */


#pragma pack(0.5)         /* { dg-warning ""invalid constant"" } */
#pragma pack(push,0.5)    /* { dg-warning ""invalid constant"" } */
#pragma pack(push,x,0.5)  /* { dg-warning ""invalid constant"" } */
"
"/* PR tree-optimization/59643 */
/* { dg-do compile } */
/* { dg-options ""-O3 -fdump-tree-pcom-details"" } */

void
foo (double *a, double *b, double *c, double d, double e, int n)
{
  int i;
  for (i = 1; i < n - 1; i++)
    a[i] = d * (b[i] + c[i] + a[i - 1] + a[i + 1]) + e * a[i];
}

/* { dg-final { scan-tree-dump-times ""Before commoning:"" 1 ""pcom"" } } */
/* { dg-final { scan-tree-dump-times ""Unrolling 2 times"" 1 ""pcom"" } } */
","/* PR tree-optimization/59643 */
/* { dg-do compile } */
/* { dg-options ""-O3 -fdump-tree-pcom-details"" } */

void
foo (double *a, double *b, double *c, double d, double e, int n)
{
  int i;
  for (i = 1; i < n - 1; i++)
    a[i] = d * (b[i] + c[i] + a[i - 1] + a[i + 1]) + e * a[i];
}

/* { dg-final { scan-tree-dump-times ""Before commoning:"" 1 ""pcom"" } } */
/* { dg-final { scan-tree-dump-times ""Unrolling 2 times"" 1 ""pcom"" } } */
"
"/* { dg-do compile } */
/* { dg-options ""-O2 -Wall -Wextra -fdiagnostics-show-caret"" } */

void fn1() {
  __builtin_printf(""\
     %ld.\n\
        2\n""); };
/* { dg-warning ""expects a matching"" """" { target *-*-* } .-3 } */
/* { dg-begin-multiline-output """" }
   __builtin_printf(""\
                    ^~
      %ld.\n\
      ~~~~~~~        
         2\n""); };
         ~~~~        
   { dg-end-multiline-output """" } */
","/* { dg-do compile } */
/* { dg-options ""-O2 -Wall -Wextra -fdiagnostics-show-caret"" } */

void fn1() {
  __builtin_printf(""\
     %ld.\n\
        2\n""); };
/* { dg-warning ""expects a matching"" """" { target *-*-* } .-3 } */
/* { dg-begin-multiline-output """" }
   __builtin_printf(""\
                    ^~
      %ld.\n\
      ~~~~~~~        
         2\n""); };
         ~~~~        
   { dg-end-multiline-output """" } */
"
"/* { dg-do compile } */
/* { dg-options ""-fprofile-arcs"" } */
/* { dg-require-profiling ""-fprofile-generate"" } */

extern void bar(void) __attribute__((noreturn));
int foo (void) { bar(); }
","/* { dg-do compile } */
/* { dg-options ""-fprofile-arcs"" } */
/* { dg-require-profiling ""-fprofile-generate"" } */

extern void bar(void) __attribute__((noreturn));
int foo (void) { bar(); }
"
"/* { dg-do compile } */
/* { dg-options ""-fgimple"" } */

int __GIMPLE foo()
{
  if (a != 2) /* { dg-error ""undeclared"" } */
    goto bb1;
  else
    goto bb2;

bb1:
  a_1 = 10; /* { dg-error ""undeclared"" } */
  return a_1;

bb2:
  return 1;
}
","/* { dg-do compile } */
/* { dg-options ""-fgimple"" } */

int __GIMPLE foo()
{
  if (a != 2) /* { dg-error ""undeclared"" } */
    goto bb1;
  else
    goto bb2;

bb1:
  a_1 = 10; /* { dg-error ""undeclared"" } */
  return a_1;

bb2:
  return 1;
}
"
"/* Testing return address signing where combined instructions used.  */
/* { dg-do compile } */
/* { dg-options ""-O2 -msign-return-address=all"" } */
/* { dg-require-effective-target lp64 } */

int foo (int);
int bar (int, int);

int __attribute__ ((target (""arch=armv8.3-a"")))
func1 (int a, int b, int c)
{
  /* paciasp */
  return a + foo (b) + c;
  /* retaa */
}

/* { dg-final { scan-assembler-times ""paciasp"" 1 } } */
/* { dg-final { scan-assembler-times ""retaa"" 1 } } */
","/* Testing return address signing where combined instructions used.  */
/* { dg-do compile } */
/* { dg-options ""-O2 -msign-return-address=all"" } */
/* { dg-require-effective-target lp64 } */

int foo (int);
int bar (int, int);

int __attribute__ ((target (""arch=armv8.3-a"")))
func1 (int a, int b, int c)
{
  /* paciasp */
  return a + foo (b) + c;
  /* retaa */
}

/* { dg-final { scan-assembler-times ""paciasp"" 1 } } */
/* { dg-final { scan-assembler-times ""retaa"" 1 } } */
"
"/* { dg-do compile } */
#include <altivec.h>
vector float _0 ;
vector pixel _1 ;
vector bool int _2 ;
vector unsigned int _3 ;
vector signed int _4 ;
vector bool short _5 ;
vector unsigned short _6 ;
vector signed short _7 ;
vector bool char _8 ;
vector unsigned char _9 ;
vector signed char _10 ;
","/* { dg-do compile } */
#include <altivec.h>
vector float _0 ;
vector pixel _1 ;
vector bool int _2 ;
vector unsigned int _3 ;
vector signed int _4 ;
vector bool short _5 ;
vector unsigned short _6 ;
vector signed short _7 ;
vector bool char _8 ;
vector unsigned char _9 ;
vector signed char _10 ;
"
"/* { dg-do run { target { ! ia32 } } } */
/* { dg-options ""-O2 -mavx512f"" } */
/* { dg-require-effective-target avx512f } */

#include ""avx512f-check.h""

static unsigned long long
__attribute__((noinline, unused))
test (union128 s1)
{
  return _mm_cvttss_u64 (s1.x);
}

void static
avx512f_test (void)
{
  union128 s1;
  unsigned long long d;
  unsigned long long e;

  s1.x = _mm_set_ps (24.43, 68.346, 10.756, 89.145);
  d =  test (s1);
  e = (unsigned long long)s1.a[0];

  if (e != d)
    abort ();
}
","/* { dg-do run { target { ! ia32 } } } */
/* { dg-options ""-O2 -mavx512f"" } */
/* { dg-require-effective-target avx512f } */

#include ""avx512f-check.h""

static unsigned long long
__attribute__((noinline, unused))
test (union128 s1)
{
  return _mm_cvttss_u64 (s1.x);
}

void static
avx512f_test (void)
{
  union128 s1;
  unsigned long long d;
  unsigned long long e;

  s1.x = _mm_set_ps (24.43, 68.346, 10.756, 89.145);
  d =  test (s1);
  e = (unsigned long long)s1.a[0];

  if (e != d)
    abort ();
}
"
"/* { dg-do compile { target { powerpc*-*-* } } } */
/* { dg-skip-if ""do not override -mcpu"" { powerpc*-*-* } { ""-mcpu=*"" } { ""-mcpu=power9"" } } */
/* { dg-require-effective-target powerpc_p9vector_ok } */
/* { dg-skip-if """" { powerpc*-*-aix* } } */
/* { dg-options ""-mcpu=power9"" } */

/* This test should succeed on both 32- and 64-bit configurations.  */
#include <altivec.h>

int
test_byte_in_range (unsigned char b,
		    unsigned char low_range, unsigned char high_range)
{
  unsigned int range_encoding = (high_range << 8) | low_range;
  return __builtin_byte_in_range (b, range_encoding);
}

/* { dg-final { scan-assembler ""cmprb"" } } */
/* { dg-final { scan-assembler ""setb"" } } */
","/* { dg-do compile { target { powerpc*-*-* } } } */
/* { dg-skip-if ""do not override -mcpu"" { powerpc*-*-* } { ""-mcpu=*"" } { ""-mcpu=power9"" } } */
/* { dg-require-effective-target powerpc_p9vector_ok } */
/* { dg-skip-if """" { powerpc*-*-aix* } } */
/* { dg-options ""-mcpu=power9"" } */

/* This test should succeed on both 32- and 64-bit configurations.  */
#include <altivec.h>

int
test_byte_in_range (unsigned char b,
		    unsigned char low_range, unsigned char high_range)
{
  unsigned int range_encoding = (high_range << 8) | low_range;
  return __builtin_byte_in_range (b, range_encoding);
}

/* { dg-final { scan-assembler ""cmprb"" } } */
/* { dg-final { scan-assembler ""setb"" } } */
"
"/* Verify that overloaded built-ins for vec_mule,vec_mulo with char
   inputs produce the right results.  */

/* { dg-do compile } */
/* { dg-require-effective-target powerpc_altivec_ok } */
/* { dg-options ""-maltivec -O2"" } */

#include <altivec.h>

vector signed short
test_even (vector signed char x, vector signed char y)
{
  return vec_mule (x, y);
}

vector unsigned short
test_uns_even (vector unsigned char x, vector unsigned char y)
{
  return vec_mule (x, y);
}

vector signed short
test_odd (vector signed char x, vector signed char y)
{
  return vec_mulo (x, y);
}

vector unsigned short
test_uns_odd (vector unsigned char x, vector unsigned char y)
{
  return vec_mulo (x, y);
}

/* { dg-final { scan-assembler-times ""vmuleub"" 1 } } */
/* { dg-final { scan-assembler-times ""vmulesb"" 1 } } */
/* { dg-final { scan-assembler-times ""vmuloub"" 1 } } */
/* { dg-final { scan-assembler-times ""vmulosb"" 1 } } */

","/* Verify that overloaded built-ins for vec_mule,vec_mulo with char
   inputs produce the right results.  */

/* { dg-do compile } */
/* { dg-require-effective-target powerpc_altivec_ok } */
/* { dg-options ""-maltivec -O2"" } */

#include <altivec.h>

vector signed short
test_even (vector signed char x, vector signed char y)
{
  return vec_mule (x, y);
}

vector unsigned short
test_uns_even (vector unsigned char x, vector unsigned char y)
{
  return vec_mule (x, y);
}

vector signed short
test_odd (vector signed char x, vector signed char y)
{
  return vec_mulo (x, y);
}

vector unsigned short
test_uns_odd (vector unsigned char x, vector unsigned char y)
{
  return vec_mulo (x, y);
}

/* { dg-final { scan-assembler-times ""vmuleub"" 1 } } */
/* { dg-final { scan-assembler-times ""vmulesb"" 1 } } */
/* { dg-final { scan-assembler-times ""vmuloub"" 1 } } */
/* { dg-final { scan-assembler-times ""vmulosb"" 1 } } */

"
"/* { dg-do compile } */
/* { dg-options ""-O2 -mavx512vl"" } */
/* { dg-final { scan-assembler-times ""vpcmpd\[ \\t\]+\[^\{\n\]*%ymm\[0-9\]+\[^\n^k\]*%k\[1-7\](?:\n|\[ \\t\]+#)"" 1 } } */
/* { dg-final { scan-assembler-times ""vpcmpd\[ \\t\]+\[^\{\n\]*%ymm\[0-9\]+\[^\n^k\]*%k\[1-7\]\{%k\[0-7\]\}(?:\n|\[ \\t\]+#)"" 1 } } */
/* { dg-final { scan-assembler-times ""vpcmpd\[ \\t\]+\[^\{\n\]*%xmm\[0-9\]+\[^\n^k\]*%k\[1-7\](?:\n|\[ \\t\]+#)"" 1 } } */
/* { dg-final { scan-assembler-times ""vpcmpd\[ \\t\]+\[^\{\n\]*%xmm\[0-9\]+\[^\n^k\]*%k\[1-7\]\{%k\[0-7\]\}(?:\n|\[ \\t\]+#)"" 1 } } */

#include <immintrin.h>

volatile __m256i x;
volatile __m128i xx;
volatile __mmask8 m;

void extern
avx512vl_test (void)
{
  m = _mm256_cmp_epi32_mask (x, x, _MM_CMPINT_EQ);
  m = _mm256_mask_cmp_epi32_mask (m, x, x, _MM_CMPINT_EQ);
  m = _mm_cmp_epi32_mask (xx, xx, _MM_CMPINT_EQ);
  m = _mm_mask_cmp_epi32_mask (m, xx, xx, _MM_CMPINT_EQ);
}
","/* { dg-do compile } */
/* { dg-options ""-O2 -mavx512vl"" } */
/* { dg-final { scan-assembler-times ""vpcmpd\[ \\t\]+\[^\{\n\]*%ymm\[0-9\]+\[^\n^k\]*%k\[1-7\](?:\n|\[ \\t\]+#)"" 1 } } */
/* { dg-final { scan-assembler-times ""vpcmpd\[ \\t\]+\[^\{\n\]*%ymm\[0-9\]+\[^\n^k\]*%k\[1-7\]\{%k\[0-7\]\}(?:\n|\[ \\t\]+#)"" 1 } } */
/* { dg-final { scan-assembler-times ""vpcmpd\[ \\t\]+\[^\{\n\]*%xmm\[0-9\]+\[^\n^k\]*%k\[1-7\](?:\n|\[ \\t\]+#)"" 1 } } */
/* { dg-final { scan-assembler-times ""vpcmpd\[ \\t\]+\[^\{\n\]*%xmm\[0-9\]+\[^\n^k\]*%k\[1-7\]\{%k\[0-7\]\}(?:\n|\[ \\t\]+#)"" 1 } } */

#include <immintrin.h>

volatile __m256i x;
volatile __m128i xx;
volatile __mmask8 m;

void extern
avx512vl_test (void)
{
  m = _mm256_cmp_epi32_mask (x, x, _MM_CMPINT_EQ);
  m = _mm256_mask_cmp_epi32_mask (m, x, x, _MM_CMPINT_EQ);
  m = _mm_cmp_epi32_mask (xx, xx, _MM_CMPINT_EQ);
  m = _mm_mask_cmp_epi32_mask (m, xx, xx, _MM_CMPINT_EQ);
}
"
"/* Verify that the fmac insn is used for the expression 'a * b + a' and
   'a * a + a' when -ffast-math is specified.  */
/* { dg-do compile { target { any_fpu } } }  */
/* { dg-options ""-O1 -ffast-math"" } */
/* { dg-final { scan-assembler-times ""fmac"" 2 } } */

float
test_00 (float a, float b)
{
  return a * b + a;
}

float
test_01 (float a)
{
  return a * a + a;
}
","/* Verify that the fmac insn is used for the expression 'a * b + a' and
   'a * a + a' when -ffast-math is specified.  */
/* { dg-do compile { target { any_fpu } } }  */
/* { dg-options ""-O1 -ffast-math"" } */
/* { dg-final { scan-assembler-times ""fmac"" 2 } } */

float
test_00 (float a, float b)
{
  return a * b + a;
}

float
test_01 (float a)
{
  return a * a + a;
}
"
"/* { dg-do assemble } */
/* { dg-options ""-O2 -save-temps"" } */

typedef int __v2si __attribute__((__vector_size__(8)));

int __attribute__((unused))
vector_cvt (__v2si arg)
{
  __v2si val4 = arg;
  char *p = (char*)&val4;

  if (p[0] != 1)
    return 1;
  if (p[1] != 2)
    return 1;
  if (p[2] != 3)
    return 1;

  return 0;
}

int
vector_cvt_2 (__v2si val, __v2si val2)
{
  char *p = (char*)&val;
  char *p2 = (char*)&val2;

  if (p[0] != p2[0])
    return 1;
  if (p[4] != p2[4])
    return 1;

  return 0;
}

/* We want to test for 'mov.t' here, but given PR80845 we test for cvt.t.t
   instead.
   { dg-final { scan-assembler ""(?n)cvt\\.u32\\.u32.*\\.x"" } } */
/* { dg-final { scan-assembler ""(?n)cvt\\.u16\\.u32.*\\.x"" } } */
","/* { dg-do assemble } */
/* { dg-options ""-O2 -save-temps"" } */

typedef int __v2si __attribute__((__vector_size__(8)));

int __attribute__((unused))
vector_cvt (__v2si arg)
{
  __v2si val4 = arg;
  char *p = (char*)&val4;

  if (p[0] != 1)
    return 1;
  if (p[1] != 2)
    return 1;
  if (p[2] != 3)
    return 1;

  return 0;
}

int
vector_cvt_2 (__v2si val, __v2si val2)
{
  char *p = (char*)&val;
  char *p2 = (char*)&val2;

  if (p[0] != p2[0])
    return 1;
  if (p[4] != p2[4])
    return 1;

  return 0;
}

/* We want to test for 'mov.t' here, but given PR80845 we test for cvt.t.t
   instead.
   { dg-final { scan-assembler ""(?n)cvt\\.u32\\.u32.*\\.x"" } } */
/* { dg-final { scan-assembler ""(?n)cvt\\.u16\\.u32.*\\.x"" } } */
"
"#include <arm_neon.h>

/* { dg-do compile } */
/* { dg-skip-if """" { *-*-* } { ""-fno-fat-lto-objects"" } } */

void
f_vst4q_lane_u16 (uint16_t * p, uint16x8x4_t v)
{
  /* { dg-error ""lane 8 out of range 0 - 7"" """" { target *-*-* } 0 } */
  vst4q_lane_u16 (p, v, 8);
  /* { dg-error ""lane -1 out of range 0 - 7"" """" { target *-*-* } 0 } */
  vst4q_lane_u16 (p, v, -1);
  return;
}
","#include <arm_neon.h>

/* { dg-do compile } */
/* { dg-skip-if """" { *-*-* } { ""-fno-fat-lto-objects"" } } */

void
f_vst4q_lane_u16 (uint16_t * p, uint16x8x4_t v)
{
  /* { dg-error ""lane 8 out of range 0 - 7"" """" { target *-*-* } 0 } */
  vst4q_lane_u16 (p, v, 8);
  /* { dg-error ""lane -1 out of range 0 - 7"" """" { target *-*-* } 0 } */
  vst4q_lane_u16 (p, v, -1);
  return;
}
"
"#include <stdarg.h>

main ()
{
  double f (int x, ...)
    {
      va_list args;
      double a;

      va_start (args, x);
      a = va_arg (args, double);
      va_end (args);
      return a;
    }

  if (f (1, (double)1) != 1.0)
    abort ();
  exit (0);
}
","#include <stdarg.h>

main ()
{
  double f (int x, ...)
    {
      va_list args;
      double a;

      va_start (args, x);
      a = va_arg (args, double);
      va_end (args);
      return a;
    }

  if (f (1, (double)1) != 1.0)
    abort ();
  exit (0);
}
"
"typedef struct {
    int x;
} FILE;
extern void fputs (const char *, FILE *);

int mView;
void foo (FILE * out, int aIndent)
{
    if (0 != mView) {
	aIndent++;
	aIndent--;
	{
	    int __t = aIndent;
	    while (--__t >= 0)
		fputs (""  "", out);
	}

    } {
	int __t = aIndent;
	while (--__t >= 0)
	    fputs (""  "", out);
    }
}
","typedef struct {
    int x;
} FILE;
extern void fputs (const char *, FILE *);

int mView;
void foo (FILE * out, int aIndent)
{
    if (0 != mView) {
	aIndent++;
	aIndent--;
	{
	    int __t = aIndent;
	    while (--__t >= 0)
		fputs (""  "", out);
	}

    } {
	int __t = aIndent;
	while (--__t >= 0)
	    fputs (""  "", out);
    }
}
"
"/* Test for bug where fold narrowed decimal floating-point
   operations.  */

#include ""dfp-dbg.h""

volatile _Decimal32 f = 1.23456DF;
volatile _Decimal64 d = 1.23456DD;

int
main (void)
{
  if ((double)((_Decimal64)f * (_Decimal64)f) != (double)(d * d))
    FAILURE
  FINISH
}
","/* Test for bug where fold narrowed decimal floating-point
   operations.  */

#include ""dfp-dbg.h""

volatile _Decimal32 f = 1.23456DF;
volatile _Decimal64 d = 1.23456DD;

int
main (void)
{
  if ((double)((_Decimal64)f * (_Decimal64)f) != (double)(d * d))
    FAILURE
  FINISH
}
"
"
void
Rotate (float angle)
{
    float mag = (angle < 0) ? -angle : angle;
}
","
void
Rotate (float angle)
{
    float mag = (angle < 0) ? -angle : angle;
}
"
"/* Verify that overloaded built-ins for vec_mul with float and
   double inputs for VSX produce the right results.  */

/* { dg-do compile } */
/* { dg-require-effective-target powerpc_vsx_ok } */
/* { dg-options ""-mvsx"" } */

#include <altivec.h>

vector float
test1 (vector float x, vector float y)
{
  return vec_mul (x, y);
}

vector double
test2 (vector double x, vector double y)
{
  return vec_mul (x, y);
}

/* { dg-final { scan-assembler-times ""\[ \t\]xvmulsp"" 1 } } */
/* { dg-final { scan-assembler-times ""\[ \t\]xvmuldp"" 1 } } */
","/* Verify that overloaded built-ins for vec_mul with float and
   double inputs for VSX produce the right results.  */

/* { dg-do compile } */
/* { dg-require-effective-target powerpc_vsx_ok } */
/* { dg-options ""-mvsx"" } */

#include <altivec.h>

vector float
test1 (vector float x, vector float y)
{
  return vec_mul (x, y);
}

vector double
test2 (vector double x, vector double y)
{
  return vec_mul (x, y);
}

/* { dg-final { scan-assembler-times ""\[ \t\]xvmulsp"" 1 } } */
/* { dg-final { scan-assembler-times ""\[ \t\]xvmuldp"" 1 } } */
"
"/* { dg-do compile } */
/* { dg-require-effective-target arm_fp_ok } */
/* { dg-options ""-mfp16-format=ieee"" } */
/* { dg-add-options arm_fp } */

#include ""arm_neon.h""

float16x4_t __attribute__((target(""fpu=neon-fp16"")))
foo (float32x4_t arg)
{
    return vcvt_f16_f32 (arg);
}
","/* { dg-do compile } */
/* { dg-require-effective-target arm_fp_ok } */
/* { dg-options ""-mfp16-format=ieee"" } */
/* { dg-add-options arm_fp } */

#include ""arm_neon.h""

float16x4_t __attribute__((target(""fpu=neon-fp16"")))
foo (float32x4_t arg)
{
    return vcvt_f16_f32 (arg);
}
"
"/* { dg-do compile } */
/* { dg-options ""-std=gnu99 -Wunsuffixed-float-constants"" } */

#define VAL 0.5;

double a = 1.1d;

/* With FLOAT_CONST_DECIMAL64 switched to ON these would have type
   _Decimal64.  */

double b = VAL;		/* { dg-warning ""unsuffixed float constant"" } */
double c = 1.2;		/* { dg-warning ""unsuffixed float constant"" } */

/* With FLOAT_CONST_DECIMAL64 switched to ON these are still binary.  */

double d = 0x5.0p1;	/* No warning for hex constant.  */
double e = 3.1i;	/* No warning for imaginary constant.  */
","/* { dg-do compile } */
/* { dg-options ""-std=gnu99 -Wunsuffixed-float-constants"" } */

#define VAL 0.5;

double a = 1.1d;

/* With FLOAT_CONST_DECIMAL64 switched to ON these would have type
   _Decimal64.  */

double b = VAL;		/* { dg-warning ""unsuffixed float constant"" } */
double c = 1.2;		/* { dg-warning ""unsuffixed float constant"" } */

/* With FLOAT_CONST_DECIMAL64 switched to ON these are still binary.  */

double d = 0x5.0p1;	/* No warning for hex constant.  */
double e = 3.1i;	/* No warning for imaginary constant.  */
"
"/* { dg-do compile } */
/* { dg-options ""-O -fgimple"" } */

struct Y { int b[2]; };
struct X { int a; struct Y y; };
struct X x;

int __GIMPLE ()
foo (struct X *p, _Complex int q)
{
  int b;
  b = __real q;
  p->a = b;
  x.y.b[b] = b;
  b = p->y.b[1];
  b = x.a;
  return b;
}
","/* { dg-do compile } */
/* { dg-options ""-O -fgimple"" } */

struct Y { int b[2]; };
struct X { int a; struct Y y; };
struct X x;

int __GIMPLE ()
foo (struct X *p, _Complex int q)
{
  int b;
  b = __real q;
  p->a = b;
  x.y.b[b] = b;
  b = p->y.b[1];
  b = x.a;
  return b;
}
"
"/* { dg-do compile } */
/* { dg-require-effective-target indirect_jumps } */

#include <setjmp.h>

extern int optind;
jmp_buf jump_buf;
void foo (jmp_buf, int);
void bar (char *);
int
main (int argc, char **argv)
{
  foo (jump_buf, setjmp(jump_buf));
  argv += optind;
  bar(argv[1]);
}
","/* { dg-do compile } */
/* { dg-require-effective-target indirect_jumps } */

#include <setjmp.h>

extern int optind;
jmp_buf jump_buf;
void foo (jmp_buf, int);
void bar (char *);
int
main (int argc, char **argv)
{
  foo (jump_buf, setjmp(jump_buf));
  argv += optind;
  bar(argv[1]);
}
"
"/* We used to ICE because we had forgot to update the immediate_uses
   information after foldding the last strcpy in Reduce PHI.
   This was PR tree-opt/19763. */

extern char *strcpy (char *, const char *);
void sdbout_one_type (char *p)
{
  int i, t = 1;
  char *q;
  for (i = 0; i < 2; i++)
    {
      strcpy (p, ""1"");
      p += sizeof (""1"");
    }
  if (t)
    q = ""2"";
  else
    q = ""3"";
  strcpy (p, q);
}

","/* We used to ICE because we had forgot to update the immediate_uses
   information after foldding the last strcpy in Reduce PHI.
   This was PR tree-opt/19763. */

extern char *strcpy (char *, const char *);
void sdbout_one_type (char *p)
{
  int i, t = 1;
  char *q;
  for (i = 0; i < 2; i++)
    {
      strcpy (p, ""1"");
      p += sizeof (""1"");
    }
  if (t)
    q = ""2"";
  else
    q = ""3"";
  strcpy (p, q);
}

"
"int test_1 (int i, int j, int k)
{
  if (i < j)
    return k + 4;
  else
    return -k;
}

/* Example showing:
   - data structure
   - loop
   - call to ""abort"".  */

struct foo
{
  int count;
  float *data;
};

float test_2 (struct foo *lhs, struct foo *rhs)
{
  float result = 0.0f;

  if (lhs->count != rhs->count)
    __builtin_abort ();

  for (int i = 0; i < lhs->count; i++)
    result += lhs->data[i] * rhs->data[i];

  return result;
}
","int test_1 (int i, int j, int k)
{
  if (i < j)
    return k + 4;
  else
    return -k;
}

/* Example showing:
   - data structure
   - loop
   - call to ""abort"".  */

struct foo
{
  int count;
  float *data;
};

float test_2 (struct foo *lhs, struct foo *rhs)
{
  float result = 0.0f;

  if (lhs->count != rhs->count)
    __builtin_abort ();

  for (int i = 0; i < lhs->count; i++)
    result += lhs->data[i] * rhs->data[i];

  return result;
}
"
"/* { dg-do link } */
/* { dg-options ""-O2 -mbmi"" } */

#include <x86intrin.h>

/* Test that a constant operand 0 to tzcnt gets folded.  */
extern void link_error(void);
int main()
{
  if (__tzcnt_u32(0) != 32)
    link_error();
  return 0;
}
","/* { dg-do link } */
/* { dg-options ""-O2 -mbmi"" } */

#include <x86intrin.h>

/* Test that a constant operand 0 to tzcnt gets folded.  */
extern void link_error(void);
int main()
{
  if (__tzcnt_u32(0) != 32)
    link_error();
  return 0;
}
"
"/*  On H8, the predicate general_operand_src(op,mode) used to ignore
    mode when op is a (mem (post_inc ...)).  As a result, the pattern
    for extendhisi2 was recognized as extendqisi2.  */

extern void abort ();
extern void exit (int);

short *q;

long
foo (short *p)
{
  long b = *p;
  q = p + 1;
  return b;
}

int
main ()
{
  short a = 0xff00;
  if (foo (&a) != (long) (short) 0xff00)
    abort ();
  exit (0);
}
","/*  On H8, the predicate general_operand_src(op,mode) used to ignore
    mode when op is a (mem (post_inc ...)).  As a result, the pattern
    for extendhisi2 was recognized as extendqisi2.  */

extern void abort ();
extern void exit (int);

short *q;

long
foo (short *p)
{
  long b = *p;
  q = p + 1;
  return b;
}

int
main ()
{
  short a = 0xff00;
  if (foo (&a) != (long) (short) 0xff00)
    abort ();
  exit (0);
}
"
"/* { dg-do run } */
/* { dg-options ""-O"" } */

struct in_addr {
	unsigned int s_addr;
};

struct ip {
	unsigned char ip_p;
	unsigned short ip_sum;
	struct	in_addr ip_src,ip_dst;
} __attribute__ ((aligned(1), packed));

struct ip ip_fw_fwd_addr;

int test_alignment( char *m )
{
  struct ip *ip = (struct ip *) m;
  struct in_addr pkt_dst;
  pkt_dst = ip->ip_dst ;
  if( pkt_dst.s_addr == 0 )
    return 1;
  else
    return 0;
}

int __attribute__ ((noinline, noclone))
intermediary (char *p)
{
  return test_alignment (p);
}

int
main (int argc, char *argv[])
{
  ip_fw_fwd_addr.ip_dst.s_addr = 1;
  return intermediary ((void *) &ip_fw_fwd_addr);
}
","/* { dg-do run } */
/* { dg-options ""-O"" } */

struct in_addr {
	unsigned int s_addr;
};

struct ip {
	unsigned char ip_p;
	unsigned short ip_sum;
	struct	in_addr ip_src,ip_dst;
} __attribute__ ((aligned(1), packed));

struct ip ip_fw_fwd_addr;

int test_alignment( char *m )
{
  struct ip *ip = (struct ip *) m;
  struct in_addr pkt_dst;
  pkt_dst = ip->ip_dst ;
  if( pkt_dst.s_addr == 0 )
    return 1;
  else
    return 0;
}

int __attribute__ ((noinline, noclone))
intermediary (char *p)
{
  return test_alignment (p);
}

int
main (int argc, char *argv[])
{
  ip_fw_fwd_addr.ip_dst.s_addr = 1;
  return intermediary ((void *) &ip_fw_fwd_addr);
}
"
"void
yysyntax_error (char *yyp)
{
        char const *yyf;
        char yyformat[5];

        yyf = yyformat;
        while ((*yyp = *yyf) != '\0') {
                if (yyf[1] == 's')
                        yyf += 2;
        }
}
","void
yysyntax_error (char *yyp)
{
        char const *yyf;
        char yyformat[5];

        yyf = yyformat;
        while ((*yyp = *yyf) != '\0') {
                if (yyf[1] == 's')
                        yyf += 2;
        }
}
"
"/* { dg-require-effective-target untyped_assembly } */
/* { dg-require-stack-check """" } */
/* { dg-additional-options ""-fstack-check"" } */
#include ""20031023-1.c""
","/* { dg-require-effective-target untyped_assembly } */
/* { dg-require-stack-check """" } */
/* { dg-additional-options ""-fstack-check"" } */
#include ""20031023-1.c""
"
"/* { dg-do compile } */
/* { dg-options ""-O2 -ftree-vectorize -fgimple -ffast-math"" } */

double __GIMPLE (startwith(""loop""))
neg_xi (double *x)
{
  int i;
  long unsigned int index;
  long unsigned int offset;
  double * xi_ptr;
  double xi;
  double neg_xi;
  double res;
  unsigned int ivtmp;

 bb_1:
  goto bb_2;

 bb_2:
  res_1 = __PHI (bb_1: 0.0, bb_3: res_2);
  i_4 = __PHI (bb_1: 0, bb_3: i_5);
  ivtmp_6 = __PHI (bb_1: 100U, bb_3: ivtmp_7);
  index = (long unsigned int) i_4;
  offset = index * 8UL;
  xi_ptr = x_8(D) + offset;
  xi = *xi_ptr;
  neg_xi = -xi;
  res_2 = neg_xi + res_1;
  i_5 = i_4 + 1;
  ivtmp_7 = ivtmp_6 - 1U;
  if (ivtmp_7 != 0U)
    goto bb_3;
  else
    goto bb_4;

 bb_3:
  goto bb_2;

 bb_4:
  res_3 = __PHI (bb_2: res_2);
  return res_3;
}

/* { dg-final { scan-assembler {\tfsub\tz[0-9]+\.d, p[0-7]/m} } } */
/* { dg-final { scan-assembler-not {\tsel\t} } } */
/* { dg-final { scan-assembler-not {\tmovprfx\t} } } */
","/* { dg-do compile } */
/* { dg-options ""-O2 -ftree-vectorize -fgimple -ffast-math"" } */

double __GIMPLE (startwith(""loop""))
neg_xi (double *x)
{
  int i;
  long unsigned int index;
  long unsigned int offset;
  double * xi_ptr;
  double xi;
  double neg_xi;
  double res;
  unsigned int ivtmp;

 bb_1:
  goto bb_2;

 bb_2:
  res_1 = __PHI (bb_1: 0.0, bb_3: res_2);
  i_4 = __PHI (bb_1: 0, bb_3: i_5);
  ivtmp_6 = __PHI (bb_1: 100U, bb_3: ivtmp_7);
  index = (long unsigned int) i_4;
  offset = index * 8UL;
  xi_ptr = x_8(D) + offset;
  xi = *xi_ptr;
  neg_xi = -xi;
  res_2 = neg_xi + res_1;
  i_5 = i_4 + 1;
  ivtmp_7 = ivtmp_6 - 1U;
  if (ivtmp_7 != 0U)
    goto bb_3;
  else
    goto bb_4;

 bb_3:
  goto bb_2;

 bb_4:
  res_3 = __PHI (bb_2: res_2);
  return res_3;
}

/* { dg-final { scan-assembler {\tfsub\tz[0-9]+\.d, p[0-7]/m} } } */
/* { dg-final { scan-assembler-not {\tsel\t} } } */
/* { dg-final { scan-assembler-not {\tmovprfx\t} } } */
"
"long double C = 5;
long double U = 1;
long double Y2 = 11;
long double Y1 = 17;
long double X, Y, Z, T, R, S;
main ()
{
  X = (C + U) * Y2;
  Y = C - U - U;
  Z = C + U + U;
  T = (C - U) * Y1;
  X = X - (Z + U);
  R = Y * Y1;
  S = Z * Y2;
  T = T - Y;
  Y = (U - Y) + R;
  Z = S - (Z + U + U);
  R = (Y2 + U) * Y1;
  Y1 = Y2 * Y1;
  R = R - Y2;
  Y1 = Y1 - 0.5L;
  if (Z != 68. || Y != 49. || X != 58. || Y1 != 186.5 || R != 193. || S != 77.
      || T != 65. || Y2 != 11.)
    abort ();
  exit (0);
}
","long double C = 5;
long double U = 1;
long double Y2 = 11;
long double Y1 = 17;
long double X, Y, Z, T, R, S;
main ()
{
  X = (C + U) * Y2;
  Y = C - U - U;
  Z = C + U + U;
  T = (C - U) * Y1;
  X = X - (Z + U);
  R = Y * Y1;
  S = Z * Y2;
  T = T - Y;
  Y = (U - Y) + R;
  Z = S - (Z + U + U);
  R = (Y2 + U) * Y1;
  Y1 = Y2 * Y1;
  R = R - Y2;
  Y1 = Y1 - 0.5L;
  if (Z != 68. || Y != 49. || X != 58. || Y1 != 186.5 || R != 193. || S != 77.
      || T != 65. || Y2 != 11.)
    abort ();
  exit (0);
}
"
"/* { dg-require-effective-target vect_float } */
/* { dg-require-effective-target vect_intfloat_cvt } */
#include <stdarg.h>
#include ""tree-vect.h""

#define N 40
float image[N][N] __attribute__ ((__aligned__(__BIGGEST_ALIGNMENT__)));
float out[N];

/* Outer-loop vectorization.  */

__attribute__ ((noinline)) void
foo (){
  int i,j;

  for (i = 0; i < N; i++) {
    for (j = 0; j < N; j++) {
      image[j][i] = j+i;
    }
  }
}

int main (void)
{
  check_vect ();
  int i, j;

  foo ();

  for (i = 0; i < N; i++) {
    for (j = 0; j < N; j++) {
      if (image[j][i] != j+i)
	abort ();
    }
  }

  return 0;
}

/* { dg-final { scan-tree-dump-times ""OUTER LOOP VECTORIZED"" 1 ""vect"" } } */
","/* { dg-require-effective-target vect_float } */
/* { dg-require-effective-target vect_intfloat_cvt } */
#include <stdarg.h>
#include ""tree-vect.h""

#define N 40
float image[N][N] __attribute__ ((__aligned__(__BIGGEST_ALIGNMENT__)));
float out[N];

/* Outer-loop vectorization.  */

__attribute__ ((noinline)) void
foo (){
  int i,j;

  for (i = 0; i < N; i++) {
    for (j = 0; j < N; j++) {
      image[j][i] = j+i;
    }
  }
}

int main (void)
{
  check_vect ();
  int i, j;

  foo ();

  for (i = 0; i < N; i++) {
    for (j = 0; j < N; j++) {
      if (image[j][i] != j+i)
	abort ();
    }
  }

  return 0;
}

/* { dg-final { scan-tree-dump-times ""OUTER LOOP VECTORIZED"" 1 ""vect"" } } */
"
"/* { dg-do compile } */
#include <altivec.h>

vector signed short _j =  {-24132, 25298, -27969, -10358, 24164, -5157, -18143, -6509};

","/* { dg-do compile } */
#include <altivec.h>

vector signed short _j =  {-24132, 25298, -27969, -10358, 24164, -5157, -18143, -6509};

"
"/* { dg-do compile } */
/* { dg-options ""-c -fplugin=foo"" } */

/* { dg-prune-output "".*inaccessible plugin file.*foo\.so expanded from short plugin name.*"" } */
","/* { dg-do compile } */
/* { dg-options ""-c -fplugin=foo"" } */

/* { dg-prune-output "".*inaccessible plugin file.*foo\.so expanded from short plugin name.*"" } */
"
"/* Verify that overloaded built-ins for vec_neg with char
   inputs produce the right code.  */

/* { dg-do compile } */
/* { dg-require-effective-target powerpc_p8vector_ok } */
/* { dg-options ""-mvsx -O2 -mcpu=power8"" } */
/* { dg-skip-if ""do not override -mcpu"" { powerpc*-*-* } { ""-mcpu=*"" } { ""-mcpu=power8"" } } */

#include <altivec.h>

vector signed char
test2 (vector signed char x)
{
  return vec_neg (x);
}

/* { dg-final { scan-assembler-times ""xxspltib|vspltisw|vxor"" 1 } } */
/* { dg-final { scan-assembler-times ""vsububm"" 1 } } */
/* { dg-final { scan-assembler-times ""vmaxsb"" 0 } } */

","/* Verify that overloaded built-ins for vec_neg with char
   inputs produce the right code.  */

/* { dg-do compile } */
/* { dg-require-effective-target powerpc_p8vector_ok } */
/* { dg-options ""-mvsx -O2 -mcpu=power8"" } */
/* { dg-skip-if ""do not override -mcpu"" { powerpc*-*-* } { ""-mcpu=*"" } { ""-mcpu=power8"" } } */

#include <altivec.h>

vector signed char
test2 (vector signed char x)
{
  return vec_neg (x);
}

/* { dg-final { scan-assembler-times ""xxspltib|vspltisw|vxor"" 1 } } */
/* { dg-final { scan-assembler-times ""vsububm"" 1 } } */
/* { dg-final { scan-assembler-times ""vmaxsb"" 0 } } */

"
"/* { dg-do run { target { powerpc64*-*-* && p8vector_hw } } } */
/* { dg-options ""-mfloat128 -mvsx"" } */

void abort ();

typedef __complex float __cfloat128 __attribute__((mode(KC)));

__cfloat128 multiply (__cfloat128 x, __cfloat128 y)
{
  return x * y;
}

__cfloat128 z, a;

int main ()
{
  z = multiply (2.0q + 1.0jq, 3.0q + 1.0jq);
  a = 5.0q + 5.0jq;
  if (z != a)
    abort ();
  return 0;
}
","/* { dg-do run { target { powerpc64*-*-* && p8vector_hw } } } */
/* { dg-options ""-mfloat128 -mvsx"" } */

void abort ();

typedef __complex float __cfloat128 __attribute__((mode(KC)));

__cfloat128 multiply (__cfloat128 x, __cfloat128 y)
{
  return x * y;
}

__cfloat128 z, a;

int main ()
{
  z = multiply (2.0q + 1.0jq, 3.0q + 1.0jq);
  a = 5.0q + 5.0jq;
  if (z != a)
    abort ();
  return 0;
}
"
"/* { dg-do compile } */
/* { dg-options ""-mavx2 -O2"" } */
/* { dg-final { scan-assembler ""vpsrlvq\[ \\t\]+\[^\n\]*%ymm\[0-9\]"" } } */

#include <immintrin.h>

volatile __m256i x;

void extern
avx2_test (void)
{
  x = _mm256_srlv_epi64 (x, x);
}
","/* { dg-do compile } */
/* { dg-options ""-mavx2 -O2"" } */
/* { dg-final { scan-assembler ""vpsrlvq\[ \\t\]+\[^\n\]*%ymm\[0-9\]"" } } */

#include <immintrin.h>

volatile __m256i x;

void extern
avx2_test (void)
{
  x = _mm256_srlv_epi64 (x, x);
}
"
"/* { dg-do compile } */
/* { dg-skip-if ""no support for hard-float VFP ABI"" { arm_thumb1 } { ""-march=*"" } { """" } } */
/* { dg-skip-if ""do not override -mfloat-abi"" { *-*-* } { ""-mfloat-abi=*"" } { ""-mfloat-abi=hard"" } } */
/* { dg-skip-if ""avoid conflicting -mfpu"" { *-*-* } { ""-mfpu=*"" } { ""-mfpu=fpv4-sp-d16"" ""-mfpu=vfpv3xd"" ""-mfpu=vfpv3xd-fp16"" } } */
/* { dg-options ""-O2 -march=armv7-a -mfloat-abi=hard -mfpu=fpv4-sp-d16"" }  */

int func1 (double d)
{
  return (int)d;
}
unsigned int func2 (double d)
{
  return (unsigned int)d;
}

/* { dg-final { scan-assembler-times ""vmov\[\\t \]+r0,\[\\t \]*r1,\[\\t \]*d0"" 2 { target { arm_little_endian } } } } */
/* { dg-final { scan-assembler-times ""vmov\[\\t \]+r1,\[\\t \]*r0,\[\\t \]*d0"" 2 { target { ! arm_little_endian } } } } */
","/* { dg-do compile } */
/* { dg-skip-if ""no support for hard-float VFP ABI"" { arm_thumb1 } { ""-march=*"" } { """" } } */
/* { dg-skip-if ""do not override -mfloat-abi"" { *-*-* } { ""-mfloat-abi=*"" } { ""-mfloat-abi=hard"" } } */
/* { dg-skip-if ""avoid conflicting -mfpu"" { *-*-* } { ""-mfpu=*"" } { ""-mfpu=fpv4-sp-d16"" ""-mfpu=vfpv3xd"" ""-mfpu=vfpv3xd-fp16"" } } */
/* { dg-options ""-O2 -march=armv7-a -mfloat-abi=hard -mfpu=fpv4-sp-d16"" }  */

int func1 (double d)
{
  return (int)d;
}
unsigned int func2 (double d)
{
  return (unsigned int)d;
}

/* { dg-final { scan-assembler-times ""vmov\[\\t \]+r0,\[\\t \]*r1,\[\\t \]*d0"" 2 { target { arm_little_endian } } } } */
/* { dg-final { scan-assembler-times ""vmov\[\\t \]+r1,\[\\t \]*r0,\[\\t \]*d0"" 2 { target { ! arm_little_endian } } } } */
"
"/* Test case from PR middle-end/10472  */

extern void f (char *);

void foo (char *s)
{
  f (__builtin_stpcpy (s, ""hi""));
}

void bar (char *s)
{
  f (__builtin_mempcpy (s, ""hi"", 3));
}

","/* Test case from PR middle-end/10472  */

extern void f (char *);

void foo (char *s)
{
  f (__builtin_stpcpy (s, ""hi""));
}

void bar (char *s)
{
  f (__builtin_mempcpy (s, ""hi"", 3));
}

"
"/* PR target/77834 */
/* { dg-do compile } */
/* { dg-options ""-O -ftree-pre -Wno-psabi"" } */
/* { dg-additional-options ""-mstringop-strategy=libcall"" { target i?86-*-* x86_64-*-* } } */

typedef int V __attribute__ ((vector_size (64)));

V
foo (V u, V v, int w)
{
  do
    {
      if (u[0]) v ^= u[w];
    }
  while ((V) { 0, u[w] }[1]);
  u = (V) { v[v[0]], u[u[0]] };
  return v + u;
}
","/* PR target/77834 */
/* { dg-do compile } */
/* { dg-options ""-O -ftree-pre -Wno-psabi"" } */
/* { dg-additional-options ""-mstringop-strategy=libcall"" { target i?86-*-* x86_64-*-* } } */

typedef int V __attribute__ ((vector_size (64)));

V
foo (V u, V v, int w)
{
  do
    {
      if (u[0]) v ^= u[w];
    }
  while ((V) { 0, u[w] }[1]);
  u = (V) { v[v[0]], u[u[0]] };
  return v + u;
}
"
"/* PR sanitizer/79904 */
/* { dg-do compile } */
/* { dg-options ""-fsanitize=signed-integer-overflow -Wno-psabi"" } */

typedef signed char V __attribute__((vector_size (8))); 

void
foo (V *a) 
{ 
  *a = *a * (V) { 3, 4, 5, 6, 7, 8, 9, 10 }; 
}
","/* PR sanitizer/79904 */
/* { dg-do compile } */
/* { dg-options ""-fsanitize=signed-integer-overflow -Wno-psabi"" } */

typedef signed char V __attribute__((vector_size (8))); 

void
foo (V *a) 
{ 
  *a = *a * (V) { 3, 4, 5, 6, 7, 8, 9, 10 }; 
}
"
"/* { dg-do compile } */
/* { dg-options ""-O2 -fdump-tree-original"" } */

int test1(int a, int b)
{
  return (a ^ 2) == 2;
}

int test2(int c, int d)
{
  return (c ^ 4) != 4;
}

int test3(int e, int f)
{
  return (e ^ 2) == 6;
}

int test4(int g, int h)
{
  return (g ^ 6) != 4;
}

/* { dg-final { scan-tree-dump-times ""a == 0"" 1 ""original"" } } */
/* { dg-final { scan-tree-dump-times ""c != 0"" 1 ""original"" } } */
/* { dg-final { scan-tree-dump-times ""e == 4"" 1 ""original"" } } */
/* { dg-final { scan-tree-dump-times ""g != 2"" 1 ""original"" } } */
","/* { dg-do compile } */
/* { dg-options ""-O2 -fdump-tree-original"" } */

int test1(int a, int b)
{
  return (a ^ 2) == 2;
}

int test2(int c, int d)
{
  return (c ^ 4) != 4;
}

int test3(int e, int f)
{
  return (e ^ 2) == 6;
}

int test4(int g, int h)
{
  return (g ^ 6) != 4;
}

/* { dg-final { scan-tree-dump-times ""a == 0"" 1 ""original"" } } */
/* { dg-final { scan-tree-dump-times ""c != 0"" 1 ""original"" } } */
/* { dg-final { scan-tree-dump-times ""e == 4"" 1 ""original"" } } */
/* { dg-final { scan-tree-dump-times ""g != 2"" 1 ""original"" } } */
"
"struct S
{
  int *sp, fc, *sc, a[2];
};

f (struct S *x)
{
  int *t = x->sc;
  int t1 = t[0];
  int t2 = t[1];
  int t3 = t[2];
  int a0 = x->a[0];
  int a1 = x->a[1];
  t[2] = t1;
  t[0] = a1;
  x->a[1] = a0;
  x->a[0] = t3;
  x->fc = t2;
  x->sp = t;
}

main ()
{
  struct S s;
  static int sc[3] = {2, 3, 4};
  s.sc = sc;
  s.a[0] = 10;
  s.a[1] = 11;
  f (&s);
  if (s.sp[2] != 2)
    abort ();
  exit (0);
}
","struct S
{
  int *sp, fc, *sc, a[2];
};

f (struct S *x)
{
  int *t = x->sc;
  int t1 = t[0];
  int t2 = t[1];
  int t3 = t[2];
  int a0 = x->a[0];
  int a1 = x->a[1];
  t[2] = t1;
  t[0] = a1;
  x->a[1] = a0;
  x->a[0] = t3;
  x->fc = t2;
  x->sp = t;
}

main ()
{
  struct S s;
  static int sc[3] = {2, 3, 4};
  s.sc = sc;
  s.a[0] = 10;
  s.a[1] = 11;
  f (&s);
  if (s.sp[2] != 2)
    abort ();
  exit (0);
}
"
"/* { dg-do run } */
/* { dg-options ""-O2 -mavx512vl"" } */
/* { dg-require-effective-target avx512vl } */

#define AVX512VL
#define AVX512F_LEN 256
#define AVX512F_LEN_HALF 128
#include ""avx512f-vfnmaddXXXpd-2.c""

#undef AVX512F_LEN
#undef AVX512F_LEN_HALF

#define AVX512F_LEN 128
#define AVX512F_LEN_HALF 128
#include ""avx512f-vfnmaddXXXpd-2.c""
","/* { dg-do run } */
/* { dg-options ""-O2 -mavx512vl"" } */
/* { dg-require-effective-target avx512vl } */

#define AVX512VL
#define AVX512F_LEN 256
#define AVX512F_LEN_HALF 128
#include ""avx512f-vfnmaddXXXpd-2.c""

#undef AVX512F_LEN
#undef AVX512F_LEN_HALF

#define AVX512F_LEN 128
#define AVX512F_LEN_HALF 128
#include ""avx512f-vfnmaddXXXpd-2.c""
"
"typedef union
{
  double value;
  struct
  {
    unsigned long msw;
    unsigned long lsw;
  } parts;
} ieee_double_shape_type;

double f (int iy)
{
  double z, t;
  ieee_double_shape_type u, v;

  if (iy == 1)
    return 0;

  u.parts.msw = iy;
  u.parts.lsw = 0;
  z = u.value;
  v.parts.msw = iy;
  v.parts.lsw = 0;
  t = v.value;
  return 1.0+z+t+t;
}
","typedef union
{
  double value;
  struct
  {
    unsigned long msw;
    unsigned long lsw;
  } parts;
} ieee_double_shape_type;

double f (int iy)
{
  double z, t;
  ieee_double_shape_type u, v;

  if (iy == 1)
    return 0;

  u.parts.msw = iy;
  u.parts.lsw = 0;
  z = u.value;
  v.parts.msw = iy;
  v.parts.lsw = 0;
  t = v.value;
  return 1.0+z+t+t;
}
"
"/* { dg-do compile } */
/* { dg-options ""-Wall"" } */
/* Distilled from glibc sources.  Tests preprocessor corner cases.
   Since it uses rest args, we must turn off -pedantic-errors.  */

#define NO_PAREN(rest...) rest
#define DEFINE_CATEGORY(category, items) \
const int _nl_value_type_##category[] = { NO_PAREN items }

DEFINE_CATEGORY
(
 LC_COLLATE,
 (
   1,
   2,
   3,
  ));

DEFINE_CATEGORY(LC_CTYPE, (1, 2, 3));
","/* { dg-do compile } */
/* { dg-options ""-Wall"" } */
/* Distilled from glibc sources.  Tests preprocessor corner cases.
   Since it uses rest args, we must turn off -pedantic-errors.  */

#define NO_PAREN(rest...) rest
#define DEFINE_CATEGORY(category, items) \
const int _nl_value_type_##category[] = { NO_PAREN items }

DEFINE_CATEGORY
(
 LC_COLLATE,
 (
   1,
   2,
   3,
  ));

DEFINE_CATEGORY(LC_CTYPE, (1, 2, 3));
"
"long long a[10];
long long b, c, d, k, m, n, o, p, q, r, s, t, u, v, w;
int e, f, g, h, i, j, l, x;

int fn1 () {
  for (; x; x++)
    if (x & 1)
      s = h | g;
    else
      s = f | e;
  l = ~0;
  m = 1 | k;
  n = i;
  o = j;
  p = f | e;
  q = h | g;
  w = d | c | a[1];
  t = c;
  v = b | c;
  u = v;
  r = b | a[4];
  return e;
}
","long long a[10];
long long b, c, d, k, m, n, o, p, q, r, s, t, u, v, w;
int e, f, g, h, i, j, l, x;

int fn1 () {
  for (; x; x++)
    if (x & 1)
      s = h | g;
    else
      s = f | e;
  l = ~0;
  m = 1 | k;
  n = i;
  o = j;
  p = f | e;
  q = h | g;
  w = d | c | a[1];
  t = c;
  v = b | c;
  u = v;
  r = b | a[4];
  return e;
}
"
"/* { dg-do run { target init_priority } } */

extern void abort ();

int i;
int j;

void c1() __attribute__((constructor (500)));
void c2() __attribute__((constructor (700)));
void c3() __attribute__((constructor (600)));

void c1() {
  if (i++ != 0)
    abort ();
}

void c2() {
  if (i++ != 2)
    abort ();
}

void c3() {
  if (i++ != 1)
    abort ();
}

void d1() __attribute__((destructor (500)));
void d2() __attribute__((destructor (700)));
void d3() __attribute__((destructor (600)));

void d1() {
  if (--i != 0)
    abort ();
}

void d2() {
  if (--i != 2)
    abort ();
}

void d3() {
  if (j != 2)
    abort ();
  if (--i != 1)
    abort ();
}

void cd4() __attribute__((constructor (800), destructor (800)));

void cd4() {
  if (i != 3)
    abort ();
  ++j;
}

int main () {
  if (i != 3)
    return 1;
  if (j != 1)
    abort ();
  return 0;
}
","/* { dg-do run { target init_priority } } */

extern void abort ();

int i;
int j;

void c1() __attribute__((constructor (500)));
void c2() __attribute__((constructor (700)));
void c3() __attribute__((constructor (600)));

void c1() {
  if (i++ != 0)
    abort ();
}

void c2() {
  if (i++ != 2)
    abort ();
}

void c3() {
  if (i++ != 1)
    abort ();
}

void d1() __attribute__((destructor (500)));
void d2() __attribute__((destructor (700)));
void d3() __attribute__((destructor (600)));

void d1() {
  if (--i != 0)
    abort ();
}

void d2() {
  if (--i != 2)
    abort ();
}

void d3() {
  if (j != 2)
    abort ();
  if (--i != 1)
    abort ();
}

void cd4() __attribute__((constructor (800), destructor (800)));

void cd4() {
  if (i != 3)
    abort ();
  ++j;
}

int main () {
  if (i != 3)
    return 1;
  if (j != 1)
    abort ();
  return 0;
}
"
"/* { dg-do compile } */
/* { dg-options ""-Os -fno-math-errno -fno-trapping-math -msse2 -mno-sse4 -mfpmath=sse"" } */

float
f1 (float f)
{
  return __builtin_rintf (f);
}

double
f2 (double f)
{
  return __builtin_rint (f);
}

/* { dg-final { scan-assembler-not ""\tucomiss\t"" } } */
/* { dg-final { scan-assembler-not ""\tucomisd\t"" } } */
","/* { dg-do compile } */
/* { dg-options ""-Os -fno-math-errno -fno-trapping-math -msse2 -mno-sse4 -mfpmath=sse"" } */

float
f1 (float f)
{
  return __builtin_rintf (f);
}

double
f2 (double f)
{
  return __builtin_rint (f);
}

/* { dg-final { scan-assembler-not ""\tucomiss\t"" } } */
/* { dg-final { scan-assembler-not ""\tucomisd\t"" } } */
"
"/* { dg-do compile } */
/* { dg-options ""-Wno-overflow"" } */

typedef __SIZE_TYPE__ size_t;

extern char a[((size_t)-1 >> 1) + 1]; /* { dg-error ""too large"" } */
extern char b[((size_t)-1 >> 1)];
extern int c[(((size_t)-1 >> 1) + 1) / sizeof(int)]; /* { dg-error ""too large"" } */
extern int d[((size_t)-1 >> 1) / sizeof(int)];
","/* { dg-do compile } */
/* { dg-options ""-Wno-overflow"" } */

typedef __SIZE_TYPE__ size_t;

extern char a[((size_t)-1 >> 1) + 1]; /* { dg-error ""too large"" } */
extern char b[((size_t)-1 >> 1)];
extern int c[(((size_t)-1 >> 1) + 1) / sizeof(int)]; /* { dg-error ""too large"" } */
extern int d[((size_t)-1 >> 1) / sizeof(int)];
"
"/* { dg-do compile { target size32plus } } */
/* { dg-options ""-O2 -ftree-loop-distribution -ftree-loop-distribute-patterns -fdump-tree-ldist-details"" } */

#define M (256)
#define N (512)
int a[M][N], b[M][N];

void
foo (void)
{
  for (unsigned i = 0; i < M; ++i)
    for (unsigned j = N; j > 0; --j)
      a[i][j - 1] = b[i][j - 1];
}

/* { dg-final { scan-tree-dump-times ""Loop nest . distributed: split to"" 1 ""ldist"" } } */
","/* { dg-do compile { target size32plus } } */
/* { dg-options ""-O2 -ftree-loop-distribution -ftree-loop-distribute-patterns -fdump-tree-ldist-details"" } */

#define M (256)
#define N (512)
int a[M][N], b[M][N];

void
foo (void)
{
  for (unsigned i = 0; i < M; ++i)
    for (unsigned j = N; j > 0; --j)
      a[i][j - 1] = b[i][j - 1];
}

/* { dg-final { scan-tree-dump-times ""Loop nest . distributed: split to"" 1 ""ldist"" } } */
"
"/* PR rtl-optimization/69592 */
/* { dg-do compile } */
/* { dg-options ""-O2"" } */

unsigned int
foo (unsigned int a, unsigned int *b, unsigned int c)
{
  unsigned int d;
#define A(n) d = a + b[n]; if (d < a) c++; a = d;
#define B(n) A(n##0) A(n##1) A(n##2) A(n##3) A(n##4) A(n##5) A(n##6) A(n##7) A(n##8) A(n##9)
#define C(n) B(n##0) B(n##1) B(n##2) B(n##3) B(n##4) B(n##5) B(n##6) B(n##7) B(n##8) B(n##9)
#define D(n) C(n##0) C(n##1) C(n##2) C(n##3) C(n##4) C(n##5) C(n##6) C(n##7) C(n##8) C(n##9)
#define E(n) D(n##0) D(n##1) D(n##2) D(n##3) D(n##4) D(n##5) D(n##6) D(n##7) D(n##8) D(n##9)
  C(1) C(2) C(3) C(4) C(5) C(6)
  return d + c;
}
","/* PR rtl-optimization/69592 */
/* { dg-do compile } */
/* { dg-options ""-O2"" } */

unsigned int
foo (unsigned int a, unsigned int *b, unsigned int c)
{
  unsigned int d;
#define A(n) d = a + b[n]; if (d < a) c++; a = d;
#define B(n) A(n##0) A(n##1) A(n##2) A(n##3) A(n##4) A(n##5) A(n##6) A(n##7) A(n##8) A(n##9)
#define C(n) B(n##0) B(n##1) B(n##2) B(n##3) B(n##4) B(n##5) B(n##6) B(n##7) B(n##8) B(n##9)
#define D(n) C(n##0) C(n##1) C(n##2) C(n##3) C(n##4) C(n##5) C(n##6) C(n##7) C(n##8) C(n##9)
#define E(n) D(n##0) D(n##1) D(n##2) D(n##3) D(n##4) D(n##5) D(n##6) D(n##7) D(n##8) D(n##9)
  C(1) C(2) C(3) C(4) C(5) C(6)
  return d + c;
}
"
"/* PR c++/62199 */
/* { dg-do compile } */
/* { dg-options ""-Wlogical-not-parentheses"" } */

#ifndef __cplusplus
# define bool _Bool
#endif

bool r;

void
foo (bool b)
{
  r = !b == 1; /* { dg-bogus ""logical not is only applied to the left hand side of comparison"" } */
  r = !b != 1; /* { dg-bogus ""logical not is only applied to the left hand side of comparison"" } */
  r = !b > 1; /* { dg-bogus ""logical not is only applied to the left hand side of comparison"" } */
  r = !b >= 1; /* { dg-bogus ""logical not is only applied to the left hand side of comparison"" } */
  r = !b < 1; /* { dg-bogus ""logical not is only applied to the left hand side of comparison"" } */
  r = !b <= 1; /* { dg-bogus ""logical not is only applied to the left hand side of comparison"" } */
}
","/* PR c++/62199 */
/* { dg-do compile } */
/* { dg-options ""-Wlogical-not-parentheses"" } */

#ifndef __cplusplus
# define bool _Bool
#endif

bool r;

void
foo (bool b)
{
  r = !b == 1; /* { dg-bogus ""logical not is only applied to the left hand side of comparison"" } */
  r = !b != 1; /* { dg-bogus ""logical not is only applied to the left hand side of comparison"" } */
  r = !b > 1; /* { dg-bogus ""logical not is only applied to the left hand side of comparison"" } */
  r = !b >= 1; /* { dg-bogus ""logical not is only applied to the left hand side of comparison"" } */
  r = !b < 1; /* { dg-bogus ""logical not is only applied to the left hand side of comparison"" } */
  r = !b <= 1; /* { dg-bogus ""logical not is only applied to the left hand side of comparison"" } */
}
"
"/* { dg-do compile } */
/* { dg-options ""-O2 -fdump-rtl-expand"" } */


int g(int*);

int f(void)
{
  int tt = 0;
  int t = 4;
  {
    int a[t];
    tt = g(a);
    tt += a[0];
  }
  {
    int a[4];
    tt += g(a);
    tt += a[0];
  }
  return tt;
}

/* { dg-final { scan-rtl-dump-times ""Partition"" 1 ""expand""} } */
","/* { dg-do compile } */
/* { dg-options ""-O2 -fdump-rtl-expand"" } */


int g(int*);

int f(void)
{
  int tt = 0;
  int t = 4;
  {
    int a[t];
    tt = g(a);
    tt += a[0];
  }
  {
    int a[4];
    tt += g(a);
    tt += a[0];
  }
  return tt;
}

/* { dg-final { scan-rtl-dump-times ""Partition"" 1 ""expand""} } */
"
"/* { dg-do compile { target { powerpc*-*-* } } } */
/* { dg-skip-if ""do not override -mcpu"" { powerpc*-*-* } { ""-mcpu=*"" } { ""-mcpu=power9"" } } */
/* { dg-require-effective-target powerpc_p9vector_ok } */
/* { dg-options ""-mcpu=power9"" } */

#include <altivec.h>

int
test_any_equal_or_zero (vector unsigned short *arg1_p,
			vector unsigned short *arg2_p)
{
  vector unsigned short arg_1 = *arg1_p;
  vector unsigned short arg_2 = *arg2_p;

  return vec_any_eqz (arg_1, arg_2);
}

/* { dg-final { scan-assembler ""vcmpnezh."" } } */
","/* { dg-do compile { target { powerpc*-*-* } } } */
/* { dg-skip-if ""do not override -mcpu"" { powerpc*-*-* } { ""-mcpu=*"" } { ""-mcpu=power9"" } } */
/* { dg-require-effective-target powerpc_p9vector_ok } */
/* { dg-options ""-mcpu=power9"" } */

#include <altivec.h>

int
test_any_equal_or_zero (vector unsigned short *arg1_p,
			vector unsigned short *arg2_p)
{
  vector unsigned short arg_1 = *arg1_p;
  vector unsigned short arg_2 = *arg2_p;

  return vec_any_eqz (arg_1, arg_2);
}

/* { dg-final { scan-assembler ""vcmpnezh."" } } */
"
"/* PR c/57821 */
/* { dg-do compile } */
/* { dg-options ""-O2"" } */
static char * name[] = {
    [0x8000000000000000]  = ""bar""
  }; /* { dg-error ""too large"" } */
","/* PR c/57821 */
/* { dg-do compile } */
/* { dg-options ""-O2"" } */
static char * name[] = {
    [0x8000000000000000]  = ""bar""
  }; /* { dg-error ""too large"" } */
"
"/* PR target/68872 */
/* { dg-do assemble { target { powerpc64le-*-* } } } */
/* { dg-options ""-mcpu=powerpc64le"" } */

/* Verify that -mcpu=powerpc64le passes -mpower8 to the assembler.  */

long
bar (unsigned char *ptr, unsigned char val)
{
  long ret;
  asm volatile (""stbcx. %0,0,%1"" :: ""r"" (val), ""r"" (ptr));
  asm volatile (""mfcr %0,8"" : ""=r"" (ret) ::);
  return ret;
}
","/* PR target/68872 */
/* { dg-do assemble { target { powerpc64le-*-* } } } */
/* { dg-options ""-mcpu=powerpc64le"" } */

/* Verify that -mcpu=powerpc64le passes -mpower8 to the assembler.  */

long
bar (unsigned char *ptr, unsigned char val)
{
  long ret;
  asm volatile (""stbcx. %0,0,%1"" :: ""r"" (val), ""r"" (ptr));
  asm volatile (""mfcr %0,8"" : ""=r"" (ret) ::);
  return ret;
}
"
"/* { dg-do compile { target { powerpc*-*-* } } } */
/* { dg-skip-if ""do not override -mcpu"" { powerpc*-*-* } { ""-mcpu=*"" } { ""-mcpu=power8"" } } */
/* { dg-require-effective-target powerpc_p8vector_ok } */
/* { dg-options ""-mcpu=power8"" } */

int
main ()
{
  __attribute__((altivec(vector__))) unsigned long long test, res;
  const int s0 = 0;
  int mask;

  /* Argument 2 must be 0 or 1.  Argument 3 must be in range 0..15.  */
  res = __builtin_crypto_vshasigmad (test, 1, 0xff); /* { dg-error ""argument 3 must be in the range 0..15"" } */
  return 0;
}
","/* { dg-do compile { target { powerpc*-*-* } } } */
/* { dg-skip-if ""do not override -mcpu"" { powerpc*-*-* } { ""-mcpu=*"" } { ""-mcpu=power8"" } } */
/* { dg-require-effective-target powerpc_p8vector_ok } */
/* { dg-options ""-mcpu=power8"" } */

int
main ()
{
  __attribute__((altivec(vector__))) unsigned long long test, res;
  const int s0 = 0;
  int mask;

  /* Argument 2 must be 0 or 1.  Argument 3 must be in range 0..15.  */
  res = __builtin_crypto_vshasigmad (test, 1, 0xff); /* { dg-error ""argument 3 must be in the range 0..15"" } */
  return 0;
}
"
"/* { dg-do compile } */
/* { dg-options ""-O2 -fcf-protection"" } */
/* { dg-final { scan-assembler-times {\mendbr} 2 } } */

extern int x;

static void
__attribute__ ((noinline, noclone))
test (int i)
{
  x = i;
}

extern __typeof (test) foo __attribute__ ((alias (""test"")));

void
bar (int i)
{
  test (i);
}
","/* { dg-do compile } */
/* { dg-options ""-O2 -fcf-protection"" } */
/* { dg-final { scan-assembler-times {\mendbr} 2 } } */

extern int x;

static void
__attribute__ ((noinline, noclone))
test (int i)
{
  x = i;
}

extern __typeof (test) foo __attribute__ ((alias (""test"")));

void
bar (int i)
{
  test (i);
}
"
"/* { dg-do compile { target { powerpc*-*-* && lp64 } } } */
/* { dg-require-effective-target powerpc_p9vector_ok } */
/* { dg-options ""-mpower9-vector -O2"" } */

extern _Float128 floorf128 (_Float128);
extern _Float128 ceilf128 (_Float128);
extern _Float128 roundf128 (_Float128);
extern _Float128 truncf128 (_Float128);

/* Check rounding optimizations that are done for double are also done for
   _Float128.  */

_Float128
floor_floor_x (_Float128 x)
{
  return floorf128 (floorf128 (x));
}

_Float128
ceil_ceil_x (_Float128 x)
{
  return ceilf128 (ceilf128 (x));
}

_Float128
trunc_trunc_x (_Float128 x)
{
  return truncf128 (truncf128 (x));
}

_Float128
round_round_x (_Float128 x)
{
  return roundf128 (roundf128 (x));
}

/* { dg-final { scan-assembler-times {\mxsrqpi\M} 4 } } */
/* { dg-final { scan-assembler-not   {\mbl\M}       } } */
","/* { dg-do compile { target { powerpc*-*-* && lp64 } } } */
/* { dg-require-effective-target powerpc_p9vector_ok } */
/* { dg-options ""-mpower9-vector -O2"" } */

extern _Float128 floorf128 (_Float128);
extern _Float128 ceilf128 (_Float128);
extern _Float128 roundf128 (_Float128);
extern _Float128 truncf128 (_Float128);

/* Check rounding optimizations that are done for double are also done for
   _Float128.  */

_Float128
floor_floor_x (_Float128 x)
{
  return floorf128 (floorf128 (x));
}

_Float128
ceil_ceil_x (_Float128 x)
{
  return ceilf128 (ceilf128 (x));
}

_Float128
trunc_trunc_x (_Float128 x)
{
  return truncf128 (truncf128 (x));
}

_Float128
round_round_x (_Float128 x)
{
  return roundf128 (roundf128 (x));
}

/* { dg-final { scan-assembler-times {\mxsrqpi\M} 4 } } */
/* { dg-final { scan-assembler-not   {\mbl\M}       } } */
"
"/* { dg-options ""-O -Wno-psabi"" } */

#ifdef __x86_64__
#include <stdlib.h>
#include ""struct-complex-2.h""

void
bar(struct st x)
{
  if (x.s1 != 1
      || __real__ x.x != 2 || __imag__ x.x != 4)
    abort ();
}

void
foo(struct stc x)
{
  if (x.s1 != 1 || x.x.r != 2 || x.x.i != 4)
    abort ();
}
#else
int dummy_y;
#endif
","/* { dg-options ""-O -Wno-psabi"" } */

#ifdef __x86_64__
#include <stdlib.h>
#include ""struct-complex-2.h""

void
bar(struct st x)
{
  if (x.s1 != 1
      || __real__ x.x != 2 || __imag__ x.x != 4)
    abort ();
}

void
foo(struct stc x)
{
  if (x.s1 != 1 || x.x.r != 2 || x.x.i != 4)
    abort ();
}
#else
int dummy_y;
#endif
"
"/* PR middle-end/31490 */
/* { dg-do compile } */
/* { dg-options ""-O2"" } */
/* { dg-options ""-O2 -fpic"" { target fpic } } */
/* { dg-require-named-sections """" } */

const char *const x __attribute__((section(""foo""))) = """";
const char *const g __attribute__((section(""foo""))) = (const char *) 0;
const char *const y __attribute__((section(""bar""))) = (const char *) 0;
const char *const h __attribute__((section(""bar""))) = ""bar"";
","/* PR middle-end/31490 */
/* { dg-do compile } */
/* { dg-options ""-O2"" } */
/* { dg-options ""-O2 -fpic"" { target fpic } } */
/* { dg-require-named-sections """" } */

const char *const x __attribute__((section(""foo""))) = """";
const char *const g __attribute__((section(""foo""))) = (const char *) 0;
const char *const y __attribute__((section(""bar""))) = (const char *) 0;
const char *const h __attribute__((section(""bar""))) = ""bar"";
"
"/* { dg-do compile } */
/* { dg-options ""-O -msse"" } */

#include <xmmintrin.h>

unsigned save;

void f(unsigned mode){
  unsigned tmp = _MM_GET_ROUNDING_MODE();
  _MM_SET_ROUNDING_MODE(mode);
  save = tmp;
}

/* { dg-final { scan-assembler-times ""stmxcsr"" 1 } } */
","/* { dg-do compile } */
/* { dg-options ""-O -msse"" } */

#include <xmmintrin.h>

unsigned save;

void f(unsigned mode){
  unsigned tmp = _MM_GET_ROUNDING_MODE();
  _MM_SET_ROUNDING_MODE(mode);
  save = tmp;
}

/* { dg-final { scan-assembler-times ""stmxcsr"" 1 } } */
"
"/* PR rtl-optimization/68321 */

int e = 1, u = 5, t2, t5, i, k;
int a[1], b, m;
char n, t;

int
fn1 (int p1)
{
  int g[1];
  for (;;)
    {
      if (p1 / 3)
	for (; t5;)
	  u || n;
      t2 = p1 & 4;
      if (b + 1)
	return 0;
      u = g[0];
    }
}

int
main ()
{
  for (; e >= 0; e--)
    {
      char c;
      if (!m)
	c = t;
      fn1 (c);
    }
  
  if (a[t2] != 0) 
    __builtin_abort (); 

  return 0;
}
","/* PR rtl-optimization/68321 */

int e = 1, u = 5, t2, t5, i, k;
int a[1], b, m;
char n, t;

int
fn1 (int p1)
{
  int g[1];
  for (;;)
    {
      if (p1 / 3)
	for (; t5;)
	  u || n;
      t2 = p1 & 4;
      if (b + 1)
	return 0;
      u = g[0];
    }
}

int
main ()
{
  for (; e >= 0; e--)
    {
      char c;
      if (!m)
	c = t;
      fn1 (c);
    }
  
  if (a[t2] != 0) 
    __builtin_abort (); 

  return 0;
}
"
"/* { dg-do compile { target *-*-linux* } } */
/* { dg-options ""-O2 -fno-pic -fno-plt"" } */

extern int bar (void);

int
check (void *p)
{
  return p != &bar;
}

/* { dg-final { scan-assembler ""cmp\(l|q\)\[ \t\]*.*bar@GOTPCREL"" { target { ! ia32 } } } } */
/* { dg-final { scan-assembler ""movl\[ \t\]*bar@GOT,"" { target { ia32 && got32x_reloc } } } } */
/* { dg-final { scan-assembler-not ""mov\(l|q\)\[ \t\]*\\\$bar,"" { target { ! ia32 } } } } */
/* { dg-final { scan-assembler-not ""mov\(l|q\)\[ \t\]*\\\$bar,"" { target { ia32 && got32x_reloc } } } } */
","/* { dg-do compile { target *-*-linux* } } */
/* { dg-options ""-O2 -fno-pic -fno-plt"" } */

extern int bar (void);

int
check (void *p)
{
  return p != &bar;
}

/* { dg-final { scan-assembler ""cmp\(l|q\)\[ \t\]*.*bar@GOTPCREL"" { target { ! ia32 } } } } */
/* { dg-final { scan-assembler ""movl\[ \t\]*bar@GOT,"" { target { ia32 && got32x_reloc } } } } */
/* { dg-final { scan-assembler-not ""mov\(l|q\)\[ \t\]*\\\$bar,"" { target { ! ia32 } } } } */
/* { dg-final { scan-assembler-not ""mov\(l|q\)\[ \t\]*\\\$bar,"" { target { ia32 && got32x_reloc } } } } */
"
"/* { dg-do compile } */
/* { dg-options ""-O2 -ftree-vectorize"" } */

#define TYPE long
#define SIZE 257

void
f (TYPE *x, TYPE *y, long n __attribute__((unused)), long m)
{
  for (int i = 0; i < SIZE; ++i)
    x[i] += y[i * m];
}

/* { dg-final { scan-assembler {\tld1d\tz[0-9]+} } } */
/* { dg-final { scan-assembler {\tst1d\tz[0-9]+} } } */
/* { dg-final { scan-assembler {\tldr\tx[0-9]+} } } */
/* { dg-final { scan-assembler {\tstr\tx[0-9]+} } } */
/* Should multiply by (257-1)*8 rather than (VF-1)*8.  */
/* { dg-final { scan-assembler-times {\tadd\tx[0-9]+, x0, 2048} 1 } } */
/* { dg-final { scan-assembler-times {lsl\tx[0-9]+, x[0-9]+, 11} 1 } } */
/* { dg-final { scan-assembler {\tcmp\tx[0-9]+, 0} } } */
/* { dg-final { scan-assembler-not {\tcmp\tw[0-9]+, 0} } } */
/* { dg-final { scan-assembler-times {\tcsel\tx[0-9]+} 2 } } */
/* Two range checks only; doesn't matter whether n is zero.  */
/* { dg-final { scan-assembler {\tcmp\t} } } */
/* { dg-final { scan-assembler-times {\tccmp\t} 1 } } */
","/* { dg-do compile } */
/* { dg-options ""-O2 -ftree-vectorize"" } */

#define TYPE long
#define SIZE 257

void
f (TYPE *x, TYPE *y, long n __attribute__((unused)), long m)
{
  for (int i = 0; i < SIZE; ++i)
    x[i] += y[i * m];
}

/* { dg-final { scan-assembler {\tld1d\tz[0-9]+} } } */
/* { dg-final { scan-assembler {\tst1d\tz[0-9]+} } } */
/* { dg-final { scan-assembler {\tldr\tx[0-9]+} } } */
/* { dg-final { scan-assembler {\tstr\tx[0-9]+} } } */
/* Should multiply by (257-1)*8 rather than (VF-1)*8.  */
/* { dg-final { scan-assembler-times {\tadd\tx[0-9]+, x0, 2048} 1 } } */
/* { dg-final { scan-assembler-times {lsl\tx[0-9]+, x[0-9]+, 11} 1 } } */
/* { dg-final { scan-assembler {\tcmp\tx[0-9]+, 0} } } */
/* { dg-final { scan-assembler-not {\tcmp\tw[0-9]+, 0} } } */
/* { dg-final { scan-assembler-times {\tcsel\tx[0-9]+} 2 } } */
/* Two range checks only; doesn't matter whether n is zero.  */
/* { dg-final { scan-assembler {\tcmp\t} } } */
/* { dg-final { scan-assembler-times {\tccmp\t} 1 } } */
"
"/* { dg-do compile } */
/* { dg-options ""-Wstrict-overflow -O2"" } */
extern int foo (int);

int
wait_reading_process_output (void)
{
  int nfds = 0;
  int channel;

  for (channel = 0; channel < 1024; ++channel)
    {
      if (foo (channel))
	nfds++;
    }

  if (nfds < 0) /* { dg-bogus ""assuming signed overflow does not occur"" """" } */
    return 1;
  return 0;
}
","/* { dg-do compile } */
/* { dg-options ""-Wstrict-overflow -O2"" } */
extern int foo (int);

int
wait_reading_process_output (void)
{
  int nfds = 0;
  int channel;

  for (channel = 0; channel < 1024; ++channel)
    {
      if (foo (channel))
	nfds++;
    }

  if (nfds < 0) /* { dg-bogus ""assuming signed overflow does not occur"" """" } */
    return 1;
  return 0;
}
"
"/* { dg-do compile } */
/* { dg-require-effective-target int32plus } */
/* { dg-skip-if ""No Inf support"" { spu-*-* } } */
/* { dg-options ""-O -ftrapping-math"" } */

/* There should be exactly 2 +Inf in the assembly file.  */

float f1 =  __FLT_MAX__ + __FLT_MAX__;

float foo1(void)
{
  return  __FLT_MAX__ + __FLT_MAX__;
}

float f2 = 1.0f/0.0f;

float foo2(void)
{
  return 1.0f/0.0f;
}

/* { dg-final { scan-assembler-times ""2139095040"" 2 { target { ! mmix-*-* } } } } */
/* { dg-final { scan-assembler-times ""#7f800000"" 2 { target mmix-*-* } } } */
","/* { dg-do compile } */
/* { dg-require-effective-target int32plus } */
/* { dg-skip-if ""No Inf support"" { spu-*-* } } */
/* { dg-options ""-O -ftrapping-math"" } */

/* There should be exactly 2 +Inf in the assembly file.  */

float f1 =  __FLT_MAX__ + __FLT_MAX__;

float foo1(void)
{
  return  __FLT_MAX__ + __FLT_MAX__;
}

float f2 = 1.0f/0.0f;

float foo2(void)
{
  return 1.0f/0.0f;
}

/* { dg-final { scan-assembler-times ""2139095040"" 2 { target { ! mmix-*-* } } } } */
/* { dg-final { scan-assembler-times ""#7f800000"" 2 { target mmix-*-* } } } */
"
"/* { dg-do run } */
/* { dg-require-effective-target avx } */
/* { dg-options ""-O2 -mavx"" } */

#include ""avx-check.h""

__attribute__((noinline, noclone)) double
foo (__m256d x)
{
  return _mm256_cvtsd_f64 (x);
}

static void
avx_test (void)
{
  if (_mm256_cvtsd_f64 (_mm256_set_pd (13.5, 24.5, 23.0, 22.5)) != 22.5)
    __builtin_abort ();

  if (foo (_mm256_set_pd (24.25, 23.75, 22.0, 12.25)) != 12.25)
    __builtin_abort ();
}
","/* { dg-do run } */
/* { dg-require-effective-target avx } */
/* { dg-options ""-O2 -mavx"" } */

#include ""avx-check.h""

__attribute__((noinline, noclone)) double
foo (__m256d x)
{
  return _mm256_cvtsd_f64 (x);
}

static void
avx_test (void)
{
  if (_mm256_cvtsd_f64 (_mm256_set_pd (13.5, 24.5, 23.0, 22.5)) != 22.5)
    __builtin_abort ();

  if (foo (_mm256_set_pd (24.25, 23.75, 22.0, 12.25)) != 12.25)
    __builtin_abort ();
}
"
"/* Test for static assertions not in C90.  */
/* { dg-do compile } */
/* { dg-options ""-std=iso9899:1990 -pedantic-errors"" } */

_Static_assert (1, """"); /* { dg-error ""ISO C90 does not support '_Static_assert'"" } */
","/* Test for static assertions not in C90.  */
/* { dg-do compile } */
/* { dg-options ""-std=iso9899:1990 -pedantic-errors"" } */

_Static_assert (1, """"); /* { dg-error ""ISO C90 does not support '_Static_assert'"" } */
"
"void
foo (long double x)
{
  struct {long double t;} y = {x};
}

","void
foo (long double x)
{
  struct {long double t;} y = {x};
}

"
"/* { dg-do run } */
/* { dg-options ""-O2 -mavx512bw -mavx512vl"" } */
/* { dg-require-effective-target avx512vl } */
/* { dg-require-effective-target avx512bw } */

#define AVX512VL
#define AVX512F_LEN 256
#define AVX512F_LEN_HALF 128
#include ""avx512bw-vpsubusw-2.c""

#undef AVX512F_LEN
#undef AVX512F_LEN_HALF

#define AVX512F_LEN 128
#define AVX512F_LEN_HALF 128
#include ""avx512bw-vpsubusw-2.c""
","/* { dg-do run } */
/* { dg-options ""-O2 -mavx512bw -mavx512vl"" } */
/* { dg-require-effective-target avx512vl } */
/* { dg-require-effective-target avx512bw } */

#define AVX512VL
#define AVX512F_LEN 256
#define AVX512F_LEN_HALF 128
#include ""avx512bw-vpsubusw-2.c""

#undef AVX512F_LEN
#undef AVX512F_LEN_HALF

#define AVX512F_LEN 128
#define AVX512F_LEN_HALF 128
#include ""avx512bw-vpsubusw-2.c""
"
"/* { dg-require-stack-check ""generic"" } */
/* { dg-options ""-O -fstack-check=generic -ftree-pre -fgraphite-identity"" } */
/* nvptx doesn't expose a stack.  */
/* { dg-skip-if """" { nvptx-*-* } } */

int main ()
{
  int i, j;
  int x[8][8];
  for (i = 0; i < 8; i++)
    for (j = i; j < 8; j++)
      x[i][j] = 4;

  for (i = 0; i < 8; i++)
    for (j = i; j < 8; j++)
      if (x[i][j] != 4)
	__builtin_abort ();

  return 0;
}
","/* { dg-require-stack-check ""generic"" } */
/* { dg-options ""-O -fstack-check=generic -ftree-pre -fgraphite-identity"" } */
/* nvptx doesn't expose a stack.  */
/* { dg-skip-if """" { nvptx-*-* } } */

int main ()
{
  int i, j;
  int x[8][8];
  for (i = 0; i < 8; i++)
    for (j = i; j < 8; j++)
      x[i][j] = 4;

  for (i = 0; i < 8; i++)
    for (j = i; j < 8; j++)
      if (x[i][j] != 4)
	__builtin_abort ();

  return 0;
}
"
"/* { dg-do compile } */
/* { dg-options ""-O -ftree-parallelize-loops=4"" } */

int d[1024];

static inline int foo (void)
{
  int s = 0;
  int i = 0;
  for (; i < 1024; i++)
    s += d[i];
  return s;
}

void bar (void)
{
  if (foo ())
    __builtin_abort ();
}
","/* { dg-do compile } */
/* { dg-options ""-O -ftree-parallelize-loops=4"" } */

int d[1024];

static inline int foo (void)
{
  int s = 0;
  int i = 0;
  for (; i < 1024; i++)
    s += d[i];
  return s;
}

void bar (void)
{
  if (foo ())
    __builtin_abort ();
}
"
"typedef struct foo foo_t;
foo_t x;
struct foo {
  int i;
};

foo_t x = { 10 };
","typedef struct foo foo_t;
foo_t x;
struct foo {
  int i;
};

foo_t x = { 10 };
"
"/* { dg-do assemble } */
/* { dg-options ""-std=c99"" } */
#include <arm_neon.h>

int
main (int argc, char **argv)
{
  uint64x1_t base_b = vcreate_u64 (0x5555666677778888ULL);
  int16_t int16_a = 0x1234;
  int16x4_t int16x4_b = vreinterpret_s16_u64 (base_b);

  /* { dg-error ""lane -1 out of range 0 - 3"" """" {target *-*-*} 0 } */
  vqdmullh_lane_s16 (int16_a, int16x4_b, -1);
  /* { dg-error ""lane 4 out of range 0 - 3"" """" {target *-*-*} 0 } */
  vqdmullh_lane_s16 (int16_a, int16x4_b, 4);
}
","/* { dg-do assemble } */
/* { dg-options ""-std=c99"" } */
#include <arm_neon.h>

int
main (int argc, char **argv)
{
  uint64x1_t base_b = vcreate_u64 (0x5555666677778888ULL);
  int16_t int16_a = 0x1234;
  int16x4_t int16x4_b = vreinterpret_s16_u64 (base_b);

  /* { dg-error ""lane -1 out of range 0 - 3"" """" {target *-*-*} 0 } */
  vqdmullh_lane_s16 (int16_a, int16x4_b, -1);
  /* { dg-error ""lane 4 out of range 0 - 3"" """" {target *-*-*} 0 } */
  vqdmullh_lane_s16 (int16_a, int16x4_b, 4);
}
"
"/* Copyright (C) 2004 Free Software Foundation.

   Check that log10, log10f, log10l, log2, log2f and log2l
   built-in functions compile.

   Written by Uros Bizjak, 11th February 2004.  */

/* { dg-do compile } */
/* { dg-options ""-O2 -ffast-math"" } */

extern double log10(double);
extern double log2(double);
extern double log1p(double);
extern float log10f(float);
extern float log2f(float);
extern float log1pf(float);
extern long double log10l(long double);
extern long double log2l(long double);
extern long double log1pl(long double);


double test1(double x)
{
  return log10(x);
}

double test2(double x)
{
  return log2(x);
}

double test3(double x)
{
  return log1p(x);
}

float test1f(float x)
{
  return log10f(x);
}

float test2f(float x)
{
  return log2f(x);
}

float test3f(float x)
{
  return log1pf(x);
}

long double test1l(long double x)
{
  return log10l(x);
}

long double test2l(long double x)
{
  return log2l(x);
}

long double test3l(long double x)
{
  return log1pl(x);
}
","/* Copyright (C) 2004 Free Software Foundation.

   Check that log10, log10f, log10l, log2, log2f and log2l
   built-in functions compile.

   Written by Uros Bizjak, 11th February 2004.  */

/* { dg-do compile } */
/* { dg-options ""-O2 -ffast-math"" } */

extern double log10(double);
extern double log2(double);
extern double log1p(double);
extern float log10f(float);
extern float log2f(float);
extern float log1pf(float);
extern long double log10l(long double);
extern long double log2l(long double);
extern long double log1pl(long double);


double test1(double x)
{
  return log10(x);
}

double test2(double x)
{
  return log2(x);
}

double test3(double x)
{
  return log1p(x);
}

float test1f(float x)
{
  return log10f(x);
}

float test2f(float x)
{
  return log2f(x);
}

float test3f(float x)
{
  return log1pf(x);
}

long double test1l(long double x)
{
  return log10l(x);
}

long double test2l(long double x)
{
  return log2l(x);
}

long double test3l(long double x)
{
  return log1pl(x);
}
"
"/* { dg-do compile } */
/* { dg-options ""-mavx2 -O3"" } */
/* { dg-final { scan-assembler ""vpsrlq\[ \\t\]+\[^\n\]*\\$\[0-9\]"" } } */

#include <immintrin.h>

volatile __m256i x;

void extern
avx2_test (void)
{
  x = _mm256_srli_epi64 (x, 13);
}
","/* { dg-do compile } */
/* { dg-options ""-mavx2 -O3"" } */
/* { dg-final { scan-assembler ""vpsrlq\[ \\t\]+\[^\n\]*\\$\[0-9\]"" } } */

#include <immintrin.h>

volatile __m256i x;

void extern
avx2_test (void)
{
  x = _mm256_srli_epi64 (x, 13);
}
"
"int main ()
{
    int nResult;
    int b=0;
    int i = -1;

    do
    {
     if (b!=0) {
       abort ();
       nResult=1;
     } else {
      nResult=0;
     }
     i++;
     b=(i+2)*4;
    } while (i < 0);
    exit (0);
}


","int main ()
{
    int nResult;
    int b=0;
    int i = -1;

    do
    {
     if (b!=0) {
       abort ();
       nResult=1;
     } else {
      nResult=0;
     }
     i++;
     b=(i+2)*4;
    } while (i < 0);
    exit (0);
}


"
"/* { dg-do compile { target *-*-darwin* } } */
/* { dg-options ""-F$srcdir/gcc.dg"" } */

#include <Foundation/Foundation.h>
/* { dg-message ""terminated"" """" { target *-*-* } 0 } */
/* { dg-message ""Foundation/Foundation.h"" """" { target *-*-* } 0 } */
","/* { dg-do compile { target *-*-darwin* } } */
/* { dg-options ""-F$srcdir/gcc.dg"" } */

#include <Foundation/Foundation.h>
/* { dg-message ""terminated"" """" { target *-*-* } 0 } */
/* { dg-message ""Foundation/Foundation.h"" """" { target *-*-* } 0 } */
"
"/* Test __builtin_{add,sub}_overflow_p on {,un}signed long long int.  */
/* { dg-do run } */
/* { dg-skip-if """" { ! run_expensive_tests }  { ""*"" } { ""-O0"" ""-O2"" } } */

typedef signed long long int S;
typedef unsigned long long int U;
#define COND 1
#define SHIFT ((__SIZEOF_LONG_LONG__ - 1) * __CHAR_BIT__)
#define S_MAX __LONG_LONG_MAX__
#define S_MIN (-__LONG_LONG_MAX__ - 1)
#if __SIZEOF_INT128__ > __SIZEOF_LONG_LONG__
typedef __int128 W;
#else
#undef COND
#define COND 0
#endif
#include ""builtin-arith-overflow-p-7.c""
","/* Test __builtin_{add,sub}_overflow_p on {,un}signed long long int.  */
/* { dg-do run } */
/* { dg-skip-if """" { ! run_expensive_tests }  { ""*"" } { ""-O0"" ""-O2"" } } */

typedef signed long long int S;
typedef unsigned long long int U;
#define COND 1
#define SHIFT ((__SIZEOF_LONG_LONG__ - 1) * __CHAR_BIT__)
#define S_MAX __LONG_LONG_MAX__
#define S_MIN (-__LONG_LONG_MAX__ - 1)
#if __SIZEOF_INT128__ > __SIZEOF_LONG_LONG__
typedef __int128 W;
#else
#undef COND
#define COND 0
#endif
#include ""builtin-arith-overflow-p-7.c""
"
"/* { dg-do run } */
/* { dg-options ""-std=c99 -O2"" } */
/* { dg-additional-options ""-msse"" { target { i?86-*-* x86_64-*-* } } } */
/* { dg-require-effective-target sse_runtime { target { i?86-*-* x86_64-*-* } } } */

extern void abort (void);

unsigned int  __attribute__((noinline))
test (int shift_size)
{
  unsigned long long res = ~0;

  return res << shift_size;
}

int
main ()
{
  int dst = 32;

  if (test (dst) != 0)
    abort ();

  return 0;
}
","/* { dg-do run } */
/* { dg-options ""-std=c99 -O2"" } */
/* { dg-additional-options ""-msse"" { target { i?86-*-* x86_64-*-* } } } */
/* { dg-require-effective-target sse_runtime { target { i?86-*-* x86_64-*-* } } } */

extern void abort (void);

unsigned int  __attribute__((noinline))
test (int shift_size)
{
  unsigned long long res = ~0;

  return res << shift_size;
}

int
main ()
{
  int dst = 32;

  if (test (dst) != 0)
    abort ();

  return 0;
}
"
"/* { dg-do compile } */
/* { dg-options ""-mcmse"" }  */
#include <arm_cmse.h>

char *
foo (char * p)
{
  if (!cmse_is_nsfptr (p))
    return cmse_nsfptr_create (p);
}

/* Checks for saving and clearing prior to function call.  */
/* { dg-final { scan-assembler-not ""cmse_is_nsfptr"" } } */
/* { dg-final { scan-assembler-not ""cmse_nsfptr_create"" } } */
","/* { dg-do compile } */
/* { dg-options ""-mcmse"" }  */
#include <arm_cmse.h>

char *
foo (char * p)
{
  if (!cmse_is_nsfptr (p))
    return cmse_nsfptr_create (p);
}

/* Checks for saving and clearing prior to function call.  */
/* { dg-final { scan-assembler-not ""cmse_is_nsfptr"" } } */
/* { dg-final { scan-assembler-not ""cmse_nsfptr_create"" } } */
"
"foo (long long *p)
{
  p[0] = p[1];
}
","foo (long long *p)
{
  p[0] = p[1];
}
"
"#include <stdarg.h>

#include ""compat-common.h""

#ifdef SKIP_VA
const int test_va = 0;
#else
const int test_va = 1;
#endif

#include ""fp-struct-defs.h""
#include ""fp-struct-init.h""
#include ""fp-struct-test-by-value-y.h""

#ifndef SKIP_COMPLEX
DEFS(cd,_Complex double)
INITS(cd, _Complex double)

TEST(Scd1, _Complex double)
TEST(Scd2, _Complex double)
TEST(Scd3, _Complex double)
TEST(Scd4, _Complex double)
TEST(Scd5, _Complex double)
TEST(Scd6, _Complex double)
TEST(Scd7, _Complex double)
TEST(Scd8, _Complex double)
TEST(Scd9, _Complex double)
TEST(Scd10, _Complex double)
TEST(Scd11, _Complex double)
TEST(Scd12, _Complex double)
#endif
","#include <stdarg.h>

#include ""compat-common.h""

#ifdef SKIP_VA
const int test_va = 0;
#else
const int test_va = 1;
#endif

#include ""fp-struct-defs.h""
#include ""fp-struct-init.h""
#include ""fp-struct-test-by-value-y.h""

#ifndef SKIP_COMPLEX
DEFS(cd,_Complex double)
INITS(cd, _Complex double)

TEST(Scd1, _Complex double)
TEST(Scd2, _Complex double)
TEST(Scd3, _Complex double)
TEST(Scd4, _Complex double)
TEST(Scd5, _Complex double)
TEST(Scd6, _Complex double)
TEST(Scd7, _Complex double)
TEST(Scd8, _Complex double)
TEST(Scd9, _Complex double)
TEST(Scd10, _Complex double)
TEST(Scd11, _Complex double)
TEST(Scd12, _Complex double)
#endif
"
"/* PR target/80310 */
/* { dg-do run } */
/* { dg-options ""-O0 -fsanitize=shift -fno-sanitize-recover=shift"" } */

unsigned int x = 1;
unsigned int y = 0;

void foo() {
  y = 1 >> (!x * 1111);
}

int main () {
    foo ();
    if (y != 1)
      __builtin_abort ();
    return 0;
}
","/* PR target/80310 */
/* { dg-do run } */
/* { dg-options ""-O0 -fsanitize=shift -fno-sanitize-recover=shift"" } */

unsigned int x = 1;
unsigned int y = 0;

void foo() {
  y = 1 >> (!x * 1111);
}

int main () {
    foo ();
    if (y != 1)
      __builtin_abort ();
    return 0;
}
"
"/* { dg-do compile } */
/* { dg-options ""-std=gnu89"" } */

int
mandel(double _Complex C)
{
  int py;
  C = (__extension__ 1.0iF) * (double)py;
  return cabs(C);  /* { dg-warning ""incompatible"" } */
}

","/* { dg-do compile } */
/* { dg-options ""-std=gnu89"" } */

int
mandel(double _Complex C)
{
  int py;
  C = (__extension__ 1.0iF) * (double)py;
  return cabs(C);  /* { dg-warning ""incompatible"" } */
}

"
"/* { dg-do compile } */

int set_role(unsigned char role_id, short m_role)
{
  return __sync_bool_compare_and_swap(&m_role, -1, role_id);
}

","/* { dg-do compile } */

int set_role(unsigned char role_id, short m_role)
{
  return __sync_bool_compare_and_swap(&m_role, -1, role_id);
}

"
"/* { dg-do run } */
/* { dg-options ""-mavx2 -O2"" } */
/* { dg-require-effective-target avx2 } */

#include ""avx2-check.h""

static void
compute_pmaxud256 (unsigned int *s1, unsigned int *s2, unsigned int *r)
{
  int i;

  for (i = 0; i < 8; i++)
    r[i] = s1[i] > s2[i] ? s1[i] : s2[i];
}

static void
avx2_test (void)
{
  union256i_d s1, s2, res;
  unsigned int res_ref[8];
  int i, j;
  int fail = 0;

  for (i = 0; i < 10; i++)
    {
      for (j = 0; j < 8; j++)
	{
	  s1.a[j] = j * i;
	  s2.a[j] = i + 2000;
	}

      res.x = _mm256_max_epu32 (s1.x, s2.x);

      compute_pmaxud256 ((unsigned *) s1.a, (unsigned *) s2.a,
			 (unsigned *) res_ref);

      fail += check_union256i_d (res, res_ref);
    }

  if (fail != 0)
    abort ();
}
","/* { dg-do run } */
/* { dg-options ""-mavx2 -O2"" } */
/* { dg-require-effective-target avx2 } */

#include ""avx2-check.h""

static void
compute_pmaxud256 (unsigned int *s1, unsigned int *s2, unsigned int *r)
{
  int i;

  for (i = 0; i < 8; i++)
    r[i] = s1[i] > s2[i] ? s1[i] : s2[i];
}

static void
avx2_test (void)
{
  union256i_d s1, s2, res;
  unsigned int res_ref[8];
  int i, j;
  int fail = 0;

  for (i = 0; i < 10; i++)
    {
      for (j = 0; j < 8; j++)
	{
	  s1.a[j] = j * i;
	  s2.a[j] = i + 2000;
	}

      res.x = _mm256_max_epu32 (s1.x, s2.x);

      compute_pmaxud256 ((unsigned *) s1.a, (unsigned *) s2.a,
			 (unsigned *) res_ref);

      fail += check_union256i_d (res, res_ref);
    }

  if (fail != 0)
    abort ();
}
"
"extern void abort (void);

typedef short  __v2hi __attribute ((vector_size(4)));
typedef __v2hi fract2x16;
typedef short fract16;

int main ()
{
  fract2x16 a;
  fract16 t;

  a = __builtin_bfin_compose_2x16 (0x1001, 0x0001);

  t = __builtin_bfin_diff_lh_fr2x16 (a);
  if (t != -0x1000)
    abort ();

  return 0;
}

","extern void abort (void);

typedef short  __v2hi __attribute ((vector_size(4)));
typedef __v2hi fract2x16;
typedef short fract16;

int main ()
{
  fract2x16 a;
  fract16 t;

  a = __builtin_bfin_compose_2x16 (0x1001, 0x0001);

  t = __builtin_bfin_diff_lh_fr2x16 (a);
  if (t != -0x1000)
    abort ();

  return 0;
}

"
"/* PR middle-end/59261 */
/* { dg-do compile } */
/* { dg-options ""-O2"" } */

typedef signed char V __attribute__((vector_size (8)));

void
foo (V *a, V *b)
{
  *a = *b * 3;
}

void
bar (V *a, V *b)
{
  *a = *b * 4;
}
","/* PR middle-end/59261 */
/* { dg-do compile } */
/* { dg-options ""-O2"" } */

typedef signed char V __attribute__((vector_size (8)));

void
foo (V *a, V *b)
{
  *a = *b * 3;
}

void
bar (V *a, V *b)
{
  *a = *b * 4;
}
"
"foo (a, p)
     int *p;
{
  *p = a > 0;
}
","foo (a, p)
     int *p;
{
  *p = a > 0;
}
"
"/* { dg-do compile { target { powerpc*-*-* } } } */
/* { dg-skip-if ""do not override -mcpu"" { powerpc*-*-* } { ""-mcpu=*"" } { ""-mcpu=power9"" } } */
/* { dg-require-effective-target powerpc_p9vector_ok } */
/* { dg-options ""-mcpu=power9"" } */

#include <altivec.h>

int
test_all_not_equal (vector signed char *arg1_p, vector signed char *arg2_p)
{
  vector signed char arg_1 = *arg1_p;
  vector signed char arg_2 = *arg2_p;

  return vec_all_ne (arg_1, arg_2);
}

/* { dg-final { scan-assembler ""vcmpneb."" } } */
","/* { dg-do compile { target { powerpc*-*-* } } } */
/* { dg-skip-if ""do not override -mcpu"" { powerpc*-*-* } { ""-mcpu=*"" } { ""-mcpu=power9"" } } */
/* { dg-require-effective-target powerpc_p9vector_ok } */
/* { dg-options ""-mcpu=power9"" } */

#include <altivec.h>

int
test_all_not_equal (vector signed char *arg1_p, vector signed char *arg2_p)
{
  vector signed char arg_1 = *arg1_p;
  vector signed char arg_2 = *arg2_p;

  return vec_all_ne (arg_1, arg_2);
}

/* { dg-final { scan-assembler ""vcmpneb."" } } */
"
"void ProdWord_bla ( gtL, gtRes, lnL )
    int *gtL, *gtRes;
    int lnL;
{
    while ( 1 < lnL )
    {
        *gtRes++ = *gtL++;
        --lnL;
    }
    if ( 0 < lnL )
        if ( gtL[0] == gtL[1] )
            *gtRes++ = 0;
}
","void ProdWord_bla ( gtL, gtRes, lnL )
    int *gtL, *gtRes;
    int lnL;
{
    while ( 1 < lnL )
    {
        *gtRes++ = *gtL++;
        --lnL;
    }
    if ( 0 < lnL )
        if ( gtL[0] == gtL[1] )
            *gtRes++ = 0;
}
"
"/* { dg-options { -fgnu89-inline } } */
typedef struct {
} mem_attrs;
int main(void)
{
  return 0;
}
void *malloc(__SIZE_TYPE__ size);
void *memcpy(void *dest, const void *src, __SIZE_TYPE__ n);
static mem_attrs * get_mem_attrs () {
  void **slot;
  *slot = malloc (3);
  memcpy (*slot, 0, 3);
}
void set_mem_attributes () {
  get_mem_attrs ();
}
void set_mem_alias_set () {
  get_mem_attrs ();
}
","/* { dg-options { -fgnu89-inline } } */
typedef struct {
} mem_attrs;
int main(void)
{
  return 0;
}
void *malloc(__SIZE_TYPE__ size);
void *memcpy(void *dest, const void *src, __SIZE_TYPE__ n);
static mem_attrs * get_mem_attrs () {
  void **slot;
  *slot = malloc (3);
  memcpy (*slot, 0, 3);
}
void set_mem_attributes () {
  get_mem_attrs ();
}
void set_mem_alias_set () {
  get_mem_attrs ();
}
"
"struct data {
    int prio;
    signed char status;
};

struct base {
    unsigned _num;
    struct data vec[10];
};

static struct data *ix(struct base *base, unsigned i)
{
    return &base->vec[i];
}

struct heap {
    struct base base;
};

struct heap *heap;

void increase_insn_priority (int *fld, int amount)
{
    if (ix(heap ? &heap->base : 0, *fld)->status > 0)
	ix(heap ? &heap->base : 0, *fld)->prio += amount;
}
","struct data {
    int prio;
    signed char status;
};

struct base {
    unsigned _num;
    struct data vec[10];
};

static struct data *ix(struct base *base, unsigned i)
{
    return &base->vec[i];
}

struct heap {
    struct base base;
};

struct heap *heap;

void increase_insn_priority (int *fld, int amount)
{
    if (ix(heap ? &heap->base : 0, *fld)->status > 0)
	ix(heap ? &heap->base : 0, *fld)->prio += amount;
}
"
"/* PR tree-optimization/48186 */
/* { dg-do compile } */
/* { dg-options ""-O --param hot-bb-frequency-fraction=0"" } */

void foo (void) { }
","/* PR tree-optimization/48186 */
/* { dg-do compile } */
/* { dg-options ""-O --param hot-bb-frequency-fraction=0"" } */

void foo (void) { }
"
"/* { dg-do run } */
/* { dg-options ""-O3 -mpower8-vector -Wno-psabi"" } */
/* { dg-require-effective-target lp64 } */
/* { dg-require-effective-target p8vector_hw } */

#ifndef CHECK_H
#define CHECK_H ""sse2-check.h""
#endif

#include CHECK_H

#ifndef TEST
#define TEST sse2_test_punpckldq_1
#endif

#include <emmintrin.h>

static __m128i
__attribute__((noinline, unused))
test (__m128i s1, __m128i s2)
{
  __asm("""" : ""+v""(s1), ""+v""(s2));
  return _mm_unpacklo_epi32 (s1, s2); 
}

static void
TEST (void)
{
  union128i_d u, s1, s2;
  int e[4];
  int i;
   
  s1.x = _mm_set_epi32 (10,20,-80,-40);
  s2.x = _mm_set_epi32 (11, -34, -78, -39);
  u.x = test (s1.x, s2.x); 
   
  for (i = 0; i < 2; i++)
    {
      e[2*i] = s1.a[i];
      e[2*i+1] = s2.a[i];
    }

  if (check_union128i_d (u, e))
    abort ();
}
","/* { dg-do run } */
/* { dg-options ""-O3 -mpower8-vector -Wno-psabi"" } */
/* { dg-require-effective-target lp64 } */
/* { dg-require-effective-target p8vector_hw } */

#ifndef CHECK_H
#define CHECK_H ""sse2-check.h""
#endif

#include CHECK_H

#ifndef TEST
#define TEST sse2_test_punpckldq_1
#endif

#include <emmintrin.h>

static __m128i
__attribute__((noinline, unused))
test (__m128i s1, __m128i s2)
{
  __asm("""" : ""+v""(s1), ""+v""(s2));
  return _mm_unpacklo_epi32 (s1, s2); 
}

static void
TEST (void)
{
  union128i_d u, s1, s2;
  int e[4];
  int i;
   
  s1.x = _mm_set_epi32 (10,20,-80,-40);
  s2.x = _mm_set_epi32 (11, -34, -78, -39);
  u.x = test (s1.x, s2.x); 
   
  for (i = 0; i < 2; i++)
    {
      e[2*i] = s1.a[i];
      e[2*i+1] = s2.a[i];
    }

  if (check_union128i_d (u, e))
    abort ();
}
"
"/* { dg-do compile } */
/* { dg-options ""-fno-dse"" } */

void bar(void);

void foo (int i, ...)
{
  __builtin_va_list ap;
  __builtin_va_start (ap, i);
  __builtin_va_arg (ap, int);
  while (i) i++;
  __builtin_va_arg (ap, int);
  while (i) i++;
  __builtin_va_arg (ap, int);
  while (i) i++;
  __builtin_va_arg (ap, int);
  if (i)
    bar ();
}

","/* { dg-do compile } */
/* { dg-options ""-fno-dse"" } */

void bar(void);

void foo (int i, ...)
{
  __builtin_va_list ap;
  __builtin_va_start (ap, i);
  __builtin_va_arg (ap, int);
  while (i) i++;
  __builtin_va_arg (ap, int);
  while (i) i++;
  __builtin_va_arg (ap, int);
  while (i) i++;
  __builtin_va_arg (ap, int);
  if (i)
    bar ();
}

"
"/* { dg-require-effective-target alloca } */
typedef unsigned long grub_uint64_t;
typedef grub_uint64_t grub_size_t;
grub_cmdline_get (unsigned max_len, int echo_char)
{
  unsigned xpos, ypos, ystart;
  grub_size_t lpos, llen;
  char buf[max_len];
  void cl_print (int pos, int c)
  {
      char *p;
      for (p = buf + pos; *p; p++)
      {
        if (xpos++ > 78)
          grub_putchar ('\n');
        grub_putchar (*p);
      }
 }
 void cl_delete (unsigned len)
 {
   cl_set_pos ();
   cl_print (lpos, ' ');
   grub_memmove ();
   cl_print (lpos, echo_char);
   cl_set_pos ();
 }
 cl_delete (llen);
 grub_size_t n = lpos;
 cl_delete (n);
}
","/* { dg-require-effective-target alloca } */
typedef unsigned long grub_uint64_t;
typedef grub_uint64_t grub_size_t;
grub_cmdline_get (unsigned max_len, int echo_char)
{
  unsigned xpos, ypos, ystart;
  grub_size_t lpos, llen;
  char buf[max_len];
  void cl_print (int pos, int c)
  {
      char *p;
      for (p = buf + pos; *p; p++)
      {
        if (xpos++ > 78)
          grub_putchar ('\n');
        grub_putchar (*p);
      }
 }
 void cl_delete (unsigned len)
 {
   cl_set_pos ();
   cl_print (lpos, ' ');
   grub_memmove ();
   cl_print (lpos, echo_char);
   cl_set_pos ();
 }
 cl_delete (llen);
 grub_size_t n = lpos;
 cl_delete (n);
}
"
"// Test that we track line numbers properly across newlines
// both escaped and not in raw strings.
// { dg-options ""-std=gnu99"" { target c } }
// { dg-options ""-std=c++0x"" { target c++ } }

const char a[] = R""(\

)"";

T t;				// { dg-error """" }
","// Test that we track line numbers properly across newlines
// both escaped and not in raw strings.
// { dg-options ""-std=gnu99"" { target c } }
// { dg-options ""-std=c++0x"" { target c++ } }

const char a[] = R""(\

)"";

T t;				// { dg-error """" }
"
"/* Test for rejection of __alignof on bit-fields.  */
/* Origin: Joseph Myers <joseph@codesourcery.com> */
/* { dg-do compile } */
/* { dg-options """" } */

struct { int a : 1; } x;

int r = __alignof (x.a); /* { dg-error ""'__alignof' applied to a bit-field"" } */
","/* Test for rejection of __alignof on bit-fields.  */
/* Origin: Joseph Myers <joseph@codesourcery.com> */
/* { dg-do compile } */
/* { dg-options """" } */

struct { int a : 1; } x;

int r = __alignof (x.a); /* { dg-error ""'__alignof' applied to a bit-field"" } */
"
"typedef unsigned int uint32_t;
static void IP(uint32_t v[2])
{
    v[0] = ((v[0] << 1) | ((v[0] >> 31) & 1L)) & 0xffffffffL;
}

","typedef unsigned int uint32_t;
static void IP(uint32_t v[2])
{
    v[0] = ((v[0] << 1) | ((v[0] >> 31) & 1L)) & 0xffffffffL;
}

"
"/* PR sanitizer/68260 */

#include <pthread.h>
#include <stdbool.h>

bool lock;
int counter;

void *
tf (void *arg)
{
  (void) arg;
  while (__atomic_test_and_set (&lock, __ATOMIC_ACQUIRE))
    ;
  ++counter;
  __atomic_clear (&lock, __ATOMIC_RELEASE);
  return (void *) 0;
}

int
main ()
{
  pthread_t thr;
  pthread_create (&thr, 0, tf, 0);
  tf ((void *) 0);
  pthread_join (thr, 0);
  return 0;
}
","/* PR sanitizer/68260 */

#include <pthread.h>
#include <stdbool.h>

bool lock;
int counter;

void *
tf (void *arg)
{
  (void) arg;
  while (__atomic_test_and_set (&lock, __ATOMIC_ACQUIRE))
    ;
  ++counter;
  __atomic_clear (&lock, __ATOMIC_RELEASE);
  return (void *) 0;
}

int
main ()
{
  pthread_t thr;
  pthread_create (&thr, 0, tf, 0);
  tf ((void *) 0);
  pthread_join (thr, 0);
  return 0;
}
"
"/* Test the vqdmlsl_high_lane_s16 AArch64 SIMD intrinsic.  */

/* { dg-do compile } */
/* { dg-options ""-save-temps -O3 -fno-inline"" } */

#include ""arm_neon.h""

int32x4_t
t_vqdmlsl_high_lane_s16 (int32x4_t a, int16x8_t b, int16x4_t c)
{
  return vqdmlsl_high_lane_s16 (a, b, c, 0);
}

/* { dg-final { scan-assembler-times ""sqdmlsl2\[ \t\]+\[vV\]\[0-9\]+\.4\[sS\], ?\[vV\]\[0-9\]+\.8\[hH\], ?\[vV\]\[0-9\]+\.\[hH\]\\\[0\\\]\n"" 1 } } */
","/* Test the vqdmlsl_high_lane_s16 AArch64 SIMD intrinsic.  */

/* { dg-do compile } */
/* { dg-options ""-save-temps -O3 -fno-inline"" } */

#include ""arm_neon.h""

int32x4_t
t_vqdmlsl_high_lane_s16 (int32x4_t a, int16x8_t b, int16x4_t c)
{
  return vqdmlsl_high_lane_s16 (a, b, c, 0);
}

/* { dg-final { scan-assembler-times ""sqdmlsl2\[ \t\]+\[vV\]\[0-9\]+\.4\[sS\], ?\[vV\]\[0-9\]+\.8\[hH\], ?\[vV\]\[0-9\]+\.\[hH\]\\\[0\\\]\n"" 1 } } */
"
"/* { dg-require-effective-target indirect_jumps } */

extern void*t[];x(i){goto*t[i];}
","/* { dg-require-effective-target indirect_jumps } */

extern void*t[];x(i){goto*t[i];}
"
"/* { dg-do compile { target powerpc*-*-* ia64-*-* i?86-*-* x86_64-*-* } } */
/* { dg-options ""-Os -fselective-scheduling2 -g"" } */
int bar (int);
int *baz (int *);

void
foo (int a)
{
  while (bar (0))
    {
      int *c = baz (0);
      if (a)
	{
	  int i = *baz (c);
	}
      bar (*baz (c));
    }
}
","/* { dg-do compile { target powerpc*-*-* ia64-*-* i?86-*-* x86_64-*-* } } */
/* { dg-options ""-Os -fselective-scheduling2 -g"" } */
int bar (int);
int *baz (int *);

void
foo (int a)
{
  while (bar (0))
    {
      int *c = baz (0);
      if (a)
	{
	  int i = *baz (c);
	}
      bar (*baz (c));
    }
}
"
"/* { dg-do compile } */
/* { dg-options ""-march=amdfam10 -O2"" } */
int a, b, c, e, f, g, h;
long *d;
__attribute__((cold)) void fn1() {
  int i = g | 1;
  for (; g; h++) {
    for (; a; e++) d[0] = c;
    if (0.002 * i) break;
    for (; b; f++) d[h] = 0;
  }
}
","/* { dg-do compile } */
/* { dg-options ""-march=amdfam10 -O2"" } */
int a, b, c, e, f, g, h;
long *d;
__attribute__((cold)) void fn1() {
  int i = g | 1;
  for (; g; h++) {
    for (; a; e++) d[0] = c;
    if (0.002 * i) break;
    for (; b; f++) d[h] = 0;
  }
}
"
"/* { dg-do compile } */
/* { dg-options ""-O2 -mno-indirect-branch-register -mfunction-return=keep -mindirect-branch=thunk -fno-pic"" } */

void func0 (void);
void func1 (void);
void func2 (void);
void func3 (void);
void func4 (void);
void func4 (void);
void func5 (void);

void
bar (int i)
{
  switch (i)
    {
    default:
      func0 ();
      break;
    case 1:
      func1 ();
      break;
    case 2:
      func2 ();
      break;
    case 3:
      func3 ();
      break;
    case 4:
      func4 ();
      break;
    case 5:
      func5 ();
      break;
    }
}

/* { dg-final { scan-assembler ""mov(?:l|q)\[ \t\]*\.L\[0-9\]+\\(,%"" { target *-*-linux* } } } */
/* { dg-final { scan-assembler ""jmp\[ \t\]*__x86_indirect_thunk_(r|e)ax"" } } */
/* { dg-final { scan-assembler ""jmp\[ \t\]*\.LIND"" } } */
/* { dg-final { scan-assembler ""call\[ \t\]*\.LIND"" } } */
/* { dg-final { scan-assembler {\tpause} } } */
/* { dg-final { scan-assembler {\tlfence} } } */
","/* { dg-do compile } */
/* { dg-options ""-O2 -mno-indirect-branch-register -mfunction-return=keep -mindirect-branch=thunk -fno-pic"" } */

void func0 (void);
void func1 (void);
void func2 (void);
void func3 (void);
void func4 (void);
void func4 (void);
void func5 (void);

void
bar (int i)
{
  switch (i)
    {
    default:
      func0 ();
      break;
    case 1:
      func1 ();
      break;
    case 2:
      func2 ();
      break;
    case 3:
      func3 ();
      break;
    case 4:
      func4 ();
      break;
    case 5:
      func5 ();
      break;
    }
}

/* { dg-final { scan-assembler ""mov(?:l|q)\[ \t\]*\.L\[0-9\]+\\(,%"" { target *-*-linux* } } } */
/* { dg-final { scan-assembler ""jmp\[ \t\]*__x86_indirect_thunk_(r|e)ax"" } } */
/* { dg-final { scan-assembler ""jmp\[ \t\]*\.LIND"" } } */
/* { dg-final { scan-assembler ""call\[ \t\]*\.LIND"" } } */
/* { dg-final { scan-assembler {\tpause} } } */
/* { dg-final { scan-assembler {\tlfence} } } */
"
"int f(float * );
__SIZE_TYPE__ FcCharSetFreeze (int *fcs, int b)
{
  int i;
  int a = 0;
  for (i = 0; i < *fcs; i++)
  {
    float *leaf = (float *)fcs;
    int hash = f (leaf);
    if (hash)
      a = b;
    if (!a)
      return;
  }
  return (__SIZE_TYPE__) fcs;
}

","int f(float * );
__SIZE_TYPE__ FcCharSetFreeze (int *fcs, int b)
{
  int i;
  int a = 0;
  for (i = 0; i < *fcs; i++)
  {
    float *leaf = (float *)fcs;
    int hash = f (leaf);
    if (hash)
      a = b;
    if (!a)
      return;
  }
  return (__SIZE_TYPE__) fcs;
}

"
"/* { dg-do run } */
/* { dg-options ""-O2 -fipa-pta -fdump-ipa-pta2-details"" } */

#include <stdarg.h>

static void __attribute__((noinline,noclone))
foo (int i, ...)
{
  va_list ap;
  int *p;
  va_start (ap, i);
  p = va_arg (ap, int *);
  *p = 1;
  va_end (ap);
}
extern void abort (void);
int main()
{
  int i = 0;
  foo (0, &i);
  if (i != 1)
    abort ();
  return 0;
}

/* Verify we properly handle variadic arguments and do not let escape
   stuff through it.  */

/* { dg-final { scan-ipa-dump ""ESCAPED = { (ESCAPED )?(NONLOCAL )?}"" ""pta2"" } } */
","/* { dg-do run } */
/* { dg-options ""-O2 -fipa-pta -fdump-ipa-pta2-details"" } */

#include <stdarg.h>

static void __attribute__((noinline,noclone))
foo (int i, ...)
{
  va_list ap;
  int *p;
  va_start (ap, i);
  p = va_arg (ap, int *);
  *p = 1;
  va_end (ap);
}
extern void abort (void);
int main()
{
  int i = 0;
  foo (0, &i);
  if (i != 1)
    abort ();
  return 0;
}

/* Verify we properly handle variadic arguments and do not let escape
   stuff through it.  */

/* { dg-final { scan-ipa-dump ""ESCAPED = { (ESCAPED )?(NONLOCAL )?}"" ""pta2"" } } */
"
"#include ""lib/memcmp.c""
","#include ""lib/memcmp.c""
"
"/* { dg-do compile } */

void
a30 (int n, float *a, float *b)
{
  int i;
#pragma omp parallel
  {
#pragma omp for lastprivate(i)
    for (i = 0; i < n - 1; i++)
      a[i] = b[i] + b[i + 1];
  }
  a[i] = b[i];			/* i == n-1 here */
}
","/* { dg-do compile } */

void
a30 (int n, float *a, float *b)
{
  int i;
#pragma omp parallel
  {
#pragma omp for lastprivate(i)
    for (i = 0; i < n - 1; i++)
      a[i] = b[i] + b[i + 1];
  }
  a[i] = b[i];			/* i == n-1 here */
}
"
"f (const int x)
{
  int y = 0;
  y = x ? y : -y;
  {
    const int *p = &x;
  }
  return y;
}

main ()
{
  if (f (0))
    abort ();
  exit (0);
}
","f (const int x)
{
  int y = 0;
  y = x ? y : -y;
  {
    const int *p = &x;
  }
  return y;
}

main ()
{
  if (f (0))
    abort ();
  exit (0);
}
"
"/* PR middle-end/42049 */

extern char *strcpy (char *s1, const char *s2);
struct S { char s[4]; };

int
foo (int x, char **y)
{
  char const *a;
  char const *b;
  struct S s[9];
  long i;
  if (x > 1)
    a = y[1];
  else
    a = ""abc"";
  if (x > 2)
    b = y[2];
  else
    b = ""def"";
  strcpy (s[0].s, a);
  strcpy (s[1].s, b);
  for (i = 2; i < x - 2 && i < 8; i++)
    strcpy (s[i].s, y[i + 1]);
  s[i].s[0] = '\0';
  return 0;
}
","/* PR middle-end/42049 */

extern char *strcpy (char *s1, const char *s2);
struct S { char s[4]; };

int
foo (int x, char **y)
{
  char const *a;
  char const *b;
  struct S s[9];
  long i;
  if (x > 1)
    a = y[1];
  else
    a = ""abc"";
  if (x > 2)
    b = y[2];
  else
    b = ""def"";
  strcpy (s[0].s, a);
  strcpy (s[1].s, b);
  for (i = 2; i < x - 2 && i < 8; i++)
    strcpy (s[i].s, y[i + 1]);
  s[i].s[0] = '\0';
  return 0;
}
"
"int h(int);
int t;
static inline int f(const int i)
{
  int tt = i;
  _Bool a = i < t;
  if (a)
    return h(t);
  return 9;
}
int g(void)
{
  return f(0x7FFFFFFF);
}
","int h(int);
int t;
static inline int f(const int i)
{
  int tt = i;
  _Bool a = i < t;
  if (a)
    return h(t);
  return 9;
}
int g(void)
{
  return f(0x7FFFFFFF);
}
"
"/* Test for scanf formats.  Test that the C90 functions get their default
   attributes in strict C90 mode, but the C99 and gettext functions
   do not.
*/
/* Origin: Joseph Myers <jsm28@cam.ac.uk> */
/* { dg-do compile { target { *-*-mingw* } } } */
/* { dg-options ""-std=iso9899:1990 -pedantic -Wformat"" } */

#define USE_SYSTEM_FORMATS
#include ""format.h""

void
foo (int *ip, char *s, va_list v0, va_list v1, va_list v2, va_list v3,
     va_list v4, va_list v5)
{
  fscanf (stdin, ""%d"", ip);
  fscanf (stdin, ""%ld"", ip); /* { dg-warning ""format"" ""fscanf"" } */
  scanf (""%d"", ip);
  scanf (""%ld"", ip); /* { dg-warning ""format"" ""scanf"" } */
  sscanf (s, ""%d"", ip);
  sscanf (s, ""%ld"", ip); /* { dg-warning ""format"" ""sscanf"" } */
  vfscanf (stdin, ""%d"", v0);
  vscanf (""%d"", v2);
  vsscanf (s, ""%d"", v4);
  scanf (gettext (""%d""), ip);
  scanf (gettext (""%ld""), ip);
  scanf (dgettext ("""", ""%d""), ip);
  scanf (dgettext ("""", ""%ld""), ip);
  scanf (dcgettext ("""", ""%d"", 0), ip);
  scanf (dcgettext ("""", ""%ld"", 0), ip);
}
","/* Test for scanf formats.  Test that the C90 functions get their default
   attributes in strict C90 mode, but the C99 and gettext functions
   do not.
*/
/* Origin: Joseph Myers <jsm28@cam.ac.uk> */
/* { dg-do compile { target { *-*-mingw* } } } */
/* { dg-options ""-std=iso9899:1990 -pedantic -Wformat"" } */

#define USE_SYSTEM_FORMATS
#include ""format.h""

void
foo (int *ip, char *s, va_list v0, va_list v1, va_list v2, va_list v3,
     va_list v4, va_list v5)
{
  fscanf (stdin, ""%d"", ip);
  fscanf (stdin, ""%ld"", ip); /* { dg-warning ""format"" ""fscanf"" } */
  scanf (""%d"", ip);
  scanf (""%ld"", ip); /* { dg-warning ""format"" ""scanf"" } */
  sscanf (s, ""%d"", ip);
  sscanf (s, ""%ld"", ip); /* { dg-warning ""format"" ""sscanf"" } */
  vfscanf (stdin, ""%d"", v0);
  vscanf (""%d"", v2);
  vsscanf (s, ""%d"", v4);
  scanf (gettext (""%d""), ip);
  scanf (gettext (""%ld""), ip);
  scanf (dgettext ("""", ""%d""), ip);
  scanf (dgettext ("""", ""%ld""), ip);
  scanf (dcgettext ("""", ""%d"", 0), ip);
  scanf (dcgettext ("""", ""%ld"", 0), ip);
}
"
"/* { dg-do run } */
/* { dg-options ""-O2 -mavx512vl"" } */
/* { dg-require-effective-target avx512vl } */

#define AVX512VL
#define AVX512F_LEN 256
#define AVX512F_LEN_HALF 128
#include ""avx512f-vsqrtpd-2.c""

#undef AVX512F_LEN
#undef AVX512F_LEN_HALF

#define AVX512F_LEN 128
#define AVX512F_LEN_HALF 128
#include ""avx512f-vsqrtpd-2.c""
","/* { dg-do run } */
/* { dg-options ""-O2 -mavx512vl"" } */
/* { dg-require-effective-target avx512vl } */

#define AVX512VL
#define AVX512F_LEN 256
#define AVX512F_LEN_HALF 128
#include ""avx512f-vsqrtpd-2.c""

#undef AVX512F_LEN
#undef AVX512F_LEN_HALF

#define AVX512F_LEN 128
#define AVX512F_LEN_HALF 128
#include ""avx512f-vsqrtpd-2.c""
"
"/* { dg-do compile } */
/* { dg-options ""-mavx2 -O2"" } */
/* { dg-final { scan-assembler ""vpavgb\[ \\t\]+\[^\n\]*%ymm\[0-9\]"" } } */

#include <immintrin.h>

volatile __m256i x;

void extern
avx2_test (void)
{
  x = _mm256_avg_epu8 (x, x);
}
","/* { dg-do compile } */
/* { dg-options ""-mavx2 -O2"" } */
/* { dg-final { scan-assembler ""vpavgb\[ \\t\]+\[^\n\]*%ymm\[0-9\]"" } } */

#include <immintrin.h>

volatile __m256i x;

void extern
avx2_test (void)
{
  x = _mm256_avg_epu8 (x, x);
}
"
"/* Test for enumeration constants not integer constant expressions but
   folding to integer constants (used in Linux kernel,
   <http://gcc.gnu.org/ml/gcc/2009-04/msg00677.html>).  */
/* { dg-do compile } */
/* { dg-options ""-pedantic-errors"" } */

extern int i;
enum e { E = (1 ? 1 : i) }; /* { dg-error ""not an integer constant expression"" } */
","/* Test for enumeration constants not integer constant expressions but
   folding to integer constants (used in Linux kernel,
   <http://gcc.gnu.org/ml/gcc/2009-04/msg00677.html>).  */
/* { dg-do compile } */
/* { dg-options ""-pedantic-errors"" } */

extern int i;
enum e { E = (1 ? 1 : i) }; /* { dg-error ""not an integer constant expression"" } */
"
"/* PR middle-end/42674 */
/* { dg-do compile } */
/* { dg-options ""-Wreturn-type"" } */

extern void bar (void);
static int foo (void) __attribute__ ((__noreturn__, __used__));

static int
foo (void)
{
  while (1)
    bar ();
}
","/* PR middle-end/42674 */
/* { dg-do compile } */
/* { dg-options ""-Wreturn-type"" } */

extern void bar (void);
static int foo (void) __attribute__ ((__noreturn__, __used__));

static int
foo (void)
{
  while (1)
    bar ();
}
"
"/* { dg-do compile } */
/* { dg-options ""-O2 -mavx512f"" } */
/* { dg-final { scan-assembler-times ""vpcmpuq\[ \\t\]+\[^\{\n\]*%zmm\[0-9\]+\[^\n^k\]*%k\[1-7\](?:\n|\[ \\t\]+#)"" 1 } } */
/* { dg-final { scan-assembler-times ""vpcmpuq\[ \\t\]+\[^\{\n\]*%zmm\[0-9\]+\[^\n^k\]*%k\[1-7\]\{%k\[0-7\]\}(?:\n|\[ \\t\]+#)"" 1 } } */

#include <immintrin.h>

volatile __m512i x;
volatile __mmask8 m;

void extern
avx512f_test (void)
{
  m = _mm512_cmp_epu64_mask (x, x, _MM_CMPINT_LE);
  m = _mm512_mask_cmp_epu64_mask (m, x, x, _MM_CMPINT_UNUSED);
}
","/* { dg-do compile } */
/* { dg-options ""-O2 -mavx512f"" } */
/* { dg-final { scan-assembler-times ""vpcmpuq\[ \\t\]+\[^\{\n\]*%zmm\[0-9\]+\[^\n^k\]*%k\[1-7\](?:\n|\[ \\t\]+#)"" 1 } } */
/* { dg-final { scan-assembler-times ""vpcmpuq\[ \\t\]+\[^\{\n\]*%zmm\[0-9\]+\[^\n^k\]*%k\[1-7\]\{%k\[0-7\]\}(?:\n|\[ \\t\]+#)"" 1 } } */

#include <immintrin.h>

volatile __m512i x;
volatile __mmask8 m;

void extern
avx512f_test (void)
{
  m = _mm512_cmp_epu64_mask (x, x, _MM_CMPINT_LE);
  m = _mm512_mask_cmp_epu64_mask (m, x, x, _MM_CMPINT_UNUSED);
}
"
"/* PR optimization/6010 */
/* { dg-do compile } */
/* { dg-options ""-O2 -funroll-all-loops"" } */
/* { dg-options ""-O2 -funroll-all-loops -march=pentium3"" { target { { i?86-*-* x86_64-*-* } && ia32 } } } */

void bar (float);

void foo (float y, unsigned long z)
{
  int b;
  float c = y;

  for (b = 0; b < z; b++)
    {
      bar (c);
      if (c == y)
	c = -y;
      else
	c = y;
    }
}
","/* PR optimization/6010 */
/* { dg-do compile } */
/* { dg-options ""-O2 -funroll-all-loops"" } */
/* { dg-options ""-O2 -funroll-all-loops -march=pentium3"" { target { { i?86-*-* x86_64-*-* } && ia32 } } } */

void bar (float);

void foo (float y, unsigned long z)
{
  int b;
  float c = y;

  for (b = 0; b < z; b++)
    {
      bar (c);
      if (c == y)
	c = -y;
      else
	c = y;
    }
}
"
"/* PR tree-optimization/55191 */
/* { dg-do compile } */
/* { dg-options ""-O2"" } */

int a, b;

void f(void)
{
  b = a || b;

  for(a = 0; a < 2; a++);
  while(1);
}

","/* PR tree-optimization/55191 */
/* { dg-do compile } */
/* { dg-options ""-O2"" } */

int a, b;

void f(void)
{
  b = a || b;

  for(a = 0; a < 2; a++);
  while(1);
}

"
"/* PR c/61854 */
/* { dg-do run } */
/* { dg-options ""-std=gnu89"" } */

int
main (void)
{
  int i = 0
#if 0
// /*
#else
// */
+1
#endif
;
  if (i != 1)
    __builtin_abort ();
  return 0;
}
","/* PR c/61854 */
/* { dg-do run } */
/* { dg-options ""-std=gnu89"" } */

int
main (void)
{
  int i = 0
#if 0
// /*
#else
// */
+1
#endif
;
  if (i != 1)
    __builtin_abort ();
  return 0;
}
"
"/* PR tree-optimization/46099.  */
/* { dg-do compile } */
/* { dg-options ""-ftree-parallelize-loops=2 -fcompare-debug -O --param parloops-chunk-size=100"" } */

#include ""pr46099.c""
","/* PR tree-optimization/46099.  */
/* { dg-do compile } */
/* { dg-options ""-ftree-parallelize-loops=2 -fcompare-debug -O --param parloops-chunk-size=100"" } */

#include ""pr46099.c""
"
"/* { dg-options ""-Wimplicit-function-declaration"" } */

extern double sqrt (double);

void test (float pf, float inff)
{
  assert (pf == inff); /* { dg-bogus ""sqrt"" } */
  /* { dg-warning ""implicit declaration of function 'assert'"" """" { target *-*-* } .-1 } */
  /* { dg-message ""header '<assert.h>'"" """" { target *-*-* } .-2 } */
}
","/* { dg-options ""-Wimplicit-function-declaration"" } */

extern double sqrt (double);

void test (float pf, float inff)
{
  assert (pf == inff); /* { dg-bogus ""sqrt"" } */
  /* { dg-warning ""implicit declaration of function 'assert'"" """" { target *-*-* } .-1 } */
  /* { dg-message ""header '<assert.h>'"" """" { target *-*-* } .-2 } */
}
"
"/* { dg-do compile } */
/* { dg-options ""-O1"" } */
/* { dg-final { scan-assembler ""wrctl\\tctl6, zero"" } } */

void foo(void){
  __builtin_wrctl(6,0);
}
","/* { dg-do compile } */
/* { dg-options ""-O1"" } */
/* { dg-final { scan-assembler ""wrctl\\tctl6, zero"" } } */

void foo(void){
  __builtin_wrctl(6,0);
}
"
"/* PR middle-end/82063 - issues with arguments enabled by -Wall
   { dg-do compile }
   { dg-options ""-O -Walloc-size-larger-than=1GiB -ftrack-macro-expansion=0"" } */

void sink (void*);

#define T(x) sink (x)

void f (void)
{
  __SIZE_TYPE__ n = 0;
  T (__builtin_malloc (n));

  n = 1024 * 1024 * 1024;   /* 1 gigibyte (GiB) */
  T (__builtin_malloc (n));

  n += 1;
  T (__builtin_malloc (n));   /* { dg-warning ""argument 1 value .1073741825. exceeds maximum object size 1073741824"" } */

  n = __PTRDIFF_MAX__;
  T (__builtin_malloc (n));   /* { dg-warning ""exceeds maximum object size"" } */

  n = __SIZE_MAX__;
  T (__builtin_malloc (n));   /* { dg-warning ""exceeds maximum object size"" } */
}
","/* PR middle-end/82063 - issues with arguments enabled by -Wall
   { dg-do compile }
   { dg-options ""-O -Walloc-size-larger-than=1GiB -ftrack-macro-expansion=0"" } */

void sink (void*);

#define T(x) sink (x)

void f (void)
{
  __SIZE_TYPE__ n = 0;
  T (__builtin_malloc (n));

  n = 1024 * 1024 * 1024;   /* 1 gigibyte (GiB) */
  T (__builtin_malloc (n));

  n += 1;
  T (__builtin_malloc (n));   /* { dg-warning ""argument 1 value .1073741825. exceeds maximum object size 1073741824"" } */

  n = __PTRDIFF_MAX__;
  T (__builtin_malloc (n));   /* { dg-warning ""exceeds maximum object size"" } */

  n = __SIZE_MAX__;
  T (__builtin_malloc (n));   /* { dg-warning ""exceeds maximum object size"" } */
}
"
"/* { dg-do run } */
/* { dg-options ""-O2 -mavx512bw -mavx512vl"" } */
/* { dg-require-effective-target avx512vl } */
/* { dg-require-effective-target avx512bw } */

#define AVX512VL
#define AVX512F_LEN 256
#define AVX512F_LEN_HALF 128
#include ""avx512bw-vpcmpleub-2.c""

#undef AVX512F_LEN
#undef AVX512F_LEN_HALF

#define AVX512F_LEN 128
#define AVX512F_LEN_HALF 128
#include ""avx512bw-vpcmpleb-2.c""
","/* { dg-do run } */
/* { dg-options ""-O2 -mavx512bw -mavx512vl"" } */
/* { dg-require-effective-target avx512vl } */
/* { dg-require-effective-target avx512bw } */

#define AVX512VL
#define AVX512F_LEN 256
#define AVX512F_LEN_HALF 128
#include ""avx512bw-vpcmpleub-2.c""

#undef AVX512F_LEN
#undef AVX512F_LEN_HALF

#define AVX512F_LEN 128
#define AVX512F_LEN_HALF 128
#include ""avx512bw-vpcmpleb-2.c""
"
"/* { dg-do run } */
/* { dg-options ""-O2 -msse2"" } */
/* { dg-require-effective-target sse2 } */

#ifndef CHECK_H
#define CHECK_H ""sse2-check.h""
#endif

#ifndef TEST
#define TEST sse2_test
#endif

#define N 0x5

#include CHECK_H

#include <emmintrin.h>

static __m128i
__attribute__((noinline, unused))
test (__m128i s1)
{
  return _mm_srli_si128 (s1, N); 
}

static void
TEST (void)
{
  union128i_b u, s;
  char src[16] = {1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16};
  char e[16] = {0};
  int i;
   
  s.x = _mm_loadu_si128 ((__m128i *)src);

  u.x = test (s.x);

  for (i = 0; i < 16-N; i++)
    e[i] = src[i+N];

  if (check_union128i_b (u, e))
    abort (); 
}
","/* { dg-do run } */
/* { dg-options ""-O2 -msse2"" } */
/* { dg-require-effective-target sse2 } */

#ifndef CHECK_H
#define CHECK_H ""sse2-check.h""
#endif

#ifndef TEST
#define TEST sse2_test
#endif

#define N 0x5

#include CHECK_H

#include <emmintrin.h>

static __m128i
__attribute__((noinline, unused))
test (__m128i s1)
{
  return _mm_srli_si128 (s1, N); 
}

static void
TEST (void)
{
  union128i_b u, s;
  char src[16] = {1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16};
  char e[16] = {0};
  int i;
   
  s.x = _mm_loadu_si128 ((__m128i *)src);

  u.x = test (s.x);

  for (i = 0; i < 16-N; i++)
    e[i] = src[i+N];

  if (check_union128i_b (u, e))
    abort (); 
}
"
"/* Test for rejection of __func__ outside a function (GNU extensions
   are OK there).  Test with no special options.  */
/* Origin: Joseph Myers <joseph@codesourcery.com> */
/* { dg-do compile } */
/* { dg-options ""-fshow-column"" } */

const char *a = __func__; /* { dg-warning ""17:'__func__' is not defined outside of function scope"" ""undef"" } */
const char *b = __FUNCTION__;
const char *c = __PRETTY_FUNCTION__;
","/* Test for rejection of __func__ outside a function (GNU extensions
   are OK there).  Test with no special options.  */
/* Origin: Joseph Myers <joseph@codesourcery.com> */
/* { dg-do compile } */
/* { dg-options ""-fshow-column"" } */

const char *a = __func__; /* { dg-warning ""17:'__func__' is not defined outside of function scope"" ""undef"" } */
const char *b = __FUNCTION__;
const char *c = __PRETTY_FUNCTION__;
"
"/* { dg-do compile { target { riscv64*-*-* } } } */
/* { dg-options ""-march=rv64gc -mabi=lp64 -O"" } */

/* Test for <optab>si3_mask_1.  */
extern int k;
void
sub2 (int i, long j)
{
  k = i << (j & 0x1f);
}

/* Test for <optab>si3_extend_mask.  */
unsigned long
sub3 (int mask)
{
  return 1 << (mask & 0xff);
}

/* Test for <optab>si3_extend_mask_1.  */
int
sub4 (int i, int j)
{
  return i << (j & 0x1f);
}

/* Test for <optab>di3_mask.  */
long
sub5 (long i, int j)
{
  char k = j & 0x3f;
  return i << k;
}

/* Test for <optab>di3_mask_1.  */
long
sub6 (long i, long j)
{
  return i << (j & 0x3f);
}
/* { dg-final { scan-assembler-not ""andi"" } } */
/* { dg-final { scan-assembler-not ""sext.w"" } } */
","/* { dg-do compile { target { riscv64*-*-* } } } */
/* { dg-options ""-march=rv64gc -mabi=lp64 -O"" } */

/* Test for <optab>si3_mask_1.  */
extern int k;
void
sub2 (int i, long j)
{
  k = i << (j & 0x1f);
}

/* Test for <optab>si3_extend_mask.  */
unsigned long
sub3 (int mask)
{
  return 1 << (mask & 0xff);
}

/* Test for <optab>si3_extend_mask_1.  */
int
sub4 (int i, int j)
{
  return i << (j & 0x1f);
}

/* Test for <optab>di3_mask.  */
long
sub5 (long i, int j)
{
  char k = j & 0x3f;
  return i << k;
}

/* Test for <optab>di3_mask_1.  */
long
sub6 (long i, long j)
{
  return i << (j & 0x3f);
}
/* { dg-final { scan-assembler-not ""andi"" } } */
/* { dg-final { scan-assembler-not ""sext.w"" } } */
"
"/* Test volatile access to unaligned field.  */
/* { dg-do compile } */
/* { dg-options ""-fno-strict-volatile-bitfields -fdump-rtl-final"" } */

#define test_type unsigned short

typedef struct s{
 unsigned char Prefix[1];
 volatile test_type Type;
}__attribute((__packed__,__aligned__(4))) ss;

extern volatile ss v;

void
foo (test_type u)
{
  v.Type = u;
}

/* The C++ memory model forbids data store race conditions outside the
   unaligned data member, therefore only QI or HI access is allowed, no SI.  */
/* { dg-final { scan-rtl-dump-not ""mem/v(/.)*:SI"" ""final"" } } */
","/* Test volatile access to unaligned field.  */
/* { dg-do compile } */
/* { dg-options ""-fno-strict-volatile-bitfields -fdump-rtl-final"" } */

#define test_type unsigned short

typedef struct s{
 unsigned char Prefix[1];
 volatile test_type Type;
}__attribute((__packed__,__aligned__(4))) ss;

extern volatile ss v;

void
foo (test_type u)
{
  v.Type = u;
}

/* The C++ memory model forbids data store race conditions outside the
   unaligned data member, therefore only QI or HI access is allowed, no SI.  */
/* { dg-final { scan-rtl-dump-not ""mem/v(/.)*:SI"" ""final"" } } */
"
"/* { dg-do compile } */
/* { dg-options ""-O3 -march=skylake-avx512"" } */
/* { dg-final { scan-assembler-not ""%zmm\[0-9\]+"" } } */

void
avx512f_test (short *table)
{
  int i;
  for (i = 0; i < 128; ++i)
    table[i] = -1;
}
","/* { dg-do compile } */
/* { dg-options ""-O3 -march=skylake-avx512"" } */
/* { dg-final { scan-assembler-not ""%zmm\[0-9\]+"" } } */

void
avx512f_test (short *table)
{
  int i;
  for (i = 0; i < 128; ++i)
    table[i] = -1;
}
"
"/* PR c/60195 */
/* { dg-do compile } */
/* { dg-options ""-std=c11 -Wpedantic -Wall"" } */

_Atomic int a;

void
fn (void)
{
  ++a;
  a++;
  --a;
  a--;
}
","/* PR c/60195 */
/* { dg-do compile } */
/* { dg-options ""-std=c11 -Wpedantic -Wall"" } */

_Atomic int a;

void
fn (void)
{
  ++a;
  a++;
  --a;
  a--;
}
"
"/* { dg-do compile { target { ptr32plus && { ! llp64 } } } } */

/* This testcase tests whether GCC can produce static initialized data
   that references addresses of size 'unsigned long', even if that's not
   the same as __SIZE_TYPE__.  (See 20011114-1.c for the same test of
   size __SIZE_TYPE__.)  

   Some rare environments might not have the required relocs to support
   this; they should have this test disabled in the .x file.  */

extern void _text;
static unsigned long x = (unsigned long) &_text - 0x10000000L - 1;
","/* { dg-do compile { target { ptr32plus && { ! llp64 } } } } */

/* This testcase tests whether GCC can produce static initialized data
   that references addresses of size 'unsigned long', even if that's not
   the same as __SIZE_TYPE__.  (See 20011114-1.c for the same test of
   size __SIZE_TYPE__.)  

   Some rare environments might not have the required relocs to support
   this; they should have this test disabled in the .x file.  */

extern void _text;
static unsigned long x = (unsigned long) &_text - 0x10000000L - 1;
"
"/* { dg-do compile { target { powerpc*-*-* && lp64 } } } */
/* { dg-require-effective-target powerpc_p9vector_ok } */
/* { dg-options ""-mpower9-vector -O2 -ffast-math"" } */

extern _Float128 sqrtf128 (_Float128);

/* Check sqrt optimizations that are done for double are also done for
   _Float128.  */

_Float128
sqrt_x_times_sqrt_x (_Float128 x)
{
  return sqrtf128 (x) * sqrtf128 (x);
}

/* { dg-final { scan-assembler-not {\mxssqrtqp\M} } } */
/* { dg-final { scan-assembler-not {\mbl\M}       } } */
","/* { dg-do compile { target { powerpc*-*-* && lp64 } } } */
/* { dg-require-effective-target powerpc_p9vector_ok } */
/* { dg-options ""-mpower9-vector -O2 -ffast-math"" } */

extern _Float128 sqrtf128 (_Float128);

/* Check sqrt optimizations that are done for double are also done for
   _Float128.  */

_Float128
sqrt_x_times_sqrt_x (_Float128 x)
{
  return sqrtf128 (x) * sqrtf128 (x);
}

/* { dg-final { scan-assembler-not {\mxssqrtqp\M} } } */
/* { dg-final { scan-assembler-not {\mbl\M}       } } */
"
"/* { dg-do run { target aarch64_sve_hw } } */
/* { dg-options ""-O2 -ftree-vectorize -ffast-math"" } */

#include ""slp_6.c""

#define N (77 * 3)

#define HARNESS(TYPE)					\
  {							\
    TYPE a[N], b[3] = { 40, 22, 75 };			\
    for (unsigned int i = 0; i < N; ++i)		\
      {							\
	a[i] = i * 2 + i % 5;				\
	asm volatile ("""" ::: ""memory"");			\
      }							\
    vec_slp_##TYPE (a, b, N / 3);			\
    TYPE x0 = 40;					\
    TYPE x1 = 22;					\
    TYPE x2 = 75;					\
    for (unsigned int i = 0; i < N; i += 3)		\
      {							\
	x0 += a[i];					\
	x1 += a[i + 1];					\
	x2 += a[i + 2];					\
	asm volatile ("""" ::: ""memory"");			\
      }							\
    /* _Float16 isn't precise enough for this.  */	\
    if ((TYPE) 0x1000 + 1 != (TYPE) 0x1000		\
	&& (x0 != b[0] || x1 != b[1] || x2 != b[2]))	\
      __builtin_abort ();				\
  }

int __attribute__ ((optimize (1)))
main (void)
{
  TEST_ALL (HARNESS)
}
","/* { dg-do run { target aarch64_sve_hw } } */
/* { dg-options ""-O2 -ftree-vectorize -ffast-math"" } */

#include ""slp_6.c""

#define N (77 * 3)

#define HARNESS(TYPE)					\
  {							\
    TYPE a[N], b[3] = { 40, 22, 75 };			\
    for (unsigned int i = 0; i < N; ++i)		\
      {							\
	a[i] = i * 2 + i % 5;				\
	asm volatile ("""" ::: ""memory"");			\
      }							\
    vec_slp_##TYPE (a, b, N / 3);			\
    TYPE x0 = 40;					\
    TYPE x1 = 22;					\
    TYPE x2 = 75;					\
    for (unsigned int i = 0; i < N; i += 3)		\
      {							\
	x0 += a[i];					\
	x1 += a[i + 1];					\
	x2 += a[i + 2];					\
	asm volatile ("""" ::: ""memory"");			\
      }							\
    /* _Float16 isn't precise enough for this.  */	\
    if ((TYPE) 0x1000 + 1 != (TYPE) 0x1000		\
	&& (x0 != b[0] || x1 != b[1] || x2 != b[2]))	\
      __builtin_abort ();				\
  }

int __attribute__ ((optimize (1)))
main (void)
{
  TEST_ALL (HARNESS)
}
"
"/* { dg-do compile } */ 
/* { dg-options ""-O2 -fno-strict-aliasing -fdump-tree-optimized"" } */

struct data {
	volatile unsigned long *addr;
} *p;

int test()
{
	*p->addr;
	return 0;
}

/* The load from p->addr should not disappear.  */
/* { dg-final { scan-tree-dump-times ""\->addr"" 1 ""optimized""} } */
","/* { dg-do compile } */ 
/* { dg-options ""-O2 -fno-strict-aliasing -fdump-tree-optimized"" } */

struct data {
	volatile unsigned long *addr;
} *p;

int test()
{
	*p->addr;
	return 0;
}

/* The load from p->addr should not disappear.  */
/* { dg-final { scan-tree-dump-times ""\->addr"" 1 ""optimized""} } */
"
"/* { dg-do run } */
/* { dg-options ""-O -fschedule-insns"" } */

int f4 (int i, ...)
{
  int y = 0;
   __builtin_va_list ap;
   __builtin_va_start(ap, i);
   if (i == 5) y = __builtin_va_arg(ap, double);
   __builtin_va_end(ap);
   return y;
}

int main (void)
{
  if (f4 (5, 7.0) != 7)
    __builtin_abort ();
  return 0;
}
","/* { dg-do run } */
/* { dg-options ""-O -fschedule-insns"" } */

int f4 (int i, ...)
{
  int y = 0;
   __builtin_va_list ap;
   __builtin_va_start(ap, i);
   if (i == 5) y = __builtin_va_arg(ap, double);
   __builtin_va_end(ap);
   return y;
}

int main (void)
{
  if (f4 (5, 7.0) != 7)
    __builtin_abort ();
  return 0;
}
"
"/* { dg-do run } */
/* { dg-require-effective-target arm_v8_2a_fp16_scalar_hw } */
/* { dg-add-options arm_v8_2a_fp16_scalar }  */

#include <arm_fp16.h>

/* Expected results (16-bit hexadecimal representation).  */
uint16_t expected[] =
{
  0x0000 /* 0.000000 */,
  0x8000 /* -0.000000 */,
  0x42af /* 3.341797 */,
  0x5043 /* 34.093750 */,
  0xccd2 /* -19.281250 */,
  0x3712 /* 0.441895 */,
  0x3acc /* 0.849609 */,
  0x4848 /* 8.562500 */,
  0xcc43 /* -17.046875 */,
  0xd65c /* -101.750000 */,
  0x4185 /* 2.759766 */,
  0xcd39 /* -20.890625 */,
  0xd45b /* -69.687500 */,
  0x5241 /* 50.031250 */,
  0xc675 /* -6.457031 */,
  0x4d07 /* 20.109375 */,
  0x7c00 /* inf */,
  0xfc00 /* -inf */
};

#define TEST_MSG ""VFMSH_F16""
#define INSN_NAME vfmsh_f16

#define EXPECTED expected

#define INPUT_TYPE float16_t
#define OUTPUT_TYPE float16_t
#define OUTPUT_TYPE_SIZE 16

/* Include the template for binary scalar operations.  */
#include ""ternary_scalar_op.inc""
","/* { dg-do run } */
/* { dg-require-effective-target arm_v8_2a_fp16_scalar_hw } */
/* { dg-add-options arm_v8_2a_fp16_scalar }  */

#include <arm_fp16.h>

/* Expected results (16-bit hexadecimal representation).  */
uint16_t expected[] =
{
  0x0000 /* 0.000000 */,
  0x8000 /* -0.000000 */,
  0x42af /* 3.341797 */,
  0x5043 /* 34.093750 */,
  0xccd2 /* -19.281250 */,
  0x3712 /* 0.441895 */,
  0x3acc /* 0.849609 */,
  0x4848 /* 8.562500 */,
  0xcc43 /* -17.046875 */,
  0xd65c /* -101.750000 */,
  0x4185 /* 2.759766 */,
  0xcd39 /* -20.890625 */,
  0xd45b /* -69.687500 */,
  0x5241 /* 50.031250 */,
  0xc675 /* -6.457031 */,
  0x4d07 /* 20.109375 */,
  0x7c00 /* inf */,
  0xfc00 /* -inf */
};

#define TEST_MSG ""VFMSH_F16""
#define INSN_NAME vfmsh_f16

#define EXPECTED expected

#define INPUT_TYPE float16_t
#define OUTPUT_TYPE float16_t
#define OUTPUT_TYPE_SIZE 16

/* Include the template for binary scalar operations.  */
#include ""ternary_scalar_op.inc""
"
"/* { dg-do run } */
/* { dg-options ""-O3 -mpower8-vector -Wno-psabi"" } */
/* { dg-require-effective-target lp64 } */
/* { dg-require-effective-target p8vector_hw } */

#ifndef CHECK_H
#define CHECK_H ""sse2-check.h""
#endif

#include CHECK_H

#ifndef TEST
#define TEST sse2_test_subpd_1
#endif

#include <emmintrin.h>

static __m128d
__attribute__((noinline, unused))
test (__m128d s1, __m128d s2)
{
  __asm("""" : ""+v""(s1), ""+v""(s2));
  return _mm_sub_pd (s1, s2); 
}

static void
TEST (void)
{
  union128d u, s1, s2;
  double e[2];
   
  s1.x = _mm_set_pd (2134.3343,1234.635654);
  s2.x = _mm_set_pd (41124.234,2344.2354);
  u.x = test (s1.x, s2.x); 
   
  e[0] = s1.a[0] - s2.a[0];
  e[1] = s1.a[1] - s2.a[1];

  if (check_union128d (u, e))
    abort ();
}
","/* { dg-do run } */
/* { dg-options ""-O3 -mpower8-vector -Wno-psabi"" } */
/* { dg-require-effective-target lp64 } */
/* { dg-require-effective-target p8vector_hw } */

#ifndef CHECK_H
#define CHECK_H ""sse2-check.h""
#endif

#include CHECK_H

#ifndef TEST
#define TEST sse2_test_subpd_1
#endif

#include <emmintrin.h>

static __m128d
__attribute__((noinline, unused))
test (__m128d s1, __m128d s2)
{
  __asm("""" : ""+v""(s1), ""+v""(s2));
  return _mm_sub_pd (s1, s2); 
}

static void
TEST (void)
{
  union128d u, s1, s2;
  double e[2];
   
  s1.x = _mm_set_pd (2134.3343,1234.635654);
  s2.x = _mm_set_pd (41124.234,2344.2354);
  u.x = test (s1.x, s2.x); 
   
  e[0] = s1.a[0] - s2.a[0];
  e[1] = s1.a[1] - s2.a[1];

  if (check_union128d (u, e))
    abort ();
}
"
"/* __builtin_ms_va_list is only supported for -m64.  */
/* { dg-do run { target lp64 } } */
/* { dg-require-effective-target lto } */
/* { dg-options ""-flto"" } */

#include <stdio.h>

int __attribute__((ms_abi))
foo (int n, ...)
{
  __builtin_ms_va_list ap;
  int sum = 0;

  __builtin_ms_va_start (ap, n);

  while (n--)
    {
      sum += __builtin_va_arg (ap, int);
      printf (""sum = %d\n"", sum);
    }

  __builtin_ms_va_end (ap);

  return sum;
}

int
main (void)
{
  int res = foo (10, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10);

  if (res != 55)
    __builtin_abort ();

  return 0;
}
","/* __builtin_ms_va_list is only supported for -m64.  */
/* { dg-do run { target lp64 } } */
/* { dg-require-effective-target lto } */
/* { dg-options ""-flto"" } */

#include <stdio.h>

int __attribute__((ms_abi))
foo (int n, ...)
{
  __builtin_ms_va_list ap;
  int sum = 0;

  __builtin_ms_va_start (ap, n);

  while (n--)
    {
      sum += __builtin_va_arg (ap, int);
      printf (""sum = %d\n"", sum);
    }

  __builtin_ms_va_end (ap);

  return sum;
}

int
main (void)
{
  int res = foo (10, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10);

  if (res != 55)
    __builtin_abort ();

  return 0;
}
"
"/* { dg-do run } */
/* { dg-options ""-O0 -fipa-icf -fdump-ipa-icf""  } */

struct S
{
  int a;
};

int
foo3 (struct S x, struct S y, struct S z)
{
  if (z.a != 9)
    __builtin_abort ();
  return 0;
}

int
bar3 (struct S x, struct S y, struct S z)
{
  return foo3 (y, x, z);
}

int
baz3 (struct S x, struct S y, struct S z)
{
  return foo3 (y, z, x);
}

int
main (void)
{
  struct S
    a = { 3 },
    b = { 6 },
    c = { 9 };

  return bar3 (b, a, c);
}

/* { dg-final { scan-ipa-dump ""Equal symbols: 0"" ""icf""  } } */
","/* { dg-do run } */
/* { dg-options ""-O0 -fipa-icf -fdump-ipa-icf""  } */

struct S
{
  int a;
};

int
foo3 (struct S x, struct S y, struct S z)
{
  if (z.a != 9)
    __builtin_abort ();
  return 0;
}

int
bar3 (struct S x, struct S y, struct S z)
{
  return foo3 (y, x, z);
}

int
baz3 (struct S x, struct S y, struct S z)
{
  return foo3 (y, z, x);
}

int
main (void)
{
  struct S
    a = { 3 },
    b = { 6 },
    c = { 9 };

  return bar3 (b, a, c);
}

/* { dg-final { scan-ipa-dump ""Equal symbols: 0"" ""icf""  } } */
"
"/* { dg-do compile } */
/* { dg-options ""-O2 -mlong-calls"" } */
/* { dg-final { scan-assembler-not ""bl\[^\n\]*dump_stack"" } } */

extern void dump_stack (void) __attribute__ ((__cold__)) __attribute__ ((noinline));
struct thread_info {
    struct task_struct *task;
};
extern struct thread_info *current_thread_info (void);
extern int show_stack (struct task_struct *, unsigned long *);

void dump_stack (void)
{
  unsigned long stack;
  show_stack ((current_thread_info ()->task), &stack);
}

void die (char *str, void *fp, int nr)
{
  if (nr)
    dump_stack ();
  while (1);
}

","/* { dg-do compile } */
/* { dg-options ""-O2 -mlong-calls"" } */
/* { dg-final { scan-assembler-not ""bl\[^\n\]*dump_stack"" } } */

extern void dump_stack (void) __attribute__ ((__cold__)) __attribute__ ((noinline));
struct thread_info {
    struct task_struct *task;
};
extern struct thread_info *current_thread_info (void);
extern int show_stack (struct task_struct *, unsigned long *);

void dump_stack (void)
{
  unsigned long stack;
  show_stack ((current_thread_info ()->task), &stack);
}

void die (char *str, void *fp, int nr)
{
  if (nr)
    dump_stack ();
  while (1);
}

"
"/* { dg-do compile } */
/* { dg-options ""-O1 -fstrict-overflow -fdump-tree-optimized"" } */

int f(int a)
{
  return (-a)/10;
}


/* { dg-final { scan-tree-dump-times ""-a"" 0 ""optimized""} } */
/* { dg-final { scan-tree-dump-times ""a_..D. / -10"" 1 ""optimized""} } */


","/* { dg-do compile } */
/* { dg-options ""-O1 -fstrict-overflow -fdump-tree-optimized"" } */

int f(int a)
{
  return (-a)/10;
}


/* { dg-final { scan-tree-dump-times ""-a"" 0 ""optimized""} } */
/* { dg-final { scan-tree-dump-times ""a_..D. / -10"" 1 ""optimized""} } */


"
"/* { dg-do run } */
/* { dg-options ""-fpredictive-commoning"" } */

extern void abort (void);
int a[6] = { 0, 0, 0, 0, 7, 0 };
static int *p = &a[4];

int
main ()
{
  int i;
  for (i = 0; i < 4; ++i)
    {
      a[i + 1] = a[i + 2] > i;
      *p &= ~1;
    }
  if (a[4] != 0)
    abort ();
  return 0;
}
","/* { dg-do run } */
/* { dg-options ""-fpredictive-commoning"" } */

extern void abort (void);
int a[6] = { 0, 0, 0, 0, 7, 0 };
static int *p = &a[4];

int
main ()
{
  int i;
  for (i = 0; i < 4; ++i)
    {
      a[i + 1] = a[i + 2] > i;
      *p &= ~1;
    }
  if (a[4] != 0)
    abort ();
  return 0;
}
"
"/* PR target/59501 */
/* { dg-do run } */
/* { dg-options ""-O2 -mavx -maccumulate-outgoing-args"" } */
/* { dg-require-effective-target avx } */

#include ""pr59501-1.c""
","/* PR target/59501 */
/* { dg-do run } */
/* { dg-options ""-O2 -mavx -maccumulate-outgoing-args"" } */
/* { dg-require-effective-target avx } */

#include ""pr59501-1.c""
"
"/* { dg-options ""(!HAS_LSA)"" } */
/* { dg-final { scan-assembler ""\t.globl\tf9"" } } */
/* { dg-final { scan-assembler ""\tsll\t"" } } */
/* { dg-final { scan-assembler ""\taddu\t"" } } */
/* { dg-final { scan-assembler-not ""\tli\t"" } } */
/* { dg-final { scan-assembler-not ""\tmul\t"" } } */
int
f9(int x)
{
  return x * 9;
}
","/* { dg-options ""(!HAS_LSA)"" } */
/* { dg-final { scan-assembler ""\t.globl\tf9"" } } */
/* { dg-final { scan-assembler ""\tsll\t"" } } */
/* { dg-final { scan-assembler ""\taddu\t"" } } */
/* { dg-final { scan-assembler-not ""\tli\t"" } } */
/* { dg-final { scan-assembler-not ""\tmul\t"" } } */
int
f9(int x)
{
  return x * 9;
}
"
"/* { dg-do compile } */ /* PR59617 */
/* { dg-options ""-O3 -mavx512f -fdump-tree-vect-details -mtune=knl"" } */

#include ""avx512f-gather-1.c""

/* { dg-final { scan-assembler-not ""gather\[^\n\]*ymm\[^\n\]*ymm"" } } */
/* { dg-final { scan-assembler-not ""gather\[^\n\]*xmm\[^\n\]*ymm"" } } */
/* { dg-final { scan-assembler-not ""gather\[^\n\]*ymm\[^\n\]*xmm"" } } */
/* { dg-final { scan-assembler-not ""gather\[^\n\]*xmm\[^\n\]*xmm"" } } */
/* { dg-final { scan-tree-dump-times ""vectorized 1 loops in function"" 16 ""vect"" } } */
","/* { dg-do compile } */ /* PR59617 */
/* { dg-options ""-O3 -mavx512f -fdump-tree-vect-details -mtune=knl"" } */

#include ""avx512f-gather-1.c""

/* { dg-final { scan-assembler-not ""gather\[^\n\]*ymm\[^\n\]*ymm"" } } */
/* { dg-final { scan-assembler-not ""gather\[^\n\]*xmm\[^\n\]*ymm"" } } */
/* { dg-final { scan-assembler-not ""gather\[^\n\]*ymm\[^\n\]*xmm"" } } */
/* { dg-final { scan-assembler-not ""gather\[^\n\]*xmm\[^\n\]*xmm"" } } */
/* { dg-final { scan-tree-dump-times ""vectorized 1 loops in function"" 16 ""vect"" } } */
"
"/* { dg-do run } */
/* { dg-options ""-O3 -mpower8-vector"" } */
/* { dg-require-effective-target lp64 } */
/* { dg-require-effective-target p8vector_hw } */

#define NO_WARN_X86_INTRINSICS 1

#ifndef CHECK_H
#define CHECK_H ""sse-check.h""
#endif

#include CHECK_H

#ifndef TEST
#define TEST sse_test_movmskb_1
#endif

#include <xmmintrin.h>

static int
__attribute__((noinline, unused))
test (__m64 a)
{
  return _mm_movemask_pi8 (a);
}

static void
TEST (void)
{
  __m64_union u;
  int d;
  int e = 0;
  int i;

  u.as_m64 = _mm_set_pi8 (1,2,3,4,-80,-40,-100,-15);;
  d = test (u.as_m64);

  for (i = 0; i < 8; i++)
    if (u.as_signed_char[i] < 0)
      e |= (1 << i);

  if (d != e)
    abort ();

}
","/* { dg-do run } */
/* { dg-options ""-O3 -mpower8-vector"" } */
/* { dg-require-effective-target lp64 } */
/* { dg-require-effective-target p8vector_hw } */

#define NO_WARN_X86_INTRINSICS 1

#ifndef CHECK_H
#define CHECK_H ""sse-check.h""
#endif

#include CHECK_H

#ifndef TEST
#define TEST sse_test_movmskb_1
#endif

#include <xmmintrin.h>

static int
__attribute__((noinline, unused))
test (__m64 a)
{
  return _mm_movemask_pi8 (a);
}

static void
TEST (void)
{
  __m64_union u;
  int d;
  int e = 0;
  int i;

  u.as_m64 = _mm_set_pi8 (1,2,3,4,-80,-40,-100,-15);;
  d = test (u.as_m64);

  for (i = 0; i < 8; i++)
    if (u.as_signed_char[i] < 0)
      e |= (1 << i);

  if (d != e)
    abort ();

}
"
"/* { dg-do compile } */
/* { dg-options ""-w"" } */

void __attribute__((noreturn)) bar(void)
{
}

void foo(int i, char *p, char *q)
{
  while (*p++) {
      if (i)
	p++;
      if (!*q++)
	bar();
  }
}
","/* { dg-do compile } */
/* { dg-options ""-w"" } */

void __attribute__((noreturn)) bar(void)
{
}

void foo(int i, char *p, char *q)
{
  while (*p++) {
      if (i)
	p++;
      if (!*q++)
	bar();
  }
}
"
"/* { dg-do compile } */
/* { dg-options ""-O2 -m8bit-idiv"" } */

extern void abort (void);

void
test (unsigned int x, unsigned int y, unsigned int q, unsigned int r)
{
  if ((x / y) != q || (x % y) != r)
    abort ();
}

/* { dg-final { scan-assembler-times ""divb"" 1 } } */
/* { dg-final { scan-assembler-times ""divl"" 1 } } */
","/* { dg-do compile } */
/* { dg-options ""-O2 -m8bit-idiv"" } */

extern void abort (void);

void
test (unsigned int x, unsigned int y, unsigned int q, unsigned int r)
{
  if ((x / y) != q || (x % y) != r)
    abort ();
}

/* { dg-final { scan-assembler-times ""divb"" 1 } } */
/* { dg-final { scan-assembler-times ""divl"" 1 } } */
"
"typedef struct {
  int a;
} VCR;

typedef struct {
  VCR vcr[8];
} VCRC;

typedef struct {
  char vcr;
} OWN;

OWN Own[16];

f (x, own)
  VCRC *x;
  OWN *own;
{
  x[own->vcr / 8].vcr[own->vcr % 8].a--;
  x[own->vcr / 8].vcr[own->vcr % 8].a = x[own->vcr / 8].vcr[own->vcr % 8].a;
}
","typedef struct {
  int a;
} VCR;

typedef struct {
  VCR vcr[8];
} VCRC;

typedef struct {
  char vcr;
} OWN;

OWN Own[16];

f (x, own)
  VCRC *x;
  OWN *own;
{
  x[own->vcr / 8].vcr[own->vcr % 8].a--;
  x[own->vcr / 8].vcr[own->vcr % 8].a = x[own->vcr / 8].vcr[own->vcr % 8].a;
}
"
"/* { dg-do compile } */
/* { dg-options ""-mavx512f -O2"" } */
/* { dg-final { scan-assembler-times ""vpternlogd\[ \\t\]+\[^\{\n\]*%zmm\[0-9\]+(?:\n|\[ \\t\]+#)""  1 } } */
/* { dg-final { scan-assembler-times ""vpternlogd\[ \\t\]+\[^\{\n\]*%zmm\[0-9\]+\{%k\[1-7\]\}(?:\n|\[ \\t\]+#)"" 1 } } */
/* { dg-final { scan-assembler-times ""vpternlogd\[ \\t\]+\[^\{\n\]*%zmm\[0-9\]+\{%k\[1-7\]\}\{z\}(?:\n|\[ \\t\]+#)"" 1 } } */

#include <immintrin.h>

volatile __m512i x, y, z;
volatile __mmask16 m;

void extern
avx512f_test (void)
{
  x = _mm512_ternarylogic_epi32 (x, y, z, 0xF0);
  x = _mm512_mask_ternarylogic_epi32 (x, m, y, z, 0xF0);
  x = _mm512_maskz_ternarylogic_epi32 (m, x, y, z, 0xF0);
}
","/* { dg-do compile } */
/* { dg-options ""-mavx512f -O2"" } */
/* { dg-final { scan-assembler-times ""vpternlogd\[ \\t\]+\[^\{\n\]*%zmm\[0-9\]+(?:\n|\[ \\t\]+#)""  1 } } */
/* { dg-final { scan-assembler-times ""vpternlogd\[ \\t\]+\[^\{\n\]*%zmm\[0-9\]+\{%k\[1-7\]\}(?:\n|\[ \\t\]+#)"" 1 } } */
/* { dg-final { scan-assembler-times ""vpternlogd\[ \\t\]+\[^\{\n\]*%zmm\[0-9\]+\{%k\[1-7\]\}\{z\}(?:\n|\[ \\t\]+#)"" 1 } } */

#include <immintrin.h>

volatile __m512i x, y, z;
volatile __mmask16 m;

void extern
avx512f_test (void)
{
  x = _mm512_ternarylogic_epi32 (x, y, z, 0xF0);
  x = _mm512_mask_ternarylogic_epi32 (x, m, y, z, 0xF0);
  x = _mm512_maskz_ternarylogic_epi32 (m, x, y, z, 0xF0);
}
"
"/* { dg-do compile } */

int i;
int a[2];

static inline char bar (void)
{
  return i ? i : 1;
}

void foo (int n)
{
  while (n--)
    {
      a[0] ^= bar ();
      a[1] ^= bar ();
    }
}

static inline char bar1 (void)
{
}

void foo1 (int n)
{
  while (n--)
    {
      a[0] ^= bar1 ();
      a[1] ^= bar1 ();
    }
}

","/* { dg-do compile } */

int i;
int a[2];

static inline char bar (void)
{
  return i ? i : 1;
}

void foo (int n)
{
  while (n--)
    {
      a[0] ^= bar ();
      a[1] ^= bar ();
    }
}

static inline char bar1 (void)
{
}

void foo1 (int n)
{
  while (n--)
    {
      a[0] ^= bar1 ();
      a[1] ^= bar1 ();
    }
}

"
"/* PR testsuite/52665
 * Make sure scan-assembler turns off .ident unless -fident in testcase */
/* { dg-do compile } */
/* { dg-options ""-fident"" } */
int i;

/* { dg-final { scan-assembler ""GCC: "" } } */
","/* PR testsuite/52665
 * Make sure scan-assembler turns off .ident unless -fident in testcase */
/* { dg-do compile } */
/* { dg-options ""-fident"" } */
int i;

/* { dg-final { scan-assembler ""GCC: "" } } */
"
"/* { dg-do compile } */
/* { dg-options ""-O3 -march=z900 -pg"" } */

int
foo ()
{
}
/* Make sure no stack frame is generated.  */
/* { dg-final { scan-assembler-not ""ahi"" { target s390-*-* } } } */
/* { dg-final { scan-assembler-not ""aghi"" { target s390x-*-* } } } */
","/* { dg-do compile } */
/* { dg-options ""-O3 -march=z900 -pg"" } */

int
foo ()
{
}
/* Make sure no stack frame is generated.  */
/* { dg-final { scan-assembler-not ""ahi"" { target s390-*-* } } } */
/* { dg-final { scan-assembler-not ""aghi"" { target s390x-*-* } } } */
"
"/* Test gcov weak ellision.  */

/* { dg-do run { target native } } */
/* { dg-options ""-fprofile-arcs -ftest-coverage"" } */
/* { dg-require-weak """" } */
/* { dg-additional-sources ""gcovpart-13b.c"" } */
/* { dg-skip-if ""weak ellision not supported"" { { hppa*-*-hpux* } && { ! lp64 } } } */

int __attribute__ ((weak)) weak ()
{
  return 1;  /* count(-) { xfail *-*-* } */
}

int main ()
{
  return weak (); /* count(1) */
}

/* { dg-final { run-gcov { -a gcov-13.c } { xfail *-*-* } } } */
/* { dg-final { run-gcov { -a gcovpart-13b.c } } } */
","/* Test gcov weak ellision.  */

/* { dg-do run { target native } } */
/* { dg-options ""-fprofile-arcs -ftest-coverage"" } */
/* { dg-require-weak """" } */
/* { dg-additional-sources ""gcovpart-13b.c"" } */
/* { dg-skip-if ""weak ellision not supported"" { { hppa*-*-hpux* } && { ! lp64 } } } */

int __attribute__ ((weak)) weak ()
{
  return 1;  /* count(-) { xfail *-*-* } */
}

int main ()
{
  return weak (); /* count(1) */
}

/* { dg-final { run-gcov { -a gcov-13.c } { xfail *-*-* } } } */
/* { dg-final { run-gcov { -a gcovpart-13b.c } } } */
"
"/* { dg-lto-do link } */
/* { dg-require-effective-target fpic } */
/* { dg-lto-options {{-fPIC -r -nostdlib -flto}} } */
/* { dg-extra-ld-options ""-flinker-output=nolto-rel"" } */

typedef struct {
    int NumPackStreams;
} CSzAr;
typedef struct {
    CSzAr db;
} CSzArEx;
int SzArEx_Init(CSzArEx *p)
{
  return p->db.NumPackStreams;
}
int SzArEx_GetFolderFullPackSize(const CSzArEx *p)
{
  return p->db.NumPackStreams;
}

","/* { dg-lto-do link } */
/* { dg-require-effective-target fpic } */
/* { dg-lto-options {{-fPIC -r -nostdlib -flto}} } */
/* { dg-extra-ld-options ""-flinker-output=nolto-rel"" } */

typedef struct {
    int NumPackStreams;
} CSzAr;
typedef struct {
    CSzAr db;
} CSzArEx;
int SzArEx_Init(CSzArEx *p)
{
  return p->db.NumPackStreams;
}
int SzArEx_GetFolderFullPackSize(const CSzArEx *p)
{
  return p->db.NumPackStreams;
}

"
"/* { dg-do compile } */
/* { dg-skip-if """" { ""*-*-*"" } { ""-mcpu=msp430"" ""-msmall"" } { """" } } */
/* { dg-options ""-mcpu=msp430x"" } */

typedef _Complex __int20 C;

C
foo (C x, C y)
{
  return x + y;
}
","/* { dg-do compile } */
/* { dg-skip-if """" { ""*-*-*"" } { ""-mcpu=msp430"" ""-msmall"" } { """" } } */
/* { dg-options ""-mcpu=msp430x"" } */

typedef _Complex __int20 C;

C
foo (C x, C y)
{
  return x + y;
}
"
"/* { dg-do compile } */
/* { dg-options ""-mavx2 -O2"" } */
/* { dg-final { scan-assembler ""vpackssdw\[ \\t\]+\[^\n\]*%ymm\[0-9\]"" } } */

#include <immintrin.h>

volatile __m256i x;

void extern
avx2_test (void)
{
  x = _mm256_packs_epi32 (x, x);
}
","/* { dg-do compile } */
/* { dg-options ""-mavx2 -O2"" } */
/* { dg-final { scan-assembler ""vpackssdw\[ \\t\]+\[^\n\]*%ymm\[0-9\]"" } } */

#include <immintrin.h>

volatile __m256i x;

void extern
avx2_test (void)
{
  x = _mm256_packs_epi32 (x, x);
}
"
"/* PR target/45336 */
/* { dg-do compile } */
/* { dg-options ""-O2 -msse4 -mtune=generic"" } */
/* { dg-final { scan-assembler-not ""movsbl"" } } */
/* { dg-final { scan-assembler-not ""movswl"" } } */
/* { dg-final { scan-assembler-not ""movzbl"" } } */
/* { dg-final { scan-assembler-not ""movzwl"" } } */
/* { dg-final { scan-assembler-not ""cwtl"" } } */
/* { dg-final { scan-assembler ""pextrb"" } } */
/* { dg-final { scan-assembler ""pextrw"" } } */
/* { dg-final { scan-assembler ""pextrd"" { target { ! x86_64-*-mingw* } } } } */

#include <smmintrin.h>
unsigned int foo8(__m128i x) { return _mm_extract_epi8(x, 4); }
unsigned int foo16(__m128i x) { return _mm_extract_epi16(x, 3); }
unsigned int foo32(__m128i x) { return _mm_extract_epi32(x, 2); }
","/* PR target/45336 */
/* { dg-do compile } */
/* { dg-options ""-O2 -msse4 -mtune=generic"" } */
/* { dg-final { scan-assembler-not ""movsbl"" } } */
/* { dg-final { scan-assembler-not ""movswl"" } } */
/* { dg-final { scan-assembler-not ""movzbl"" } } */
/* { dg-final { scan-assembler-not ""movzwl"" } } */
/* { dg-final { scan-assembler-not ""cwtl"" } } */
/* { dg-final { scan-assembler ""pextrb"" } } */
/* { dg-final { scan-assembler ""pextrw"" } } */
/* { dg-final { scan-assembler ""pextrd"" { target { ! x86_64-*-mingw* } } } } */

#include <smmintrin.h>
unsigned int foo8(__m128i x) { return _mm_extract_epi8(x, 4); }
unsigned int foo16(__m128i x) { return _mm_extract_epi16(x, 3); }
unsigned int foo32(__m128i x) { return _mm_extract_epi32(x, 2); }
"
"/* { dg-do link } */

int main (void) { return 0; }

/* { dg-final { output-exists-not { xfail *-*-* } } } */
","/* { dg-do link } */

int main (void) { return 0; }

/* { dg-final { output-exists-not { xfail *-*-* } } } */
"
"/* { dg-do run } */
/* { dg-options ""-march=x86-64 -mfma4 -mno-sse2"" } */

extern void abort (void);

int
main ()
{
#if !defined __SSE__
  abort ();
#endif
#if defined __SSE2__
  abort ();
#endif
#if defined __SSE3__
  abort ();
#endif
#if defined __SSSE3__
  abort ();
#endif
#if defined __SSE4_1__
  abort ();
#endif
#if defined __SSE4_2__
  abort ();
#endif
#if defined __SSE4A__
  abort ();
#endif
#if defined __FMA4__
  abort ();
#endif
  return 0;
}
","/* { dg-do run } */
/* { dg-options ""-march=x86-64 -mfma4 -mno-sse2"" } */

extern void abort (void);

int
main ()
{
#if !defined __SSE__
  abort ();
#endif
#if defined __SSE2__
  abort ();
#endif
#if defined __SSE3__
  abort ();
#endif
#if defined __SSSE3__
  abort ();
#endif
#if defined __SSE4_1__
  abort ();
#endif
#if defined __SSE4_2__
  abort ();
#endif
#if defined __SSE4A__
  abort ();
#endif
#if defined __FMA4__
  abort ();
#endif
  return 0;
}
"
"/* PR preprocessor/60570 */
/* { dg-do preprocess } */

#if 1
int i;
#elif 1/0
#endif

#if 1
int j;
#elif
#endif

#if 0
#elif 1/0	/* { dg-error ""division by zero"" } */
int k;
#endif

#if 0
#elif		/* { dg-error ""with no expression"" } */
int n;
#endif

#if 1
# if 1
int l;
# elif 1/0
# endif
#endif

#if 1
# if 1
int l;
# elif
# endif
#endif

#if 1
# if 0
# elif 1/0	/* { dg-error ""division by zero"" } */
# endif
#endif

#if 1
# if 0
# elif		/* { dg-error ""with no expression"" } */
# endif
#endif
","/* PR preprocessor/60570 */
/* { dg-do preprocess } */

#if 1
int i;
#elif 1/0
#endif

#if 1
int j;
#elif
#endif

#if 0
#elif 1/0	/* { dg-error ""division by zero"" } */
int k;
#endif

#if 0
#elif		/* { dg-error ""with no expression"" } */
int n;
#endif

#if 1
# if 1
int l;
# elif 1/0
# endif
#endif

#if 1
# if 1
int l;
# elif
# endif
#endif

#if 1
# if 0
# elif 1/0	/* { dg-error ""division by zero"" } */
# endif
#endif

#if 1
# if 0
# elif		/* { dg-error ""with no expression"" } */
# endif
#endif
"
"/* { dg-do compile { target i?86-*-* x86_64-*-* } } */
/* { dg-options ""-O2 -fdump-rtl-loop2_invariant"" } */
/* NOTE: The target list above could be extended to other targets that have
         conditional moves, but don't have zero registers.  */

enum test_type
{
  TYPE0,
  TYPE1
};

struct type_node
{
  enum test_type type;
};

struct test_ref
{
  struct type_node *referring;
};

struct test_node
{
  struct test_node *next;
};

int iterate (struct test_node *, unsigned, struct test_ref **);

int
loop_invar (struct test_node *node)
{
  struct test_ref *ref;

  for (unsigned i = 0; iterate (node, i, &ref); i++)
    if (loop_invar ((ref->referring && ref->referring->type == TYPE0)
                    ? ((struct test_node *) (ref->referring)) : 0))
      return 1;

  return 0;
}

/* { dg-final { scan-rtl-dump ""Decided to move invariant"" ""loop2_invariant"" } } */
","/* { dg-do compile { target i?86-*-* x86_64-*-* } } */
/* { dg-options ""-O2 -fdump-rtl-loop2_invariant"" } */
/* NOTE: The target list above could be extended to other targets that have
         conditional moves, but don't have zero registers.  */

enum test_type
{
  TYPE0,
  TYPE1
};

struct type_node
{
  enum test_type type;
};

struct test_ref
{
  struct type_node *referring;
};

struct test_node
{
  struct test_node *next;
};

int iterate (struct test_node *, unsigned, struct test_ref **);

int
loop_invar (struct test_node *node)
{
  struct test_ref *ref;

  for (unsigned i = 0; iterate (node, i, &ref); i++)
    if (loop_invar ((ref->referring && ref->referring->type == TYPE0)
                    ? ((struct test_node *) (ref->referring)) : 0))
      return 1;

  return 0;
}

/* { dg-final { scan-rtl-dump ""Decided to move invariant"" ""loop2_invariant"" } } */
"
"/* { dg-do run } */
/* { dg-require-effective-target sse4 } */
/* { dg-options ""-O2 -msse4.1"" } */

#ifndef CHECK_H
#define CHECK_H ""sse4_1-check.h""
#endif

#ifndef TEST
#define TEST sse4_1_test
#endif

#include CHECK_H

#include <smmintrin.h>

#define NUM 128

static void
TEST (void)
{
  union
    {
      __m128i x[NUM / 2];
      unsigned long long ll[NUM];
      unsigned short s[NUM * 4];
    } dst, src;
  int i;

  for (i = 0; i < NUM; i++)
    {
      src.s[(i % 2) + (i / 2) * 8] = i * i;
      if ((i % 2))
	src.s[(i % 2) + (i / 2) * 8] |= 0x8000;
    }

  for (i = 0; i < NUM; i += 2)
    dst.x [i / 2] = _mm_cvtepu16_epi64 (src.x [i / 2]);

  for (i = 0; i < NUM; i++)
    if (src.s[(i % 2) + (i / 2) * 8] != dst.ll[i])
      abort ();
}
","/* { dg-do run } */
/* { dg-require-effective-target sse4 } */
/* { dg-options ""-O2 -msse4.1"" } */

#ifndef CHECK_H
#define CHECK_H ""sse4_1-check.h""
#endif

#ifndef TEST
#define TEST sse4_1_test
#endif

#include CHECK_H

#include <smmintrin.h>

#define NUM 128

static void
TEST (void)
{
  union
    {
      __m128i x[NUM / 2];
      unsigned long long ll[NUM];
      unsigned short s[NUM * 4];
    } dst, src;
  int i;

  for (i = 0; i < NUM; i++)
    {
      src.s[(i % 2) + (i / 2) * 8] = i * i;
      if ((i % 2))
	src.s[(i % 2) + (i / 2) * 8] |= 0x8000;
    }

  for (i = 0; i < NUM; i += 2)
    dst.x [i / 2] = _mm_cvtepu16_epi64 (src.x [i / 2]);

  for (i = 0; i < NUM; i++)
    if (src.s[(i % 2) + (i / 2) * 8] != dst.ll[i])
      abort ();
}
"
"/* Test the `vextq_f64' AArch64 SIMD intrinsic.  */

/* { dg-do run } */
/* { dg-options ""-save-temps -O3 -fno-inline"" } */

#include ""arm_neon.h""
extern void abort (void);
#include <stdio.h>

float64x2_t
test_vextq_f64_1 (float64x2_t a, float64x2_t b)
{
  return vextq_f64 (a, b, 1);
}

int
main (int argc, char **argv)
{
  int i, off;
  float64_t arr1[] = {0, 1};
  float64x2_t in1 = vld1q_f64 (arr1);
  float64_t arr2[] = {2, 3};
  float64x2_t in2 = vld1q_f64 (arr2);
  float64_t exp[] = {1, 2};
  float64x2_t expected = vld1q_f64 (exp);
  float64x2_t actual = test_vextq_f64_1 (in1, in2);

  for (i = 0; i < 2; i++)
    if (actual[i] != expected[i])
      abort ();

  return 0;
}

/* { dg-final { scan-assembler-times ""ext\[ \t\]+\[vV\]\[0-9\]+\.16\[bB\], ?\[vV\]\[0-9\]+\.16\[bB\], ?\[vV\]\[0-9\]+\.16\[bB\], ?#\[0-9\]+\(?:.8\)?\(?:\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n"" 1 } } */
","/* Test the `vextq_f64' AArch64 SIMD intrinsic.  */

/* { dg-do run } */
/* { dg-options ""-save-temps -O3 -fno-inline"" } */

#include ""arm_neon.h""
extern void abort (void);
#include <stdio.h>

float64x2_t
test_vextq_f64_1 (float64x2_t a, float64x2_t b)
{
  return vextq_f64 (a, b, 1);
}

int
main (int argc, char **argv)
{
  int i, off;
  float64_t arr1[] = {0, 1};
  float64x2_t in1 = vld1q_f64 (arr1);
  float64_t arr2[] = {2, 3};
  float64x2_t in2 = vld1q_f64 (arr2);
  float64_t exp[] = {1, 2};
  float64x2_t expected = vld1q_f64 (exp);
  float64x2_t actual = test_vextq_f64_1 (in1, in2);

  for (i = 0; i < 2; i++)
    if (actual[i] != expected[i])
      abort ();

  return 0;
}

/* { dg-final { scan-assembler-times ""ext\[ \t\]+\[vV\]\[0-9\]+\.16\[bB\], ?\[vV\]\[0-9\]+\.16\[bB\], ?\[vV\]\[0-9\]+\.16\[bB\], ?#\[0-9\]+\(?:.8\)?\(?:\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n"" 1 } } */
"
"/* { dg-do compile { target *-*-linux* } } */
/* { dg-options ""-O2 -fpic"" } */

/* Common symbol with -fpic.  */
__attribute__((visibility(""protected"")))
int xxx;

int
foo ()
{
  return xxx;
}

/* { dg-final { scan-assembler-not ""xxx\\(%rip\\)"" { target { ! ia32 } } } } */
/* { dg-final { scan-assembler ""xxx@GOTPCREL"" { target { ! ia32 } } } } */
/* { dg-final { scan-assembler-not ""xxx@GOTOFF"" { target ia32 } } } */
/* { dg-final { scan-assembler ""xxx@GOT\\("" { target ia32 } } } */
","/* { dg-do compile { target *-*-linux* } } */
/* { dg-options ""-O2 -fpic"" } */

/* Common symbol with -fpic.  */
__attribute__((visibility(""protected"")))
int xxx;

int
foo ()
{
  return xxx;
}

/* { dg-final { scan-assembler-not ""xxx\\(%rip\\)"" { target { ! ia32 } } } } */
/* { dg-final { scan-assembler ""xxx@GOTPCREL"" { target { ! ia32 } } } } */
/* { dg-final { scan-assembler-not ""xxx@GOTOFF"" { target ia32 } } } */
/* { dg-final { scan-assembler ""xxx@GOT\\("" { target ia32 } } } */
"
"/* { dg-do compile } */
/* { dg-options ""-O2 -fopenmp -fdump-tree-gimple"" } */

void __attribute__((noinline))
baz (int *p)
{
}

void
foo (void)
{
  int p[2];
  p[0] = 1;
  p[1] = 3;
  #pragma omp task firstprivate (p)
    baz (p);
}

/* Check that new function does not end up in gimple dump.  */
/* { dg-final { scan-tree-dump-not ""foo\\._omp_cpyfn\\.1 \\(struct"" ""gimple"" } } */
","/* { dg-do compile } */
/* { dg-options ""-O2 -fopenmp -fdump-tree-gimple"" } */

void __attribute__((noinline))
baz (int *p)
{
}

void
foo (void)
{
  int p[2];
  p[0] = 1;
  p[1] = 3;
  #pragma omp task firstprivate (p)
    baz (p);
}

/* Check that new function does not end up in gimple dump.  */
/* { dg-final { scan-tree-dump-not ""foo\\._omp_cpyfn\\.1 \\(struct"" ""gimple"" } } */
"
"/* Test that we generate aligned load when memory is aligned.  */
/* { dg-do compile } */
/* { dg-options ""-O -mavx -mtune=generic"" } */
/* { dg-final { scan-assembler-not ""movups"" } } */
/* { dg-final { scan-assembler ""movaps"" } } */

typedef float v8sf __attribute__ ((__vector_size__ (32)));

extern void foo (v8sf, v8sf, v8sf, v8sf, v8sf, v8sf, v8sf, v8sf, v8sf);

int
test (void)
{
  v8sf x = { 0.0, 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0 };

  foo (x, x, x, x, x, x, x, x, x);
  return 0;
}
","/* Test that we generate aligned load when memory is aligned.  */
/* { dg-do compile } */
/* { dg-options ""-O -mavx -mtune=generic"" } */
/* { dg-final { scan-assembler-not ""movups"" } } */
/* { dg-final { scan-assembler ""movaps"" } } */

typedef float v8sf __attribute__ ((__vector_size__ (32)));

extern void foo (v8sf, v8sf, v8sf, v8sf, v8sf, v8sf, v8sf, v8sf, v8sf);

int
test (void)
{
  v8sf x = { 0.0, 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0 };

  foo (x, x, x, x, x, x, x, x, x);
  return 0;
}
"
"/* { dg-do run } */
/* { dg-require-effective-target avx } */
/* { dg-options ""-O2 -mavx -fno-strict-aliasing"" } */

#define CHECK_H ""avx-check.h""
#define TEST avx_test

#include ""ssse3-phaddw.c""
","/* { dg-do run } */
/* { dg-require-effective-target avx } */
/* { dg-options ""-O2 -mavx -fno-strict-aliasing"" } */

#define CHECK_H ""avx-check.h""
#define TEST avx_test

#include ""ssse3-phaddw.c""
"
"/* PR tree-optimization/83559 - -Wsuggest-attribute=const conflicts with
   -Wattributes warning about const attribute on function returning void
   { dg-do compile { target nonpic } }
   { dg-options ""-O2 -Wsuggest-attribute=const"" } */

int f_i_v (void)    /* { dg-warning ""candidate for attribute .const."" } */
{
  return 0;
}

int f_i ()          /* { dg-warning ""candidate for attribute .const."" } */
{
  return 0;
}

void f_v_v (void)   /* { dg-bogus ""candidate"" } */
{
}

void f_v ()         /* { dg-bogus ""candidate"" } */
{
}
","/* PR tree-optimization/83559 - -Wsuggest-attribute=const conflicts with
   -Wattributes warning about const attribute on function returning void
   { dg-do compile { target nonpic } }
   { dg-options ""-O2 -Wsuggest-attribute=const"" } */

int f_i_v (void)    /* { dg-warning ""candidate for attribute .const."" } */
{
  return 0;
}

int f_i ()          /* { dg-warning ""candidate for attribute .const."" } */
{
  return 0;
}

void f_v_v (void)   /* { dg-bogus ""candidate"" } */
{
}

void f_v ()         /* { dg-bogus ""candidate"" } */
{
}
"
"/* { dg-require-effective-target vect_int } */

#include ""tree-vect.h""

int x[1024], y[1024], z[1024];

int __attribute__((noinline,noclone))
foo (int n)
{
  int sum = 0;
  /* Can vectorize this.  */
  for (int i = 0; i < n; ++i)
    sum = (y[i] - (x[i] - sum));
  return sum;
}

int __attribute__((noinline,noclone))
bar (int n)
{
  int sum = 0;
  /* Cannot vectorize this, sum is negated.  */
  for (int i = 0; i < n; ++i)
    sum = z[i] - (y[i] - (x[i] - sum));
  return sum;
}

int
main()
{
  check_vect ();
  for (int i = 0; i < 1024; ++i)
    {
      x[i] = i;
      y[i] = i + 1;
      z[i] = 0;
      __asm__ volatile ("""" : : : ""memory"");
    }
  if (foo (1024) != 1024)
    __builtin_abort ();
  if (bar (1023) != -1 || bar (1024) != 0)
    __builtin_abort ();
  return 0;
}

/* { dg-final { scan-tree-dump-times ""vectorized 1 loops"" 1 ""vect"" } } */
","/* { dg-require-effective-target vect_int } */

#include ""tree-vect.h""

int x[1024], y[1024], z[1024];

int __attribute__((noinline,noclone))
foo (int n)
{
  int sum = 0;
  /* Can vectorize this.  */
  for (int i = 0; i < n; ++i)
    sum = (y[i] - (x[i] - sum));
  return sum;
}

int __attribute__((noinline,noclone))
bar (int n)
{
  int sum = 0;
  /* Cannot vectorize this, sum is negated.  */
  for (int i = 0; i < n; ++i)
    sum = z[i] - (y[i] - (x[i] - sum));
  return sum;
}

int
main()
{
  check_vect ();
  for (int i = 0; i < 1024; ++i)
    {
      x[i] = i;
      y[i] = i + 1;
      z[i] = 0;
      __asm__ volatile ("""" : : : ""memory"");
    }
  if (foo (1024) != 1024)
    __builtin_abort ();
  if (bar (1023) != -1 || bar (1024) != 0)
    __builtin_abort ();
  return 0;
}

/* { dg-final { scan-tree-dump-times ""vectorized 1 loops"" 1 ""vect"" } } */
"
"/* { dg-do run } */
/* { dg-options ""-O2 -mavx512bw -mavx512vl"" } */
/* { dg-require-effective-target avx512vl } */
/* { dg-require-effective-target avx512bw } */

#define AVX512VL
#define AVX512F_LEN 256
#define AVX512F_LEN_HALF 128
#include ""avx512bw-vpcmpltb-2.c""

#undef AVX512F_LEN
#undef AVX512F_LEN_HALF

#define AVX512F_LEN 128
#define AVX512F_LEN_HALF 128
#include ""avx512bw-vpcmpltb-2.c""
","/* { dg-do run } */
/* { dg-options ""-O2 -mavx512bw -mavx512vl"" } */
/* { dg-require-effective-target avx512vl } */
/* { dg-require-effective-target avx512bw } */

#define AVX512VL
#define AVX512F_LEN 256
#define AVX512F_LEN_HALF 128
#include ""avx512bw-vpcmpltb-2.c""

#undef AVX512F_LEN
#undef AVX512F_LEN_HALF

#define AVX512F_LEN 128
#define AVX512F_LEN_HALF 128
#include ""avx512bw-vpcmpltb-2.c""
"
"/* { dg-do run }  */
/* { dg-require-ifunc """" } */
/* { dg-options """" } */

#include <stdio.h>

static int implementation (void)
{
  printf (""'ere I am JH\n"");
  return 0;
}

static __typeof__ (implementation)* resolver (void)
{
  return (void *)implementation;
}

extern int magic (void) __attribute__ ((ifunc (""resolver""),visibility (""hidden"")));

int main ()
{
  return magic () != 0;
}
","/* { dg-do run }  */
/* { dg-require-ifunc """" } */
/* { dg-options """" } */

#include <stdio.h>

static int implementation (void)
{
  printf (""'ere I am JH\n"");
  return 0;
}

static __typeof__ (implementation)* resolver (void)
{
  return (void *)implementation;
}

extern int magic (void) __attribute__ ((ifunc (""resolver""),visibility (""hidden"")));

int main ()
{
  return magic () != 0;
}
"
"/* { dg-do run } */
/* { dg-options ""-O2 -fno-inline --save-temps"" } */

extern long long llabs (long long);
extern void abort (void);

long long
abs64 (long long a)
{
  /* { dg-final { scan-assembler ""csneg\t"" } } */
  return llabs (a);
}

long long
abs64_in_dreg (long long a)
{
  /* { dg-final { scan-assembler ""csneg\t"" } } */
  register long long x asm (""d8"") = a;
  register long long y asm (""d9"");
  asm volatile ("""" : : ""w"" (x));
  y = llabs (x);
  asm volatile ("""" : : ""w"" (y));
  return y;
}

int
main (void)
{
  volatile long long ll0 = 0LL, ll1 = 1LL, llm1 = -1LL;

  if (abs64 (ll0) != 0LL)
    abort ();

  if (abs64 (ll1) != 1LL)
    abort ();

  if (abs64 (llm1) != 1LL)
    abort ();

  if (abs64_in_dreg (ll0) != 0LL)
    abort ();

  if (abs64_in_dreg (ll1) != 1LL)
    abort ();

  if (abs64_in_dreg (llm1) != 1LL)
    abort ();

  return 0;
}

","/* { dg-do run } */
/* { dg-options ""-O2 -fno-inline --save-temps"" } */

extern long long llabs (long long);
extern void abort (void);

long long
abs64 (long long a)
{
  /* { dg-final { scan-assembler ""csneg\t"" } } */
  return llabs (a);
}

long long
abs64_in_dreg (long long a)
{
  /* { dg-final { scan-assembler ""csneg\t"" } } */
  register long long x asm (""d8"") = a;
  register long long y asm (""d9"");
  asm volatile ("""" : : ""w"" (x));
  y = llabs (x);
  asm volatile ("""" : : ""w"" (y));
  return y;
}

int
main (void)
{
  volatile long long ll0 = 0LL, ll1 = 1LL, llm1 = -1LL;

  if (abs64 (ll0) != 0LL)
    abort ();

  if (abs64 (ll1) != 1LL)
    abort ();

  if (abs64 (llm1) != 1LL)
    abort ();

  if (abs64_in_dreg (ll0) != 0LL)
    abort ();

  if (abs64_in_dreg (ll1) != 1LL)
    abort ();

  if (abs64_in_dreg (llm1) != 1LL)
    abort ();

  return 0;
}

"
"/* { dg-options ""-fno-tree-scev-cprop -fgraphite-identity -O -fdump-tree-graphite-all"" } */

void bar (void);

int toto()
{
  int i, j, k;
  int a[101][100];
  int b[100];

  for (i = 1; i < 100; i++)
    {
      for (j = 1; j < 100; j++)
	for (k = 1; k < 100; k++)
	  a[j][k] = a[j+1][i-1] + 2;

      b[i] = b[i-1] + 2;

      bar ();

      for (j = 1; j < 100; j++)
	a[j][i] = a[j+1][i-1] + 2;

      b[i] = b[i-1] + 2;

      bar ();

      for (j = 1; j < 100; j++)
	a[j][i] = a[j+1][i-1] + 2;

      b[i] = a[i-1][i] + 2;

      for (j = 1; j < 100; j++)
	a[j][i] = a[j+1][i-1] + 2;
    }

  return a[3][5] + b[1];
}

/* { dg-final { scan-tree-dump-times ""number of SCoPs: 2"" 1 ""graphite""} } */
","/* { dg-options ""-fno-tree-scev-cprop -fgraphite-identity -O -fdump-tree-graphite-all"" } */

void bar (void);

int toto()
{
  int i, j, k;
  int a[101][100];
  int b[100];

  for (i = 1; i < 100; i++)
    {
      for (j = 1; j < 100; j++)
	for (k = 1; k < 100; k++)
	  a[j][k] = a[j+1][i-1] + 2;

      b[i] = b[i-1] + 2;

      bar ();

      for (j = 1; j < 100; j++)
	a[j][i] = a[j+1][i-1] + 2;

      b[i] = b[i-1] + 2;

      bar ();

      for (j = 1; j < 100; j++)
	a[j][i] = a[j+1][i-1] + 2;

      b[i] = a[i-1][i] + 2;

      for (j = 1; j < 100; j++)
	a[j][i] = a[j+1][i-1] + 2;
    }

  return a[3][5] + b[1];
}

/* { dg-final { scan-tree-dump-times ""number of SCoPs: 2"" 1 ""graphite""} } */
"
"/* { dg-do preprocess } */
#if 0xe-1	/* { dg-error ""invalid suffix"" } */
#endif
","/* { dg-do preprocess } */
#if 0xe-1	/* { dg-error ""invalid suffix"" } */
#endif
"
"/* { dg-do compile { target { lp64 } } } */
/* { dg-options ""-pg -mnop-mcount"" } */

void
profileme (void)
{
  /* { dg-final { scan-assembler ""NOPs for -mnop-mcount \\(12 halfwords\\)\n.*brcl\t0,0\n.*brcl\t0,0\n.*brcl\t0,0\n.*brcl\t0,0"" } } */
}
","/* { dg-do compile { target { lp64 } } } */
/* { dg-options ""-pg -mnop-mcount"" } */

void
profileme (void)
{
  /* { dg-final { scan-assembler ""NOPs for -mnop-mcount \\(12 halfwords\\)\n.*brcl\t0,0\n.*brcl\t0,0\n.*brcl\t0,0\n.*brcl\t0,0"" } } */
}
"
"/* { dg-do compile } */
/* { dg-options ""-O2"" } */

double
foo (unsigned int x)
{
  return (double) (float) (x & 0xffffff00);
}

/* { dg-final { scan-assembler {\tucvtf\td0, w[0-9]*} } } */
","/* { dg-do compile } */
/* { dg-options ""-O2"" } */

double
foo (unsigned int x)
{
  return (double) (float) (x & 0xffffff00);
}

/* { dg-final { scan-assembler {\tucvtf\td0, w[0-9]*} } } */
"
"/* PR rtl-optimization/23098 */
/* { dg-do compile } */
/* { dg-options ""-O2 -fPIC"" } */
/* { dg-final { scan-assembler-not ""\.LC\[0-9\]"" } } */
/* { dg-require-effective-target ia32 } */
/* { dg-require-effective-target fpic } */

double foo (float);

double
f1 (void)
{
  return foo (1.0);
}

double
f2 (void)
{
  return foo (0.0);
}

void
f3 (float *x, float t)
{
  *x = 0.0 + t;
}
","/* PR rtl-optimization/23098 */
/* { dg-do compile } */
/* { dg-options ""-O2 -fPIC"" } */
/* { dg-final { scan-assembler-not ""\.LC\[0-9\]"" } } */
/* { dg-require-effective-target ia32 } */
/* { dg-require-effective-target fpic } */

double foo (float);

double
f1 (void)
{
  return foo (1.0);
}

double
f2 (void)
{
  return foo (0.0);
}

void
f3 (float *x, float t)
{
  *x = 0.0 + t;
}
"
"/* PR tree-optimization/17506
   We issue an uninitialized variable warning at a wrong location at
   line 11, which is very confusing.  Make sure we print out a note to
   make it less confusing.  (not xfailed alternative)
   But it is of course ok if we warn in bar about uninitialized use
   of j.  (xfailed alternative)  */
/* { dg-do compile } */
/* { dg-options ""-O1 -Wuninitialized"" } */

inline int
foo (int i)
{
  if (i) /* { dg-warning ""used uninitialized in this function"" } */
    return 1;
  return 0;
}

void baz (void);

void
bar (void)
{
  int j; /* { dg-message ""note: 'j' was declared here"" } */
  for (; foo (j); ++j)  /* { dg-warning ""'j' is used uninitialized"" """" { xfail *-*-* } } */
    baz ();
}
","/* PR tree-optimization/17506
   We issue an uninitialized variable warning at a wrong location at
   line 11, which is very confusing.  Make sure we print out a note to
   make it less confusing.  (not xfailed alternative)
   But it is of course ok if we warn in bar about uninitialized use
   of j.  (xfailed alternative)  */
/* { dg-do compile } */
/* { dg-options ""-O1 -Wuninitialized"" } */

inline int
foo (int i)
{
  if (i) /* { dg-warning ""used uninitialized in this function"" } */
    return 1;
  return 0;
}

void baz (void);

void
bar (void)
{
  int j; /* { dg-message ""note: 'j' was declared here"" } */
  for (; foo (j); ++j)  /* { dg-warning ""'j' is used uninitialized"" """" { xfail *-*-* } } */
    baz ();
}
"
"/* { dg-do run } */
/* { dg-options ""-O -fno-tree-fre -fdump-tree-dom2"" } */

extern void abort (void);

int a;
int __attribute__((noinline))
foo (int b)
{
  a = 0;
  if (b)
    {
      a = 1;
      return a;
    }
  /* DOM should be able to CSE both loads here, forwarding 0 and 1
     to the PHI feeding the return.  */
  return a;
}

int
main()
{
  if (foo (0) != 0
      || foo (1) != 1)
    abort ();
  return 0;
}

/* { dg-final { scan-tree-dump ""= PHI <\[01\]\\\(.\\\), \[01\]\\\(.\\\)>"" ""dom2"" } } */
","/* { dg-do run } */
/* { dg-options ""-O -fno-tree-fre -fdump-tree-dom2"" } */

extern void abort (void);

int a;
int __attribute__((noinline))
foo (int b)
{
  a = 0;
  if (b)
    {
      a = 1;
      return a;
    }
  /* DOM should be able to CSE both loads here, forwarding 0 and 1
     to the PHI feeding the return.  */
  return a;
}

int
main()
{
  if (foo (0) != 0
      || foo (1) != 1)
    abort ();
  return 0;
}

/* { dg-final { scan-tree-dump ""= PHI <\[01\]\\\(.\\\), \[01\]\\\(.\\\)>"" ""dom2"" } } */
"
"
/* { dg-do run } */
/* { dg-options ""-O3"" } */

#include ""arm_neon.h""

extern void abort (void);

#include ""vaddv-intrinsic.x""

int
main (void)
{
  const float32_t pool_v2sf[] = {4.0f, 9.0f};
  const float32_t pool_v4sf[] = {4.0f, 9.0f, 16.0f, 25.0f};
  const float64_t pool_v2df[] = {4.0, 9.0};

  if (test_vaddv_v2sf (pool_v2sf) != 13.0f)
    abort ();

  if (test_vaddv_v4sf (pool_v4sf) != 54.0f)
    abort ();

  if (test_vaddv_v2df (pool_v2df) != 13.0)
    abort ();

  return 0;
}
","
/* { dg-do run } */
/* { dg-options ""-O3"" } */

#include ""arm_neon.h""

extern void abort (void);

#include ""vaddv-intrinsic.x""

int
main (void)
{
  const float32_t pool_v2sf[] = {4.0f, 9.0f};
  const float32_t pool_v4sf[] = {4.0f, 9.0f, 16.0f, 25.0f};
  const float64_t pool_v2df[] = {4.0, 9.0};

  if (test_vaddv_v2sf (pool_v2sf) != 13.0f)
    abort ();

  if (test_vaddv_v4sf (pool_v4sf) != 54.0f)
    abort ();

  if (test_vaddv_v2df (pool_v2df) != 13.0)
    abort ();

  return 0;
}
"
"/* { dg-require-effective-target vect_condition } */
/* { dg-require-effective-target vect_int } */

#include <stdarg.h>
#include ""tree-vect.h""

#define N 16
#define MAX 42

int A[N] = {36,39,42,45,43,32,21,12,23,34,45,56,67,78,89,11};
int B[N] = {42,42,42,0,0,42,42,42,42,42,0,0,0,0,0,42};

extern void abort(void); 

int main ()
{  
  int i, j;

  check_vect ();

  for (i = 0; i < 16; i++)
    A[i] = ( A[i] <= MAX ? MAX : 0); 

  /* check results:  */
  for (i = 0; i < N; i++)
    if (A[i] != B[i])
      abort ();

  return 0;
}



/* { dg-final { scan-tree-dump-times ""vectorized 1 loops"" 1 ""vect"" } } */
","/* { dg-require-effective-target vect_condition } */
/* { dg-require-effective-target vect_int } */

#include <stdarg.h>
#include ""tree-vect.h""

#define N 16
#define MAX 42

int A[N] = {36,39,42,45,43,32,21,12,23,34,45,56,67,78,89,11};
int B[N] = {42,42,42,0,0,42,42,42,42,42,0,0,0,0,0,42};

extern void abort(void); 

int main ()
{  
  int i, j;

  check_vect ();

  for (i = 0; i < 16; i++)
    A[i] = ( A[i] <= MAX ? MAX : 0); 

  /* check results:  */
  for (i = 0; i < N; i++)
    if (A[i] != B[i])
      abort ();

  return 0;
}



/* { dg-final { scan-tree-dump-times ""vectorized 1 loops"" 1 ""vect"" } } */
"
"/* { dg-additional-options ""-O3"" } */

#include <stdlib.h>

int a;
int c;
__attribute__((noinline, noclone)) void foo (int x)
{
  if (x == 0)
    c++;
}

int
main (int argc, char* argv[])
{
  int j, k, b = 0;
  if (argc == 0)
    b = 1;
  for (j = 0; j < 3; j++)
    for (k = 0; k < 1; k++)
      {
	foo (0);
	if (b)
	  for (k = -1; a;)
	    ;
      }
  if (c != 3)
    abort ();
  return 0;
}
","/* { dg-additional-options ""-O3"" } */

#include <stdlib.h>

int a;
int c;
__attribute__((noinline, noclone)) void foo (int x)
{
  if (x == 0)
    c++;
}

int
main (int argc, char* argv[])
{
  int j, k, b = 0;
  if (argc == 0)
    b = 1;
  for (j = 0; j < 3; j++)
    for (k = 0; k < 1; k++)
      {
	foo (0);
	if (b)
	  for (k = -1; a;)
	    ;
      }
  if (c != 3)
    abort ();
  return 0;
}
"
"/* { dg-do compile } */
/* { dg-options ""-mavx512f -O2"" } */
/* { dg-final { scan-assembler-times ""vinserti32x4\[^\{\n\]+zmm\[0-9\](?:\n|\[ \\t\]+#)"" 1 } } */
/* { dg-final { scan-assembler-times ""vinserti32x4\[^\{\n\]*zmm\[0-9\]\{%k\[1-7\]\}\{z\}(?:\n|\[ \\t\]+#)"" 1 } } */
/* { dg-final { scan-assembler-times ""vinserti32x4\[^\{\n\]*\{%k\[1-7\]\}(?:\n|\[ \\t\]+#)"" 1 } } */

#include <immintrin.h>

volatile __m512i x,a;
volatile __m128i y;

void extern
avx512f_test (void)
{
  x = _mm512_maskz_inserti32x4 (6, x, y, 1);
  x = _mm512_mask_inserti32x4 (a, 6, x, y, 1);
  x = _mm512_inserti32x4 (x, y, 1);
}
","/* { dg-do compile } */
/* { dg-options ""-mavx512f -O2"" } */
/* { dg-final { scan-assembler-times ""vinserti32x4\[^\{\n\]+zmm\[0-9\](?:\n|\[ \\t\]+#)"" 1 } } */
/* { dg-final { scan-assembler-times ""vinserti32x4\[^\{\n\]*zmm\[0-9\]\{%k\[1-7\]\}\{z\}(?:\n|\[ \\t\]+#)"" 1 } } */
/* { dg-final { scan-assembler-times ""vinserti32x4\[^\{\n\]*\{%k\[1-7\]\}(?:\n|\[ \\t\]+#)"" 1 } } */

#include <immintrin.h>

volatile __m512i x,a;
volatile __m128i y;

void extern
avx512f_test (void)
{
  x = _mm512_maskz_inserti32x4 (6, x, y, 1);
  x = _mm512_mask_inserti32x4 (a, 6, x, y, 1);
  x = _mm512_inserti32x4 (x, y, 1);
}
"
"struct a {
    char b[100];
};
int foo(struct a *a)
{
  if (&a->b)
    return 1;
  return 0;
}
extern void abort (void);
int main()
{
  if (foo((struct a *)0) != 0)
    abort ();
  return 0;
}
","struct a {
    char b[100];
};
int foo(struct a *a)
{
  if (&a->b)
    return 1;
  return 0;
}
extern void abort (void);
int main()
{
  if (foo((struct a *)0) != 0)
    abort ();
  return 0;
}
"
"/* { dg-do compile { target { powerpc64*-*-* && lp64 } } } */
/* { dg-skip-if ""do not override -mcpu"" { powerpc*-*-* } { ""-mcpu=*"" } { ""-mcpu=power8"" } } */
/* { dg-require-effective-target powerpc_p8vector_ok } */
/* { dg-options ""-mcpu=power8 -O2"" } */

vector int
merge (int a, int b, int c, int d)
{
  return (vector int) { a, b, c, d };
}

/* { dg-final { scan-assembler     ""rldicr"" } } */
/* { dg-final { scan-assembler     ""rldicl"" } } */
/* { dg-final { scan-assembler     ""mtvsrd"" } } */
/* { dg-final { scan-assembler-not ""stw""    } } */
/* { dg-final { scan-assembler-not ""lxvw4x"" } } */
","/* { dg-do compile { target { powerpc64*-*-* && lp64 } } } */
/* { dg-skip-if ""do not override -mcpu"" { powerpc*-*-* } { ""-mcpu=*"" } { ""-mcpu=power8"" } } */
/* { dg-require-effective-target powerpc_p8vector_ok } */
/* { dg-options ""-mcpu=power8 -O2"" } */

vector int
merge (int a, int b, int c, int d)
{
  return (vector int) { a, b, c, d };
}

/* { dg-final { scan-assembler     ""rldicr"" } } */
/* { dg-final { scan-assembler     ""rldicl"" } } */
/* { dg-final { scan-assembler     ""mtvsrd"" } } */
/* { dg-final { scan-assembler-not ""stw""    } } */
/* { dg-final { scan-assembler-not ""lxvw4x"" } } */
"
"/* { dg-do run } */
/* { dg-options ""-O2 -mavx512dq -mavx512vl"" } */
/* { dg-require-effective-target avx512vl } */
/* { dg-require-effective-target avx512dq } */

#define AVX512VL
#define AVX512F_LEN 256
#define AVX512F_LEN_HALF 128
#include ""avx512dq-vcvttps2uqq-2.c""

#undef AVX512F_LEN
#undef AVX512F_LEN_HALF

#define AVX512F_LEN 128
#define AVX512F_LEN_HALF 128
#include ""avx512dq-vcvttps2uqq-2.c""
","/* { dg-do run } */
/* { dg-options ""-O2 -mavx512dq -mavx512vl"" } */
/* { dg-require-effective-target avx512vl } */
/* { dg-require-effective-target avx512dq } */

#define AVX512VL
#define AVX512F_LEN 256
#define AVX512F_LEN_HALF 128
#include ""avx512dq-vcvttps2uqq-2.c""

#undef AVX512F_LEN
#undef AVX512F_LEN_HALF

#define AVX512F_LEN 128
#define AVX512F_LEN_HALF 128
#include ""avx512dq-vcvttps2uqq-2.c""
"
"/* { dg-do compile } */
/* { dg-options ""-O2 -ftree-vectorize -ffast-math"" } */

#define REDUC(TYPE)						\
  TYPE reduc_##TYPE (TYPE *x, TYPE *y, int count)		\
  {								\
    TYPE sum = 0;						\
    for (int i = 0; i < count; ++i)				\
      sum += x[i] * y[i];					\
    return sum;							\
  }

REDUC (float)
REDUC (double)

/* { dg-final { scan-assembler-times {\tfmla\tz[0-9]+\.s, p[0-7]/m} 1 } } */
/* { dg-final { scan-assembler-times {\tfmla\tz[0-9]+\.d, p[0-7]/m} 1 } } */
","/* { dg-do compile } */
/* { dg-options ""-O2 -ftree-vectorize -ffast-math"" } */

#define REDUC(TYPE)						\
  TYPE reduc_##TYPE (TYPE *x, TYPE *y, int count)		\
  {								\
    TYPE sum = 0;						\
    for (int i = 0; i < count; ++i)				\
      sum += x[i] * y[i];					\
    return sum;							\
  }

REDUC (float)
REDUC (double)

/* { dg-final { scan-assembler-times {\tfmla\tz[0-9]+\.s, p[0-7]/m} 1 } } */
/* { dg-final { scan-assembler-times {\tfmla\tz[0-9]+\.d, p[0-7]/m} 1 } } */
"
"/* { dg-do compile } */
/* { dg-options ""-O2 -fno-omit-frame-pointer"" } */

struct foo
{
  int head;
} a;

int
bar (void)
{
  return a.head != 0;
}

/* No need to use a frame pointer.  */
/* { dg-final { scan-assembler-not ""%\[re\]bp"" } } */
","/* { dg-do compile } */
/* { dg-options ""-O2 -fno-omit-frame-pointer"" } */

struct foo
{
  int head;
} a;

int
bar (void)
{
  return a.head != 0;
}

/* No need to use a frame pointer.  */
/* { dg-final { scan-assembler-not ""%\[re\]bp"" } } */
"
"/* PR c/45079 */
/* { dg-do compile } */

void
foo (const char *p, int cond, int a, int b)
{
  p[cond ? a : b] = '\0';	/* { dg-error ""assignment of read-only location"" } */
}

/* { dg-bogus ""not supported by"" """" { target *-*-* } 0 } */
","/* PR c/45079 */
/* { dg-do compile } */

void
foo (const char *p, int cond, int a, int b)
{
  p[cond ? a : b] = '\0';	/* { dg-error ""assignment of read-only location"" } */
}

/* { dg-bogus ""not supported by"" """" { target *-*-* } 0 } */
"
"/* Verify that overloaded built-ins for vec_pack with int
   inputs produce the right results.  */

/* { dg-do compile } */
/* { dg-require-effective-target powerpc_altivec_ok } */
/* { dg-options ""-maltivec -O2"" } */

#include <altivec.h>

vector bool short
testbi_h (vector bool int vbi2, vector bool int vbi3)
{
  return vec_pack (vbi2, vbi3);
}

vector signed short
testsi_h (vector signed int vsi2, vector signed int vsi3)
{
  return vec_pack (vsi2, vsi3);
}

vector unsigned short
testui_h (vector unsigned int vui2, vector unsigned int vui3)
{
  return vec_pack (vui2, vui3);
}

/* { dg-final { scan-assembler-times ""vpkuwum"" 3 } } */
","/* Verify that overloaded built-ins for vec_pack with int
   inputs produce the right results.  */

/* { dg-do compile } */
/* { dg-require-effective-target powerpc_altivec_ok } */
/* { dg-options ""-maltivec -O2"" } */

#include <altivec.h>

vector bool short
testbi_h (vector bool int vbi2, vector bool int vbi3)
{
  return vec_pack (vbi2, vbi3);
}

vector signed short
testsi_h (vector signed int vsi2, vector signed int vsi3)
{
  return vec_pack (vsi2, vsi3);
}

vector unsigned short
testui_h (vector unsigned int vui2, vector unsigned int vui3)
{
  return vec_pack (vui2, vui3);
}

/* { dg-final { scan-assembler-times ""vpkuwum"" 3 } } */
"
"/* { dg-do compile } */
/* { dg-options ""-O2 -Wstrict-aliasing -fstrict-aliasing"" } */


int foo ()
{
  int x = 10;
  int *p;
  float *q;

  q = (float*) &x;  /* { dg-bogus ""not referenced"" } */

  return x;
}
","/* { dg-do compile } */
/* { dg-options ""-O2 -Wstrict-aliasing -fstrict-aliasing"" } */


int foo ()
{
  int x = 10;
  int *p;
  float *q;

  q = (float*) &x;  /* { dg-bogus ""not referenced"" } */

  return x;
}
"
"/* Verify that overloaded built-ins for vec_splat with float and
   double inputs produce the right code.  */

/* { dg-do compile } */
/* { dg-require-effective-target powerpc_vsx_ok } */
/* { dg-options ""-mvsx -O2"" } */

#include <altivec.h>

vector double
testd_l (vector double vd2, vector double vd3)
{
  return vec_mergel (vd2, vd3);
}

vector double
testd_h (vector double vd2, vector double vd3)
{
  return vec_mergeh (vd2, vd3);
}

/* { dg-final { scan-assembler-times ""xxpermdi"" 2 } } */

","/* Verify that overloaded built-ins for vec_splat with float and
   double inputs produce the right code.  */

/* { dg-do compile } */
/* { dg-require-effective-target powerpc_vsx_ok } */
/* { dg-options ""-mvsx -O2"" } */

#include <altivec.h>

vector double
testd_l (vector double vd2, vector double vd3)
{
  return vec_mergel (vd2, vd3);
}

vector double
testd_h (vector double vd2, vector double vd3)
{
  return vec_mergeh (vd2, vd3);
}

/* { dg-final { scan-assembler-times ""xxpermdi"" 2 } } */

"
"int abs(int j);
extern void abort(void);

__attribute__((noinline)) int lisp_atan2(long dy, long dx) {
    if (dx <= 0)
        if (dy > 0)
            return abs(dx) <= abs(dy);
    return 0;
}

int main() {   
    volatile long dy = 63, dx = -77;
    if (lisp_atan2(dy, dx))
        abort();
    return 0;
}
","int abs(int j);
extern void abort(void);

__attribute__((noinline)) int lisp_atan2(long dy, long dx) {
    if (dx <= 0)
        if (dy > 0)
            return abs(dx) <= abs(dy);
    return 0;
}

int main() {   
    volatile long dy = 63, dx = -77;
    if (lisp_atan2(dy, dx))
        abort();
    return 0;
}
"
"/* Copyright (C) 2000, 2002 Free Software Foundation, Inc.  */

/* { dg-do preprocess } */
/* { dg-options ""-dM -traditional-cpp"" } */

/* Test -dM does not fail.  */

#define objlike obj like
#define funlike(like) fun like
","/* Copyright (C) 2000, 2002 Free Software Foundation, Inc.  */

/* { dg-do preprocess } */
/* { dg-options ""-dM -traditional-cpp"" } */

/* Test -dM does not fail.  */

#define objlike obj like
#define funlike(like) fun like
"
"c_move_tst (char b)
{
  char a;

  a = b;
  b = 'b';
  foo (a);
  foo (b);
  foo (a);
  bar (a, b);
  b = a;
  if (b == 0)
    a++;
  return a + b;
}
","c_move_tst (char b)
{
  char a;

  a = b;
  b = 'b';
  foo (a);
  foo (b);
  foo (a);
  bar (a, b);
  b = a;
  if (b == 0)
    a++;
  return a + b;
}
"
"/* Diagnostics for attempts to access a member not in a structure or
   union should name the type involved.  Bug 13804.  */
/* Origin: Joseph Myers <jsm@polyomino.org.uk> */
/* { dg-do compile } */
/* { dg-options """" } */

struct s0 { int a; };
union u0 { long b; };
typedef struct s0 S0;
typedef union u0 U0;

struct s0 x0;
S0 x1;
union u0 x2;
U0 x3;
struct s0 *x4;
union u0 *x5;

void
f (void)
{
  x0.c; /* { dg-error ""'struct s0' has no member named 'c'"" } */
  x1.c; /* { dg-error ""'S0' {aka 'struct s0'} has no member named 'c'"" } */
  x2.c; /* { dg-error ""'union u0' has no member named 'c'"" } */
  x3.c; /* { dg-error ""'U0' {aka 'union u0'} has no member named 'c'"" } */
  x4->c; /* { dg-error ""'struct s0' has no member named 'c'"" } */
  x5->c; /* { dg-error ""'union u0' has no member named 'c'"" } */
}
","/* Diagnostics for attempts to access a member not in a structure or
   union should name the type involved.  Bug 13804.  */
/* Origin: Joseph Myers <jsm@polyomino.org.uk> */
/* { dg-do compile } */
/* { dg-options """" } */

struct s0 { int a; };
union u0 { long b; };
typedef struct s0 S0;
typedef union u0 U0;

struct s0 x0;
S0 x1;
union u0 x2;
U0 x3;
struct s0 *x4;
union u0 *x5;

void
f (void)
{
  x0.c; /* { dg-error ""'struct s0' has no member named 'c'"" } */
  x1.c; /* { dg-error ""'S0' {aka 'struct s0'} has no member named 'c'"" } */
  x2.c; /* { dg-error ""'union u0' has no member named 'c'"" } */
  x3.c; /* { dg-error ""'U0' {aka 'union u0'} has no member named 'c'"" } */
  x4->c; /* { dg-error ""'struct s0' has no member named 'c'"" } */
  x5->c; /* { dg-error ""'union u0' has no member named 'c'"" } */
}
"
"/* { dg-do run } */
/* { dg-options ""-O3 -mavx"" } */
/* { dg-require-effective-target avx_runtime } */

extern void abort (void);
double ad[1024];
float af[1024];
short as[1024];
int ai[1024];
long long all[1024];
unsigned short aus[1024];
unsigned int au[1024];
unsigned long long aull[1024];

#define F(var) \
__attribute__((noinline, noclone)) __typeof (var[0]) \
f##var (void) \
{ \
  int i; \
  __typeof (var[0]) r = 0; \
  for (i = 0; i < 1024; i++) \
    r = r > var[i] ? r : var[i]; \
  return r; \
}

#define TESTS \
F (ad) F (af) F (as) F (ai) F (all) F (aus) F (au) F (aull)

TESTS

int
main ()
{
  int i;
  for (i = 0; i < 1024; i++)
    {
#undef F
#define F(var) var[i] = i;
      TESTS
    }
  for (i = 1023; i < 32 * 1024; i += 1024 + 271)
    {
#undef F
#define F(var) var[i & 1023] = i; if (f##var () != i) abort ();
      TESTS
    }
  return 0;
}
","/* { dg-do run } */
/* { dg-options ""-O3 -mavx"" } */
/* { dg-require-effective-target avx_runtime } */

extern void abort (void);
double ad[1024];
float af[1024];
short as[1024];
int ai[1024];
long long all[1024];
unsigned short aus[1024];
unsigned int au[1024];
unsigned long long aull[1024];

#define F(var) \
__attribute__((noinline, noclone)) __typeof (var[0]) \
f##var (void) \
{ \
  int i; \
  __typeof (var[0]) r = 0; \
  for (i = 0; i < 1024; i++) \
    r = r > var[i] ? r : var[i]; \
  return r; \
}

#define TESTS \
F (ad) F (af) F (as) F (ai) F (all) F (aus) F (au) F (aull)

TESTS

int
main ()
{
  int i;
  for (i = 0; i < 1024; i++)
    {
#undef F
#define F(var) var[i] = i;
      TESTS
    }
  for (i = 1023; i < 32 * 1024; i += 1024 + 271)
    {
#undef F
#define F(var) var[i & 1023] = i; if (f##var () != i) abort ();
      TESTS
    }
  return 0;
}
"
"/* { dg-do compile } */
/* { dg-options ""-O2 -fno-tree-vrp -fdump-tree-dom-details"" } */


int f(int x, int y)
{
  int ret;
  if (x == y)
    ret = x & y;
  else
    ret = 0;

  return ret;
}
/* { dg-final { scan-tree-dump ""Replaced redundant expr \[^\r\n\]* with .\(x|y\).""  ""dom2"" } } */


","/* { dg-do compile } */
/* { dg-options ""-O2 -fno-tree-vrp -fdump-tree-dom-details"" } */


int f(int x, int y)
{
  int ret;
  if (x == y)
    ret = x & y;
  else
    ret = 0;

  return ret;
}
/* { dg-final { scan-tree-dump ""Replaced redundant expr \[^\r\n\]* with .\(x|y\).""  ""dom2"" } } */


"
"/* Test floating-point conversions.  _Float32 type with TImode.  */
/* { dg-do run } */
/* { dg-options """" } */
/* { dg-add-options float32 } */
/* { dg-require-effective-target float32_runtime } */

#define __STDC_WANT_IEC_60559_TYPES_EXT__
#include <float.h>
#include ""fp-int-convert.h""

int
main (void)
{
  TEST_I_F(TItype, UTItype, _Float32, FLT32_MANT_DIG, FLT32_MAX_EXP);
  exit (0);
}
","/* Test floating-point conversions.  _Float32 type with TImode.  */
/* { dg-do run } */
/* { dg-options """" } */
/* { dg-add-options float32 } */
/* { dg-require-effective-target float32_runtime } */

#define __STDC_WANT_IEC_60559_TYPES_EXT__
#include <float.h>
#include ""fp-int-convert.h""

int
main (void)
{
  TEST_I_F(TItype, UTItype, _Float32, FLT32_MANT_DIG, FLT32_MAX_EXP);
  exit (0);
}
"
"/* { dg-do run } */
/* { dg-options ""-mpreferred-stack-boundary=4 -msse"" } */
/* { dg-require-effective-target ia32 } */
/* { dg-require-effective-target sse } */

#include ""sse-check.h""

extern void abort(void);

void __attribute__((fastcall, sseregparm)) foo(int i, int j, float x)
{
  static int last_align = -1;
  int dummy, align = (int)&dummy & 15;
  if (last_align < 0)
    last_align = align;
  else if (align != last_align)
    abort ();
}

static void
sse_test (void)
{
	foo(0,0,0.0);
	foo(0,0,0.0);
}
","/* { dg-do run } */
/* { dg-options ""-mpreferred-stack-boundary=4 -msse"" } */
/* { dg-require-effective-target ia32 } */
/* { dg-require-effective-target sse } */

#include ""sse-check.h""

extern void abort(void);

void __attribute__((fastcall, sseregparm)) foo(int i, int j, float x)
{
  static int last_align = -1;
  int dummy, align = (int)&dummy & 15;
  if (last_align < 0)
    last_align = align;
  else if (align != last_align)
    abort ();
}

static void
sse_test (void)
{
	foo(0,0,0.0);
	foo(0,0,0.0);
}
"
"int a[2] = { 2, 0 };

void foo(int *sp, int cnt)
{
  int *p, *top;

  top = sp; sp -= cnt;

  for(p = sp; p <= top; p++)
    if (*p < 2) exit(0);
}

int main()
{
  foo(a + 1, 1);
  abort();
}
","int a[2] = { 2, 0 };

void foo(int *sp, int cnt)
{
  int *p, *top;

  top = sp; sp -= cnt;

  for(p = sp; p <= top; p++)
    if (*p < 2) exit(0);
}

int main()
{
  foo(a + 1, 1);
  abort();
}
"
"/* { dg-do compile { target { powerpc*-*-* } } } */
/* { dg-skip-if """" { powerpc*-*-darwin* } } */
/* { dg-skip-if ""do not override -mcpu"" { powerpc*-*-* } { ""-mcpu=*"" } { ""-mcpu=power5"" } } */
/* { dg-options ""-O2 -mcpu=power5"" } */
/* { dg-final { scan-assembler-times ""nop"" 3 } } */

/* Test generation of nops in load hit store situation.  Make sure enough nop
   insns are generated to move the load to a new dispatch group.  With the
   simple stw/lwz pair below, that would be 3 nop insns for Power5.  */

unsigned int f (volatile unsigned int *u, unsigned int u2)
{
  *u = u2;
  return *u;
}
","/* { dg-do compile { target { powerpc*-*-* } } } */
/* { dg-skip-if """" { powerpc*-*-darwin* } } */
/* { dg-skip-if ""do not override -mcpu"" { powerpc*-*-* } { ""-mcpu=*"" } { ""-mcpu=power5"" } } */
/* { dg-options ""-O2 -mcpu=power5"" } */
/* { dg-final { scan-assembler-times ""nop"" 3 } } */

/* Test generation of nops in load hit store situation.  Make sure enough nop
   insns are generated to move the load to a new dispatch group.  With the
   simple stw/lwz pair below, that would be 3 nop insns for Power5.  */

unsigned int f (volatile unsigned int *u, unsigned int u2)
{
  *u = u2;
  return *u;
}
"
"/* { dg-do compile } */
/* { dg-options ""-O2 -Woverflow"" } */

#include <limits.h>

int foo = INT_MAX + 1;  /* { dg-warning ""integer overflow"" } */

","/* { dg-do compile } */
/* { dg-options ""-O2 -Woverflow"" } */

#include <limits.h>

int foo = INT_MAX + 1;  /* { dg-warning ""integer overflow"" } */

"
"/* PR c/66415 */
/* { dg-do compile } */
/* { dg-options ""-Wformat"" } */

#24
void
fn1 (void)
{
  __builtin_printf                                (""xxxxxxxxxxxxxxxxx%dxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"");
  /* { dg-warning ""format"" """" { target *-*-* } 27 } */
}
","/* PR c/66415 */
/* { dg-do compile } */
/* { dg-options ""-Wformat"" } */

#24
void
fn1 (void)
{
  __builtin_printf                                (""xxxxxxxxxxxxxxxxx%dxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"");
  /* { dg-warning ""format"" """" { target *-*-* } 27 } */
}
"
"/* PR target/61925 */
/* { dg-do compile } */
/* { dg-options ""-O2 -w"" } */
/* { dg-additional-options ""-march=i386 -mno-sse"" { target ia32 } } */

#pragma GCC push_options
#pragma GCC target(""sse"")
typedef float __m128 __attribute__ ((__vector_size__ (16), __may_alias__));
extern __inline __m128 __attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
foo (void)
{
}

#pragma GCC target(""sse2"")
#pragma GCC pop_options

__attribute__ ((vector_size (16))) int
bar (__attribute__ ((vector_size (16))) int a, __attribute__ ((vector_size (16))) int b)
{
  return a + b;
}
","/* PR target/61925 */
/* { dg-do compile } */
/* { dg-options ""-O2 -w"" } */
/* { dg-additional-options ""-march=i386 -mno-sse"" { target ia32 } } */

#pragma GCC push_options
#pragma GCC target(""sse"")
typedef float __m128 __attribute__ ((__vector_size__ (16), __may_alias__));
extern __inline __m128 __attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
foo (void)
{
}

#pragma GCC target(""sse2"")
#pragma GCC pop_options

__attribute__ ((vector_size (16))) int
bar (__attribute__ ((vector_size (16))) int a, __attribute__ ((vector_size (16))) int b)
{
  return a + b;
}
"
"/* { dg-do run } */
/* { dg-require-effective-target arm_v8_2a_fp16_scalar_hw } */
/* { dg-add-options arm_v8_2a_fp16_scalar }  */
/* { dg-skip-if """" { arm*-*-* } } */

#include <arm_fp16.h>

uint16_t expected[] = { 0xFFFF, 0xFFFF, 0x0, 0xFFFF, 0xFFFF, 0x0, 0xFFFF, 0x0,
			0xFFFF, 0xFFFF, 0x0, 0xFFFF, 0x0, 0x0, 0xFFFF, 0x0, 0x0,
			0xFFFF};

#define TEST_MSG ""VCLEH_F16""
#define INSN_NAME vcleh_f16

#define EXPECTED expected

#define INPUT_TYPE float16_t
#define OUTPUT_TYPE uint16_t
#define OUTPUT_TYPE_SIZE 16

/* Include the template for binary scalar operations.  */
#include ""binary_scalar_op.inc""
","/* { dg-do run } */
/* { dg-require-effective-target arm_v8_2a_fp16_scalar_hw } */
/* { dg-add-options arm_v8_2a_fp16_scalar }  */
/* { dg-skip-if """" { arm*-*-* } } */

#include <arm_fp16.h>

uint16_t expected[] = { 0xFFFF, 0xFFFF, 0x0, 0xFFFF, 0xFFFF, 0x0, 0xFFFF, 0x0,
			0xFFFF, 0xFFFF, 0x0, 0xFFFF, 0x0, 0x0, 0xFFFF, 0x0, 0x0,
			0xFFFF};

#define TEST_MSG ""VCLEH_F16""
#define INSN_NAME vcleh_f16

#define EXPECTED expected

#define INPUT_TYPE float16_t
#define OUTPUT_TYPE uint16_t
#define OUTPUT_TYPE_SIZE 16

/* Include the template for binary scalar operations.  */
#include ""binary_scalar_op.inc""
"
"/* Invalid initializers should not receive an ""is not constant""
   error.  */
/* Origin: Joseph Myers <joseph@codesourcery.com> */
/* { dg-do compile } */
/* { dg-options """" } */

int p = c; /* { dg-error ""undeclared"" } */
struct s { int a; } x = { b }; /* { dg-error ""undeclared"" } */
","/* Invalid initializers should not receive an ""is not constant""
   error.  */
/* Origin: Joseph Myers <joseph@codesourcery.com> */
/* { dg-do compile } */
/* { dg-options """" } */

int p = c; /* { dg-error ""undeclared"" } */
struct s { int a; } x = { b }; /* { dg-error ""undeclared"" } */
"
"/* Verify that overloaded built-ins for vec_splat with long long
   inputs produce the right code.  */

/* { dg-do compile { target { powerpc*-*-linux* && lp64 } } } */
/* { dg-require-effective-target powerpc_vsx_ok } */
/* { dg-options ""-mvsx -O2"" } */

#include <altivec.h>

vector signed long long
test3s (signed long long x)
{
  return vec_splats (x);
}

vector unsigned long long
test3u (unsigned long long x)
{
  return vec_splats (x);
}

/* { dg-final { scan-assembler-times ""xxpermdi|mtvsrdd"" 2 } } */
","/* Verify that overloaded built-ins for vec_splat with long long
   inputs produce the right code.  */

/* { dg-do compile { target { powerpc*-*-linux* && lp64 } } } */
/* { dg-require-effective-target powerpc_vsx_ok } */
/* { dg-options ""-mvsx -O2"" } */

#include <altivec.h>

vector signed long long
test3s (signed long long x)
{
  return vec_splats (x);
}

vector unsigned long long
test3u (unsigned long long x)
{
  return vec_splats (x);
}

/* { dg-final { scan-assembler-times ""xxpermdi|mtvsrdd"" 2 } } */
"
"/* PR ipa/80104 */
/* { dg-do compile } */
/* { dg-options ""-fipa-icf"" } */

float
a (_Complex float b)
{
  return *&b;
}

float
c (_Complex float b)
{
  return (&b)[0];
}
","/* PR ipa/80104 */
/* { dg-do compile } */
/* { dg-options ""-fipa-icf"" } */

float
a (_Complex float b)
{
  return *&b;
}

float
c (_Complex float b)
{
  return (&b)[0];
}
"
"/* { dg-do compile { target powerpc*-*-* } } */
/* { dg-options ""-O2"" } */
/* { dg-final { scan-assembler {\mmflr\M.*\mbl\M.*\mmflr\M.*\mbl\M} } } */

/* This tests if shrink-wrapping for separate components puts a prologue
   inside a loop when that is useful.  In this case, it saves the link
   register before each call: both calls happen with probability .10,
   so saving the link register happens with .80 per execution of f on
   average, which is smaller than 1 which you would get if you saved
   it outside the loop.  */

int *a;
void g(void);

void f(int x)
{
	int j;
	for (j = 0; j < 4; j++) {
		if (__builtin_expect(a[j], 0))
			g();
		asm(""#"" : : : ""memory"");
		if (__builtin_expect(a[j], 0))
			g();
		a[j]++;
	}
}
","/* { dg-do compile { target powerpc*-*-* } } */
/* { dg-options ""-O2"" } */
/* { dg-final { scan-assembler {\mmflr\M.*\mbl\M.*\mmflr\M.*\mbl\M} } } */

/* This tests if shrink-wrapping for separate components puts a prologue
   inside a loop when that is useful.  In this case, it saves the link
   register before each call: both calls happen with probability .10,
   so saving the link register happens with .80 per execution of f on
   average, which is smaller than 1 which you would get if you saved
   it outside the loop.  */

int *a;
void g(void);

void f(int x)
{
	int j;
	for (j = 0; j < 4; j++) {
		if (__builtin_expect(a[j], 0))
			g();
		asm(""#"" : : : ""memory"");
		if (__builtin_expect(a[j], 0))
			g();
		a[j]++;
	}
}
"
"/* Check calling convention in the vector ABI.  */

/* { dg-do compile { target { s390*-*-* } } } */
/* { dg-options ""-O3 -mzarch -march=z13"" } */

/* Make sure the last argument is fetched from the argument overflow area.  */
/* { dg-final { scan-assembler ""vl\t%v\[0-9\]*,160\\(%r15\\)"" { target lp64 } } } */
/* { dg-final { scan-assembler ""vl\t%v\[0-9\]*,96\\(%r15\\)"" { target ilp32 } } } */
/* { dg-final { scan-assembler ""gnu_attribute 8, 2"" } } */

typedef double v2df __attribute__((vector_size(16)));

v2df
add (v2df a, v2df b, v2df c, v2df d,
     v2df e, v2df f, v2df g, v2df h, v2df i)
{
  return a + b + c + d + e + f + g + h + i;
}
","/* Check calling convention in the vector ABI.  */

/* { dg-do compile { target { s390*-*-* } } } */
/* { dg-options ""-O3 -mzarch -march=z13"" } */

/* Make sure the last argument is fetched from the argument overflow area.  */
/* { dg-final { scan-assembler ""vl\t%v\[0-9\]*,160\\(%r15\\)"" { target lp64 } } } */
/* { dg-final { scan-assembler ""vl\t%v\[0-9\]*,96\\(%r15\\)"" { target ilp32 } } } */
/* { dg-final { scan-assembler ""gnu_attribute 8, 2"" } } */

typedef double v2df __attribute__((vector_size(16)));

v2df
add (v2df a, v2df b, v2df c, v2df d,
     v2df e, v2df f, v2df g, v2df h, v2df i)
{
  return a + b + c + d + e + f + g + h + i;
}
"
"barfoo (a)
{
  return (a << 16) & ~0xffff;
}

foobar (a)
{
  return ((unsigned short) a) << 15;}

foo (a)
{
  return (a & 0x121) << 31;
}

bar (a)
{
  return (a & ~0xffff) << 16;
}

main ()
{
  int a;

  for (a = 1;  a; a += a)
    {
      printf (""%d"", (foo (a)));
    }
  puts ("""");
}

","barfoo (a)
{
  return (a << 16) & ~0xffff;
}

foobar (a)
{
  return ((unsigned short) a) << 15;}

foo (a)
{
  return (a & 0x121) << 31;
}

bar (a)
{
  return (a & ~0xffff) << 16;
}

main ()
{
  int a;

  for (a = 1;  a; a += a)
    {
      printf (""%d"", (foo (a)));
    }
  puts ("""");
}

"
"/* Verify that overloaded built-ins for vec_eqv with char
   inputs produce the right results.  */

/* { dg-do compile } */
/* { dg-require-effective-target powerpc_p8vector_ok } */
/* { dg-options ""-mpower8-vector -O2"" } */

#include <altivec.h>

vector bool char
test1 (vector bool char x, vector bool char y)
{
  return vec_eqv (x, y);
}

vector signed char
test3 (vector signed char x, vector signed char y)
{
  return vec_eqv (x, y);
}

vector unsigned char
test6 (vector unsigned char x, vector unsigned char y)
{
  return vec_eqv (x, y);
}

/* { dg-final { scan-assembler-times ""xxleqv"" 3 } } */
","/* Verify that overloaded built-ins for vec_eqv with char
   inputs produce the right results.  */

/* { dg-do compile } */
/* { dg-require-effective-target powerpc_p8vector_ok } */
/* { dg-options ""-mpower8-vector -O2"" } */

#include <altivec.h>

vector bool char
test1 (vector bool char x, vector bool char y)
{
  return vec_eqv (x, y);
}

vector signed char
test3 (vector signed char x, vector signed char y)
{
  return vec_eqv (x, y);
}

vector unsigned char
test6 (vector unsigned char x, vector unsigned char y)
{
  return vec_eqv (x, y);
}

/* { dg-final { scan-assembler-times ""xxleqv"" 3 } } */
"
"/* Copyright (C) 2003 Free Software Foundation.

   Check that constant folding of built-in math functions doesn't
   break anything and produces the expected results.

   Written by Roger Sayle, 25th May 2003.  */

/* { dg-do link } */
/* { dg-options ""-O2 -ffast-math"" } */

extern void link_error(void);

extern double exp(double);
extern double atan(double);

int main()
{
  if (exp (1.0) < 2.71 || exp (1.0) > 2.72)
    link_error ();
  if (exp (2.0) < 7.38 || exp (2.0) > 7.39)
    link_error ();
  if (exp (-2.0) < 0.13 || exp (-2.0) > 0.14)
    link_error ();
  if (atan (1.0) < 0.78 || atan (1.0) > 0.79)
    link_error ();

  return 0;
}

","/* Copyright (C) 2003 Free Software Foundation.

   Check that constant folding of built-in math functions doesn't
   break anything and produces the expected results.

   Written by Roger Sayle, 25th May 2003.  */

/* { dg-do link } */
/* { dg-options ""-O2 -ffast-math"" } */

extern void link_error(void);

extern double exp(double);
extern double atan(double);

int main()
{
  if (exp (1.0) < 2.71 || exp (1.0) > 2.72)
    link_error ();
  if (exp (2.0) < 7.38 || exp (2.0) > 7.39)
    link_error ();
  if (exp (-2.0) < 0.13 || exp (-2.0) > 0.14)
    link_error ();
  if (atan (1.0) < 0.78 || atan (1.0) > 0.79)
    link_error ();

  return 0;
}

"
"/* Verify we don't ICE on statement-expressions.  */
/* { dg-do compile } */

void foo(void)
{
  char buf[({ 4; })];
}
","/* Verify we don't ICE on statement-expressions.  */
/* { dg-do compile } */

void foo(void)
{
  char buf[({ 4; })];
}
"
"/* { dg-options { -nostartfiles below100.o -Tbelow100.ld -O2 } } */
/* { dg-final { scan-assembler ""set1 32532,#7"" } } */

typedef struct
{
  unsigned short b0:1;
  unsigned short b1:1;
  unsigned short b2:1;
  unsigned short b3:1;
  unsigned short b4:1;
  unsigned short b5:1;
  unsigned short b6:1;
  unsigned short b7:1;
  unsigned short b8:1;
  unsigned short b9:1;
  unsigned short b10:1;
  unsigned short b11:1;
  unsigned short b12:1;
  unsigned short b13:1;
  unsigned short b14:1;
  unsigned short b15:1;
} BitField;

#define SFR (*((volatile BitField*)0x7f14))
unsigned short *p = (unsigned short *) 0x7f14;

void
Do (void)
{
  SFR.b7 = 1;
}

int
main (void)
{
  *p = 0x1234;
  Do ();
  return (*p == 0x12b4) ? 0 : 1;
}
","/* { dg-options { -nostartfiles below100.o -Tbelow100.ld -O2 } } */
/* { dg-final { scan-assembler ""set1 32532,#7"" } } */

typedef struct
{
  unsigned short b0:1;
  unsigned short b1:1;
  unsigned short b2:1;
  unsigned short b3:1;
  unsigned short b4:1;
  unsigned short b5:1;
  unsigned short b6:1;
  unsigned short b7:1;
  unsigned short b8:1;
  unsigned short b9:1;
  unsigned short b10:1;
  unsigned short b11:1;
  unsigned short b12:1;
  unsigned short b13:1;
  unsigned short b14:1;
  unsigned short b15:1;
} BitField;

#define SFR (*((volatile BitField*)0x7f14))
unsigned short *p = (unsigned short *) 0x7f14;

void
Do (void)
{
  SFR.b7 = 1;
}

int
main (void)
{
  *p = 0x1234;
  Do ();
  return (*p == 0x12b4) ? 0 : 1;
}
"
"/* { dg-do compile } */
/* { dg-options ""-Wpedantic -Wno-pointer-arith"" } */

void h(void)
{
  typedef void (*pft) ();
  typedef void (ft) ();

  void *pv = 0;
  pft pf = 0;

  pv++;
  pf++;

  --pv;
  --pf;

  pv += 1;
  pf += 1;

  pv = pv - 1;
  pf = pf - 1;

  sizeof (void);
  sizeof (ft);
}
","/* { dg-do compile } */
/* { dg-options ""-Wpedantic -Wno-pointer-arith"" } */

void h(void)
{
  typedef void (*pft) ();
  typedef void (ft) ();

  void *pv = 0;
  pft pf = 0;

  pv++;
  pf++;

  --pv;
  --pf;

  pv += 1;
  pf += 1;

  pv = pv - 1;
  pf = pf - 1;

  sizeof (void);
  sizeof (ft);
}
"
"/* { dg-lto-do run } */
int first = 0;
void abort (void);
void c (void);
void b (void);
int second = 0;
void callmealias (void)
{
  if (!first || !second)
   abort ();
}
void callmefirst (void)
{
  if (first)
    abort();
  first = 1;
}
void callmesecond (void)
{
  if (!first)
    abort();
  if (second)
    abort();
  second = 1;
}
int
main()
{
  c();
  b();
  return 0;
}
","/* { dg-lto-do run } */
int first = 0;
void abort (void);
void c (void);
void b (void);
int second = 0;
void callmealias (void)
{
  if (!first || !second)
   abort ();
}
void callmefirst (void)
{
  if (first)
    abort();
  first = 1;
}
void callmesecond (void)
{
  if (!first)
    abort();
  if (second)
    abort();
  second = 1;
}
int
main()
{
  c();
  b();
  return 0;
}
"
"/* { dg-do run } */
/* { dg-options ""-O2 -mavx512bw"" } */
/* { dg-require-effective-target avx512bw } */

#define AVX512BW
#include ""avx512f-helper.h""

#define SIZE (AVX512F_LEN / 8)
#include ""avx512f-mask-type.h""

void
CALC (MASK_TYPE *r, char *s1, char *s2)
{
  int i;
  *r = 0;
  MASK_TYPE one = 1;

  for (i = 0; i < SIZE; i++)
    if (s1[i] != s2[i])
      *r = *r | (one << i);
}

void
TEST (void)
{
  int i;
  UNION_TYPE (AVX512F_LEN, i_b) src1, src2;
  MASK_TYPE res_ref, res1, res2;
  MASK_TYPE mask = MASK_VALUE;

  for (i = 0; i < SIZE / 2; i++)
    {
      src1.a[i * 2] = i;
      src1.a[i * 2 + 1] = i * i;
      src2.a[i * 2] = 2 * i;
      src2.a[i * 2 + 1] = i * i;
    }

  res1 = INTRINSIC (_cmpneq_epi8_mask) (src1.x, src2.x);
  res2 = INTRINSIC (_mask_cmpneq_epi8_mask) (mask, src1.x, src2.x);

  CALC (&res_ref, src1.a, src2.a);

  if (res_ref != res1)
    abort ();

  res_ref &= mask;

  if (res_ref != res2)
    abort ();
}
","/* { dg-do run } */
/* { dg-options ""-O2 -mavx512bw"" } */
/* { dg-require-effective-target avx512bw } */

#define AVX512BW
#include ""avx512f-helper.h""

#define SIZE (AVX512F_LEN / 8)
#include ""avx512f-mask-type.h""

void
CALC (MASK_TYPE *r, char *s1, char *s2)
{
  int i;
  *r = 0;
  MASK_TYPE one = 1;

  for (i = 0; i < SIZE; i++)
    if (s1[i] != s2[i])
      *r = *r | (one << i);
}

void
TEST (void)
{
  int i;
  UNION_TYPE (AVX512F_LEN, i_b) src1, src2;
  MASK_TYPE res_ref, res1, res2;
  MASK_TYPE mask = MASK_VALUE;

  for (i = 0; i < SIZE / 2; i++)
    {
      src1.a[i * 2] = i;
      src1.a[i * 2 + 1] = i * i;
      src2.a[i * 2] = 2 * i;
      src2.a[i * 2 + 1] = i * i;
    }

  res1 = INTRINSIC (_cmpneq_epi8_mask) (src1.x, src2.x);
  res2 = INTRINSIC (_mask_cmpneq_epi8_mask) (mask, src1.x, src2.x);

  CALC (&res_ref, src1.a, src2.a);

  if (res_ref != res1)
    abort ();

  res_ref &= mask;

  if (res_ref != res2)
    abort ();
}
"
"/* Check error messages for named asm operands.  */
void foo ()
{
  int i;
  __asm__ ("""" : [data] ""=r"" (i) : [data] ""i"" (100)); /* { dg-error ""duplicate asm operand"" } */
  __asm__ (""%[foo]"" :: [bar] ""i"" (1)); /* { dg-error ""undefined named operand"" } */
}
","/* Check error messages for named asm operands.  */
void foo ()
{
  int i;
  __asm__ ("""" : [data] ""=r"" (i) : [data] ""i"" (100)); /* { dg-error ""duplicate asm operand"" } */
  __asm__ (""%[foo]"" :: [bar] ""i"" (1)); /* { dg-error ""undefined named operand"" } */
}
"
"/* { dg-do compile } */
/* { dg-options ""-O3 -dp -mavx -mavx256-split-unaligned-load -mtune=generic"" } */

#define N 1024

double a[N], b[N+3], c[N];

void
avx_test (void)
{
  int i;

  for (i = 0; i < N; i++)
    c[i] = a[i] * b[i+3];
}

/* { dg-final { scan-assembler-not ""(avx_loadupd256|vmovupd\[^\n\r]*movv4df_internal)"" } } */
/* { dg-final { scan-assembler ""(sse2_loadupd|vmovupd\[^\n\r]*movv2df_internal)"" } } */
/* { dg-final { scan-assembler ""vinsertf128"" } } */
","/* { dg-do compile } */
/* { dg-options ""-O3 -dp -mavx -mavx256-split-unaligned-load -mtune=generic"" } */

#define N 1024

double a[N], b[N+3], c[N];

void
avx_test (void)
{
  int i;

  for (i = 0; i < N; i++)
    c[i] = a[i] * b[i+3];
}

/* { dg-final { scan-assembler-not ""(avx_loadupd256|vmovupd\[^\n\r]*movv4df_internal)"" } } */
/* { dg-final { scan-assembler ""(sse2_loadupd|vmovupd\[^\n\r]*movv2df_internal)"" } } */
/* { dg-final { scan-assembler ""vinsertf128"" } } */
"
"/* { dg-do compile } */
/* { dg-options ""-O2 -fomit-frame-pointer -flax-vector-conversions -mmmx"" } */
/* { dg-additional-options ""-mno-vect8-ret-in-mem"" { target *-*-vxworks* } } */

#include <mmintrin.h>

__v8qi test ()
{
  __v8qi mm0 = {1,2,3,4,5,6,7,8};
  __v8qi mm1 = {11,22,33,44,55,66,77,88};
  volatile __m64 x;

  x = _mm_add_pi8 (mm0, mm1);

  return x;
}

/* { dg-final { scan-assembler-times ""movq"" 3 } } */
/* { dg-final { scan-assembler-not ""movl"" { target nonpic } } } */
","/* { dg-do compile } */
/* { dg-options ""-O2 -fomit-frame-pointer -flax-vector-conversions -mmmx"" } */
/* { dg-additional-options ""-mno-vect8-ret-in-mem"" { target *-*-vxworks* } } */

#include <mmintrin.h>

__v8qi test ()
{
  __v8qi mm0 = {1,2,3,4,5,6,7,8};
  __v8qi mm1 = {11,22,33,44,55,66,77,88};
  volatile __m64 x;

  x = _mm_add_pi8 (mm0, mm1);

  return x;
}

/* { dg-final { scan-assembler-times ""movq"" 3 } } */
/* { dg-final { scan-assembler-not ""movl"" { target nonpic } } } */
"
"/* Test for _Bool bit-fields.  After TC2, the width of a _Bool
   bit-field must not extend the width (number of sign and value bits)
   of _Bool, which is implementation-defined but is 1 unless the
   implementation defines representations for values greater than 1 in
   type _Bool and allows for _Bool objects to have such types, which
   GCC does not.  */
/* Origin: Joseph Myers <joseph@codesourcery.com> */
/* { dg-do compile } */
/* { dg-options ""-std=iso9899:1999 -pedantic-errors"" } */

struct foo
{
  _Bool b : 2; /* { dg-error ""width"" } */
};
","/* Test for _Bool bit-fields.  After TC2, the width of a _Bool
   bit-field must not extend the width (number of sign and value bits)
   of _Bool, which is implementation-defined but is 1 unless the
   implementation defines representations for values greater than 1 in
   type _Bool and allows for _Bool objects to have such types, which
   GCC does not.  */
/* Origin: Joseph Myers <joseph@codesourcery.com> */
/* { dg-do compile } */
/* { dg-options ""-std=iso9899:1999 -pedantic-errors"" } */

struct foo
{
  _Bool b : 2; /* { dg-error ""width"" } */
};
"
"/* PR rtl-optimization/28634.  On targets with delayed branches,
   dbr_schedule could do the next iteration's addition in the
   branch delay slot, then subtract the value again if the branch
   wasn't taken.  This can lead to rounding errors.  */
double x = -0x1.0p53;
double y = 1;
int
main (void)
{
  while (y > 0)
    y += x;
  if (y != x + 1)
    abort ();
  exit (0);
}
","/* PR rtl-optimization/28634.  On targets with delayed branches,
   dbr_schedule could do the next iteration's addition in the
   branch delay slot, then subtract the value again if the branch
   wasn't taken.  This can lead to rounding errors.  */
double x = -0x1.0p53;
double y = 1;
int
main (void)
{
  while (y > 0)
    y += x;
  if (y != x + 1)
    abort ();
  exit (0);
}
"
"/* { dg-do compile } */
/* { dg-options ""-mavx512bw -O2"" } */
/* { dg-final { scan-assembler-times ""knotd\[ \\t\]+\[^\{\n\]*%k\[0-7\](?:\n|\[ \\t\]+#)"" 1 } } */

#include <immintrin.h>

void
avx512bw_test ()
{
  __mmask32 k1, k2;
  volatile __m512i x = _mm512_setzero_si512 ();

  __asm__( ""kmovd %1, %0"" : ""=k"" (k1) : ""r"" (45) );

  k2 = _knot_mask32 (k1);
  x = _mm512_mask_add_epi16 (x, k1, x, x);
  x = _mm512_mask_add_epi16 (x, k2, x, x);
}
","/* { dg-do compile } */
/* { dg-options ""-mavx512bw -O2"" } */
/* { dg-final { scan-assembler-times ""knotd\[ \\t\]+\[^\{\n\]*%k\[0-7\](?:\n|\[ \\t\]+#)"" 1 } } */

#include <immintrin.h>

void
avx512bw_test ()
{
  __mmask32 k1, k2;
  volatile __m512i x = _mm512_setzero_si512 ();

  __asm__( ""kmovd %1, %0"" : ""=k"" (k1) : ""r"" (45) );

  k2 = _knot_mask32 (k1);
  x = _mm512_mask_add_epi16 (x, k1, x, x);
  x = _mm512_mask_add_epi16 (x, k2, x, x);
}
"
"/* { dg-do compile } */ 
/* { dg-options ""-O2 -fdump-tree-pre-stats"" } */
int t[2];
int g(int);
int f(int tt)
{
    if (t[0])
      t[0] = 2;
    return g(t[0]);
}

/* { dg-final { scan-tree-dump-times ""Eliminated: 1"" 1 ""pre""} } */
","/* { dg-do compile } */ 
/* { dg-options ""-O2 -fdump-tree-pre-stats"" } */
int t[2];
int g(int);
int f(int tt)
{
    if (t[0])
      t[0] = 2;
    return g(t[0]);
}

/* { dg-final { scan-tree-dump-times ""Eliminated: 1"" 1 ""pre""} } */
"
"/* { dg-do run } */
/* { dg-options ""-O2 -mavx512bw"" } */
/* { dg-require-effective-target avx512bw } */

#define AVX512BW

#include ""avx512f-helper.h""

static __mmask64 __attribute__((noinline,noclone))
unpack (__mmask64 arg1, __mmask64 arg2)
{
  __mmask64 res;

  res = _mm512_kunpackd (arg1, arg2);

  return res;
}

void
TEST (void)
{
  if (unpack (0x07UL, 0x70UL) != 0x0700000070UL)
    __builtin_abort ();
}
","/* { dg-do run } */
/* { dg-options ""-O2 -mavx512bw"" } */
/* { dg-require-effective-target avx512bw } */

#define AVX512BW

#include ""avx512f-helper.h""

static __mmask64 __attribute__((noinline,noclone))
unpack (__mmask64 arg1, __mmask64 arg2)
{
  __mmask64 res;

  res = _mm512_kunpackd (arg1, arg2);

  return res;
}

void
TEST (void)
{
  if (unpack (0x07UL, 0x70UL) != 0x0700000070UL)
    __builtin_abort ();
}
"
"/* PR target/27696
   The testcase below uses to trigger an ICE.  */

/* { dg-do compile } */
/* { dg-options ""-msse3"" } */

void
foo (void const * P, unsigned int E, unsigned int H)
{
  __builtin_ia32_monitor (P, E, H);
}
","/* PR target/27696
   The testcase below uses to trigger an ICE.  */

/* { dg-do compile } */
/* { dg-options ""-msse3"" } */

void
foo (void const * P, unsigned int E, unsigned int H)
{
  __builtin_ia32_monitor (P, E, H);
}
"
"/* Test atomic_kill_dependency.  */
/* { dg-do run } */
/* { dg-options ""-std=c11 -pedantic-errors"" } */

#include <stdatomic.h>

extern void abort (void);

_Atomic int a = ATOMIC_VAR_INIT (1), b;

int
main ()
{
  b = kill_dependency (a);
  if (b != 1)
    abort ();

  return 0;
}
","/* Test atomic_kill_dependency.  */
/* { dg-do run } */
/* { dg-options ""-std=c11 -pedantic-errors"" } */

#include <stdatomic.h>

extern void abort (void);

_Atomic int a = ATOMIC_VAR_INIT (1), b;

int
main ()
{
  b = kill_dependency (a);
  if (b != 1)
    abort ();

  return 0;
}
"
"/* { dg-do run } */
/* { dg-options ""-O2 -mavx512vl"" } */
/* { dg-require-effective-target avx512vl } */

#define AVX512VL
#define AVX512F_LEN 256
#define AVX512F_LEN_HALF 128
#include ""avx512f-vpcmpgtuq-2.c""

#undef AVX512F_LEN
#undef AVX512F_LEN_HALF

#define AVX512F_LEN 128
#define AVX512F_LEN_HALF 128
#include ""avx512f-vpcmpgtuq-2.c""
","/* { dg-do run } */
/* { dg-options ""-O2 -mavx512vl"" } */
/* { dg-require-effective-target avx512vl } */

#define AVX512VL
#define AVX512F_LEN 256
#define AVX512F_LEN_HALF 128
#include ""avx512f-vpcmpgtuq-2.c""

#undef AVX512F_LEN
#undef AVX512F_LEN_HALF

#define AVX512F_LEN 128
#define AVX512F_LEN_HALF 128
#include ""avx512f-vpcmpgtuq-2.c""
"
"/* { dg-do compile } */
/* { dg-options ""-Wcoercion"" } */
/* { dg-error ""unrecognized command line option '-Wcoercion'; did you mean '-Wconversion'?""  """" { target *-*-* } 0 } */

","/* { dg-do compile } */
/* { dg-options ""-Wcoercion"" } */
/* { dg-error ""unrecognized command line option '-Wcoercion'; did you mean '-Wconversion'?""  """" { target *-*-* } 0 } */

"
"/* { dg-do run } */

extern void abort (void);

#if __SIZEOF_INT__ > 2
struct foo
{
 int *f;
 int i;
};

int baz;
#else
struct foo
{
 long *f;
 long i;
};

long baz;
#endif

void __attribute__ ((noinline))
bar (struct foo x)
{
 *(x.f) = x.i;
}

int
main ()
{
  struct foo x = { &baz, 0xdeadbeef };

  bar (x);

  if (baz != 0xdeadbeef)
    abort ();

  return 0;
}
","/* { dg-do run } */

extern void abort (void);

#if __SIZEOF_INT__ > 2
struct foo
{
 int *f;
 int i;
};

int baz;
#else
struct foo
{
 long *f;
 long i;
};

long baz;
#endif

void __attribute__ ((noinline))
bar (struct foo x)
{
 *(x.f) = x.i;
}

int
main ()
{
  struct foo x = { &baz, 0xdeadbeef };

  bar (x);

  if (baz != 0xdeadbeef)
    abort ();

  return 0;
}
"
"/* { dg-require-effective-target int32plus } */

struct S0
{
};

struct S1
{
  unsigned f0:27;
  const unsigned:0;
};

struct S2
{
  unsigned f2:1;
};

unsigned char g_4[1][8][3][1][1][1];
unsigned char *g_17;
unsigned char **g_16[1][10][7];

struct S2 g_35 = {
  0
};

struct S2 *g_34 = &g_35;

struct S1 func_86 (unsigned char p_87, struct S2 **p_89)
{
  struct S1 l_92[6][8][1][1] = {
    16143586
  }
  ;
  return l_92[0][0][0][0];
}

void func_28 (struct S1 p_30, const struct S1 p_32)
{
}

void func_70 (unsigned char p_72)
{
  unsigned char *const *l_93 = &g_17;
  struct S2 **l_94;
  unsigned char *const *l_97 = &g_17;
  func_28 (func_86 (p_72, 0),
           func_86 (p_72, &g_34));
}
","/* { dg-require-effective-target int32plus } */

struct S0
{
};

struct S1
{
  unsigned f0:27;
  const unsigned:0;
};

struct S2
{
  unsigned f2:1;
};

unsigned char g_4[1][8][3][1][1][1];
unsigned char *g_17;
unsigned char **g_16[1][10][7];

struct S2 g_35 = {
  0
};

struct S2 *g_34 = &g_35;

struct S1 func_86 (unsigned char p_87, struct S2 **p_89)
{
  struct S1 l_92[6][8][1][1] = {
    16143586
  }
  ;
  return l_92[0][0][0][0];
}

void func_28 (struct S1 p_30, const struct S1 p_32)
{
}

void func_70 (unsigned char p_72)
{
  unsigned char *const *l_93 = &g_17;
  struct S2 **l_94;
  unsigned char *const *l_97 = &g_17;
  func_28 (func_86 (p_72, 0),
           func_86 (p_72, &g_34));
}
"
"/* This used to ICE with the ccmp patches on aarch64. */
int f(char);
int init_emit_regs (int mode) {
  f(mode == 4 || mode == 13);
}
","/* This used to ICE with the ccmp patches on aarch64. */
int f(char);
int init_emit_regs (int mode) {
  f(mode == 4 || mode == 13);
}
"
"/* { dg-lto-do run } */

double a(double) __attribute__ ((optimize(1), used));
double a(double r) 
{ 
  return r;
}
int main () { return 0; }
","/* { dg-lto-do run } */

double a(double) __attribute__ ((optimize(1), used));
double a(double r) 
{ 
  return r;
}
int main () { return 0; }
"
"/* { dg-do run } */
/* { dg-options ""-fsanitize=null -w"" } */
/* { dg-shouldfail ""ubsan"" } */

int
main (void)
{
  int *p = 0;
  return *p;
}

/* { dg-output ""load of null pointer of type 'int'"" } */
","/* { dg-do run } */
/* { dg-options ""-fsanitize=null -w"" } */
/* { dg-shouldfail ""ubsan"" } */

int
main (void)
{
  int *p = 0;
  return *p;
}

/* { dg-output ""load of null pointer of type 'int'"" } */
"
"/* { dg-shouldfail ""tsan"" } */
/* { dg-additional-options ""-ldl"" } */

#include <pthread.h>
#include <unistd.h>
#include ""tsan_barrier.h""

static pthread_barrier_t barrier;
int fds[2];

void *Thread1(void *x) {
  write(fds[1], ""a"", 1);
  barrier_wait(&barrier);
  return NULL;
}

void *Thread2(void *x) {
  barrier_wait(&barrier);
  close(fds[0]);
  close(fds[1]);
  return NULL;
}

int main() {
  barrier_init(&barrier, 2);
  pipe(fds);
  pthread_t t[2];
  pthread_create(&t[0], NULL, Thread1, NULL);
  pthread_create(&t[1], NULL, Thread2, NULL);
  pthread_join(t[0], NULL);
  pthread_join(t[1], NULL);
  return 0;
}

/* { dg-output ""WARNING: ThreadSanitizer: data race.*\n"" } */
/* { dg-output ""  Write of size 8.*\n"" } */
/* { dg-output ""    #0 close.*\n"" } */
/* { dg-output ""    #1 Thread2.*\n"" } */
/* { dg-output ""  Previous read of size 8.*\n"" } */
/* { dg-output ""    #0 write.*\n"" } */
/* { dg-output ""    #1 Thread1.*\n"" } */
","/* { dg-shouldfail ""tsan"" } */
/* { dg-additional-options ""-ldl"" } */

#include <pthread.h>
#include <unistd.h>
#include ""tsan_barrier.h""

static pthread_barrier_t barrier;
int fds[2];

void *Thread1(void *x) {
  write(fds[1], ""a"", 1);
  barrier_wait(&barrier);
  return NULL;
}

void *Thread2(void *x) {
  barrier_wait(&barrier);
  close(fds[0]);
  close(fds[1]);
  return NULL;
}

int main() {
  barrier_init(&barrier, 2);
  pipe(fds);
  pthread_t t[2];
  pthread_create(&t[0], NULL, Thread1, NULL);
  pthread_create(&t[1], NULL, Thread2, NULL);
  pthread_join(t[0], NULL);
  pthread_join(t[1], NULL);
  return 0;
}

/* { dg-output ""WARNING: ThreadSanitizer: data race.*\n"" } */
/* { dg-output ""  Write of size 8.*\n"" } */
/* { dg-output ""    #0 close.*\n"" } */
/* { dg-output ""    #1 Thread2.*\n"" } */
/* { dg-output ""  Previous read of size 8.*\n"" } */
/* { dg-output ""    #0 write.*\n"" } */
/* { dg-output ""    #1 Thread1.*\n"" } */
"
"/* Test AAPCS layout (VFP variant) */

/* { dg-do run { target aarch64*-*-* } } */

#ifndef IN_FRAMEWORK
#define TESTFILE ""test_6.c""

__complex__ double x = 1.0+2.0i;

struct y
{
  int p;
  int q;
  int r;
  int s;
} v = { 1, 2, 3, 4 };

#include ""abitest.h""
#else
  ARG(struct y, v, X0)
  ARG(float, 1.0f, S0)
  ARG(__complex__ double, x, D1)
  ARG(float, 2.0f, S3)
  ARG(double, 5.0, D4)
  LAST_ARG(int, 3, W2)
#endif
","/* Test AAPCS layout (VFP variant) */

/* { dg-do run { target aarch64*-*-* } } */

#ifndef IN_FRAMEWORK
#define TESTFILE ""test_6.c""

__complex__ double x = 1.0+2.0i;

struct y
{
  int p;
  int q;
  int r;
  int s;
} v = { 1, 2, 3, 4 };

#include ""abitest.h""
#else
  ARG(struct y, v, X0)
  ARG(float, 1.0f, S0)
  ARG(__complex__ double, x, D1)
  ARG(float, 2.0f, S3)
  ARG(double, 5.0, D4)
  LAST_ARG(int, 3, W2)
#endif
"
"/* { dg-do compile } */
/* { dg-csky-options ""-O1"" } */

/* Test special code generation patterns for bit operators.  */

long long int land1 (long long int x)
{
  return x & 0xffffffff00000000LL;
}

/* { dg-final { scan-assembler ""movi.*, 0"" } } */
","/* { dg-do compile } */
/* { dg-csky-options ""-O1"" } */

/* Test special code generation patterns for bit operators.  */

long long int land1 (long long int x)
{
  return x & 0xffffffff00000000LL;
}

/* { dg-final { scan-assembler ""movi.*, 0"" } } */
"
"/* PR sanitizer/80349 */
/* { dg-do compile } */
/* { dg-options ""-fsanitize=undefined"" } */

int var;
long a;

long
fn1 ()
{
  return 0 % ((a & 1) == (7UL & 1));
}

long
fn2 ()
{
  return 0 % ((a & 1) == (1 & 7UL));
}

long
fn3 ()
{
  return 0 % ((1 & a) == (7UL & 1));
}

long
fn4 ()
{
  return 0 % ((1 & a) == (1 & 7UL));
}
","/* PR sanitizer/80349 */
/* { dg-do compile } */
/* { dg-options ""-fsanitize=undefined"" } */

int var;
long a;

long
fn1 ()
{
  return 0 % ((a & 1) == (7UL & 1));
}

long
fn2 ()
{
  return 0 % ((a & 1) == (1 & 7UL));
}

long
fn3 ()
{
  return 0 % ((1 & a) == (7UL & 1));
}

long
fn4 ()
{
  return 0 % ((1 & a) == (1 & 7UL));
}
"
"/* PR18191 Struct member is not getting default-initialized.
   Origin: Grigory Zagorodnev  <grigory.zagorodnev@intel.com>  */

/* { dg-do run } */

extern int printf (__const char *__restrict __format, ...);

typedef struct S {
  const char* s;
  int         i;
} S;

void
foo (void)
{
  S dummy[2];
  unsigned i;

  /* Put some garbage on the stack.  */
  for (i = 0; i < sizeof(dummy); i++)
    ((char *)&dummy)[i] = -1;
}

int
bar (void)
{
  /* Allocate object on the stack.  */
  S obj[2] = { {""m0""}, {""m1""} };

  /* Assume fields those not explicitly initialized
     are default initialized to 0 [8.5.1/7 and 8.5/5].  */
  if (obj[0].i == 0)
    return 0;
  else
    {
      printf(""Failed: obj[0].i == '%d', expecting '0'\n"", obj[0].i);
      return 1;
    }
}

int
main (void)
{
  foo();
  return bar();
}

","/* PR18191 Struct member is not getting default-initialized.
   Origin: Grigory Zagorodnev  <grigory.zagorodnev@intel.com>  */

/* { dg-do run } */

extern int printf (__const char *__restrict __format, ...);

typedef struct S {
  const char* s;
  int         i;
} S;

void
foo (void)
{
  S dummy[2];
  unsigned i;

  /* Put some garbage on the stack.  */
  for (i = 0; i < sizeof(dummy); i++)
    ((char *)&dummy)[i] = -1;
}

int
bar (void)
{
  /* Allocate object on the stack.  */
  S obj[2] = { {""m0""}, {""m1""} };

  /* Assume fields those not explicitly initialized
     are default initialized to 0 [8.5.1/7 and 8.5/5].  */
  if (obj[0].i == 0)
    return 0;
  else
    {
      printf(""Failed: obj[0].i == '%d', expecting '0'\n"", obj[0].i);
      return 1;
    }
}

int
main (void)
{
  foo();
  return bar();
}

"
"/* { dg-do compile } */
/* { dg-options ""-O2 -mshstk"" } */
/* { dg-final { scan-assembler-times ""setssbsy"" 1 } } */

#include <immintrin.h>

void f2 (void)
{
  _setssbsy ();
}
","/* { dg-do compile } */
/* { dg-options ""-O2 -mshstk"" } */
/* { dg-final { scan-assembler-times ""setssbsy"" 1 } } */

#include <immintrin.h>

void f2 (void)
{
  _setssbsy ();
}
"
"/* { dg-do compile } */
/* { dg-options ""-O2"" } */
/* { dg-final { scan-assembler-times ""fmsub\[ \ta-zA-Z0-9\]*,"" 1 } } */

float
f (float ar, float ai, float br, float bi)
{
  return ar * br - ai * bi;
}
","/* { dg-do compile } */
/* { dg-options ""-O2"" } */
/* { dg-final { scan-assembler-times ""fmsub\[ \ta-zA-Z0-9\]*,"" 1 } } */

float
f (float ar, float ai, float br, float bi)
{
  return ar * br - ai * bi;
}
"
"/* Test the `vextp16' AArch64 SIMD intrinsic.  */

/* { dg-do run } */
/* { dg-options ""-save-temps -O3 -fno-inline"" } */

#include ""arm_neon.h""
#include ""ext_p16.x""

/* { dg-final { scan-assembler-times ""ext\[ \t\]+\[vV\]\[0-9\]+\.8\[bB\], ?\[vV\]\[0-9\]+\.8\[bB\], ?\[vV\]\[0-9\]+\.8\[bB\], ?#\[0-9\]+\(?:.2\)?\(?:\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n"" 3 } } */
","/* Test the `vextp16' AArch64 SIMD intrinsic.  */

/* { dg-do run } */
/* { dg-options ""-save-temps -O3 -fno-inline"" } */

#include ""arm_neon.h""
#include ""ext_p16.x""

/* { dg-final { scan-assembler-times ""ext\[ \t\]+\[vV\]\[0-9\]+\.8\[bB\], ?\[vV\]\[0-9\]+\.8\[bB\], ?\[vV\]\[0-9\]+\.8\[bB\], ?#\[0-9\]+\(?:.2\)?\(?:\[ \t\]+@\[a-zA-Z0-9 \]+\)?\n"" 3 } } */
"
"/* PR target/43636 */

extern char a[], *b[];

char *
foo (char *x, int y)
{
  x = __builtin_stpcpy (x, b[a[y]]);
  return x;
}
","/* PR target/43636 */

extern char a[], *b[];

char *
foo (char *x, int y)
{
  x = __builtin_stpcpy (x, b[a[y]]);
  return x;
}
"
"struct s { int f[4]; };

int foo (struct s s, int x1, int x2, int x3, int x4, int x5, int x6, int x7)
{
  return s.f[3] + x7;
}

int main ()
{
  struct s s = { 1, 2, 3, 4 };

  if (foo (s, 100, 200, 300, 400, 500, 600, 700) != 704)
    abort ();
  exit (0);
}
","struct s { int f[4]; };

int foo (struct s s, int x1, int x2, int x3, int x4, int x5, int x6, int x7)
{
  return s.f[3] + x7;
}

int main ()
{
  struct s s = { 1, 2, 3, 4 };

  if (foo (s, 100, 200, 300, 400, 500, 600, 700) != 704)
    abort ();
  exit (0);
}
"
"/* { dg-do compile } */
/* { dg-options ""-O2 -mavx512vl"" } */
/* { dg-final { scan-assembler-times ""vpsrad\[ \\t\]+\[^\{\n\]*, %ymm\[0-9\]+\{%k\[1-7\]\}(?:\n|\[ \\t\]+#)"" 1 } } */
/* { dg-final { scan-assembler-times ""vpsrad\[ \\t\]+\[^\{\n\]*, %ymm\[0-9\]+\{%k\[1-7\]\}\{z\}(?:\n|\[ \\t\]+#)"" 1 } } */
/* { dg-final { scan-assembler-times ""vpsrad\[ \\t\]+\[^\{\n\]*, %xmm\[0-9\]+\{%k\[1-7\]\}(?:\n|\[ \\t\]+#)"" 1 } } */
/* { dg-final { scan-assembler-times ""vpsrad\[ \\t\]+\[^\{\n\]*, %xmm\[0-9\]+\{%k\[1-7\]\}\{z\}(?:\n|\[ \\t\]+#)"" 1 } } */

#include <immintrin.h>

volatile __m256i x256;
volatile __m128i x128;
volatile __m128i y;
volatile __mmask8 m;

void extern
avx512vl_test (void)
{
  x256 = _mm256_mask_sra_epi32 (x256, m, x256, y);
  x256 = _mm256_maskz_sra_epi32 (m, x256, y);
  x128 = _mm_mask_sra_epi32 (x128, m, x128, y);
  x128 = _mm_maskz_sra_epi32 (m, x128, y);
}
","/* { dg-do compile } */
/* { dg-options ""-O2 -mavx512vl"" } */
/* { dg-final { scan-assembler-times ""vpsrad\[ \\t\]+\[^\{\n\]*, %ymm\[0-9\]+\{%k\[1-7\]\}(?:\n|\[ \\t\]+#)"" 1 } } */
/* { dg-final { scan-assembler-times ""vpsrad\[ \\t\]+\[^\{\n\]*, %ymm\[0-9\]+\{%k\[1-7\]\}\{z\}(?:\n|\[ \\t\]+#)"" 1 } } */
/* { dg-final { scan-assembler-times ""vpsrad\[ \\t\]+\[^\{\n\]*, %xmm\[0-9\]+\{%k\[1-7\]\}(?:\n|\[ \\t\]+#)"" 1 } } */
/* { dg-final { scan-assembler-times ""vpsrad\[ \\t\]+\[^\{\n\]*, %xmm\[0-9\]+\{%k\[1-7\]\}\{z\}(?:\n|\[ \\t\]+#)"" 1 } } */

#include <immintrin.h>

volatile __m256i x256;
volatile __m128i x128;
volatile __m128i y;
volatile __mmask8 m;

void extern
avx512vl_test (void)
{
  x256 = _mm256_mask_sra_epi32 (x256, m, x256, y);
  x256 = _mm256_maskz_sra_epi32 (m, x256, y);
  x128 = _mm_mask_sra_epi32 (x128, m, x128, y);
  x128 = _mm_maskz_sra_epi32 (m, x128, y);
}
"
"/* { dg-do compile } */
/* { dg-options ""-O2 -ftree-loop-linear"" } */
/* { dg-require-effective-target size32plus } */

int foo()
{
  int x[2][2], y[2];
  int i, n, s;

  /* This is a reduction: there is a scalar dependence that cannot be
     removed by rewriting IVs.  This code cannot and should not be
     transformed into a perfect loop.  */
  for (n = 0; n < 2; n++)
    {
      s = 0;
      for (i = 0; i < 2; i++)
        s += x[n][i]*y[i];
      s += 1;
    }

  return s;
}
","/* { dg-do compile } */
/* { dg-options ""-O2 -ftree-loop-linear"" } */
/* { dg-require-effective-target size32plus } */

int foo()
{
  int x[2][2], y[2];
  int i, n, s;

  /* This is a reduction: there is a scalar dependence that cannot be
     removed by rewriting IVs.  This code cannot and should not be
     transformed into a perfect loop.  */
  for (n = 0; n < 2; n++)
    {
      s = 0;
      for (i = 0; i < 2; i++)
        s += x[n][i]*y[i];
      s += 1;
    }

  return s;
}
"
"/* Test for strftime formats.  Formats using C99 features.  */
/* Origin: Joseph Myers <jsm28@cam.ac.uk> */
/* { dg-do compile { target { *-*-mingw* } } } */
/* { dg-options ""-std=iso9899:1999 -pedantic -Wformat -Wformat-y2k"" } */

#define USE_SYSTEM_FORMATS
#include ""format.h""

void
foo (char *s, size_t m, const struct tm *tp)
{
  /* See ISO/IEC 9899:1990 (E) subclause 7.12.3.5 (pages 174-175).  */
  /* Formats which are Y2K-compliant (no 2-digit years).  */
  strftime (s, m, ""%a%A%b%B%d%H%I%j%m%M%p%S%U%w%W%X%Y%z%Z%%"", tp);
  /* Formats with 2-digit years.  */
  strftime (s, m, ""%y"", tp); /* { dg-warning ""only last 2"" ""2-digit year"" } */
  /* Formats with 2-digit years in some locales.  */
  strftime (s, m, ""%c"", tp); /* { dg-warning ""some locales"" ""2-digit year"" } */
  strftime (s, m, ""%x"", tp); /* { dg-warning ""some locales"" ""2-digit year"" } */
}
","/* Test for strftime formats.  Formats using C99 features.  */
/* Origin: Joseph Myers <jsm28@cam.ac.uk> */
/* { dg-do compile { target { *-*-mingw* } } } */
/* { dg-options ""-std=iso9899:1999 -pedantic -Wformat -Wformat-y2k"" } */

#define USE_SYSTEM_FORMATS
#include ""format.h""

void
foo (char *s, size_t m, const struct tm *tp)
{
  /* See ISO/IEC 9899:1990 (E) subclause 7.12.3.5 (pages 174-175).  */
  /* Formats which are Y2K-compliant (no 2-digit years).  */
  strftime (s, m, ""%a%A%b%B%d%H%I%j%m%M%p%S%U%w%W%X%Y%z%Z%%"", tp);
  /* Formats with 2-digit years.  */
  strftime (s, m, ""%y"", tp); /* { dg-warning ""only last 2"" ""2-digit year"" } */
  /* Formats with 2-digit years in some locales.  */
  strftime (s, m, ""%c"", tp); /* { dg-warning ""some locales"" ""2-digit year"" } */
  strftime (s, m, ""%x"", tp); /* { dg-warning ""some locales"" ""2-digit year"" } */
}
"
"/* PR c/64856 */
/* { dg-do compile } */
/* { dg-options """" } */

struct A {
  unsigned long b;
};

struct B {
  struct A c[5];
};

struct B d = { .c = { [0 ... 4] = (struct A){ .b = 2 } } };
","/* PR c/64856 */
/* { dg-do compile } */
/* { dg-options """" } */

struct A {
  unsigned long b;
};

struct B {
  struct A c[5];
};

struct B d = { .c = { [0 ... 4] = (struct A){ .b = 2 } } };
"
"/* { dg-do compile } */
/* { dg-options """" } */

struct S { int i, j, k; };

void
foo (void)
{
  struct S s = { .i = 1, .j = 2, .l = 4}; /* { dg-error ""35: .struct S. has no member named .l."" } */
}
","/* { dg-do compile } */
/* { dg-options """" } */

struct S { int i, j, k; };

void
foo (void)
{
  struct S s = { .i = 1, .j = 2, .l = 4}; /* { dg-error ""35: .struct S. has no member named .l."" } */
}
"
"/* { dg-do compile { target ia32 } } */
/* { dg-options ""-O3 -march=x86-64"" } */
/* { dg-final { scan-assembler-not ""cmpl\[ \t]+(\[%a-z]+), \\1"" } } */

short a;
int b = 1, f;
char c, e = 1;
long long d;

static short
foo ()
{
  unsigned g, h = 0;
  int i = 0 || d * (b | e);
  char j = a << i, l = a;
  short k;
  int m = -b;
  if (m < b)
    {
      k = m = b;
      g = (k || l) / (b / e);
      if (b)
	__builtin_printf (""foo=%lld\n"", (long long) a);
    }
  a = b = m;
  if (j || e)
    {
      h = g;
      i = m;
      g = j * k / (i - d);
      if (m)
	b = j && b;
      e = b * (h & d) || g;
    }
  b = i;
  char n = e || h | d;
  e = i < d & k / n;
  return f;
}

int
main ()
{
  if (foo ())
    if (c)
    lab:
      goto lab;
  return 0;
}
","/* { dg-do compile { target ia32 } } */
/* { dg-options ""-O3 -march=x86-64"" } */
/* { dg-final { scan-assembler-not ""cmpl\[ \t]+(\[%a-z]+), \\1"" } } */

short a;
int b = 1, f;
char c, e = 1;
long long d;

static short
foo ()
{
  unsigned g, h = 0;
  int i = 0 || d * (b | e);
  char j = a << i, l = a;
  short k;
  int m = -b;
  if (m < b)
    {
      k = m = b;
      g = (k || l) / (b / e);
      if (b)
	__builtin_printf (""foo=%lld\n"", (long long) a);
    }
  a = b = m;
  if (j || e)
    {
      h = g;
      i = m;
      g = j * k / (i - d);
      if (m)
	b = j && b;
      e = b * (h & d) || g;
    }
  b = i;
  char n = e || h | d;
  e = i < d & k / n;
  return f;
}

int
main ()
{
  if (foo ())
    if (c)
    lab:
      goto lab;
  return 0;
}
"
"/* { dg-do compile { target { powerpc*-*-* } } } */
/* { dg-skip-if ""do not override -mcpu"" { powerpc*-*-* } { ""-mcpu=*"" } { ""-mcpu=power9"" } } */
/* { dg-require-effective-target lp64 } */
/* { dg-require-effective-target powerpc_p9vector_ok } */
/* { dg-options ""-mcpu=power9"" } */

#include <altivec.h>
#include <stdbool.h>

bool
test_neg (__ieee128 *p)
{
  __ieee128 source = *p;

  /* IEEE 128-bit floating point operations are only supported
     on 64-bit targets.  */
  return scalar_test_neg (source);
}

/* { dg-final { scan-assembler ""xststdcqp"" } } */
","/* { dg-do compile { target { powerpc*-*-* } } } */
/* { dg-skip-if ""do not override -mcpu"" { powerpc*-*-* } { ""-mcpu=*"" } { ""-mcpu=power9"" } } */
/* { dg-require-effective-target lp64 } */
/* { dg-require-effective-target powerpc_p9vector_ok } */
/* { dg-options ""-mcpu=power9"" } */

#include <altivec.h>
#include <stdbool.h>

bool
test_neg (__ieee128 *p)
{
  __ieee128 source = *p;

  /* IEEE 128-bit floating point operations are only supported
     on 64-bit targets.  */
  return scalar_test_neg (source);
}

/* { dg-final { scan-assembler ""xststdcqp"" } } */
"
"/* Have to enable optimizations, as otherwise builtins won't be expanded.  */
/* { dg-additional-options ""-O -fdump-rtl-expand -std=c89 -Wno-implicit-function-declaration"" } */

int
f (void)
{
  int r = 0;

  r |= acc_on_device ();
  r |= acc_on_device (1, 2);
  r |= acc_on_device (3.14);
  r |= acc_on_device (""hello"");

  return r;
}

/* Unsuitable to be handled as a builtin, so we're expecting four calls.
   { dg-final { scan-rtl-dump-times ""\\\(call \[^\\n\]* acc_on_device"" 4 ""expand"" } } */

","/* Have to enable optimizations, as otherwise builtins won't be expanded.  */
/* { dg-additional-options ""-O -fdump-rtl-expand -std=c89 -Wno-implicit-function-declaration"" } */

int
f (void)
{
  int r = 0;

  r |= acc_on_device ();
  r |= acc_on_device (1, 2);
  r |= acc_on_device (3.14);
  r |= acc_on_device (""hello"");

  return r;
}

/* Unsuitable to be handled as a builtin, so we're expecting four calls.
   { dg-final { scan-rtl-dump-times ""\\\(call \[^\\n\]* acc_on_device"" 4 ""expand"" } } */

"
"/* { dg-options """" } */
#include <limits.h>

struct s
{
  int i1 : sizeof (int) * CHAR_BIT;
  int i2 : sizeof (int) * CHAR_BIT;
  int i3 : sizeof (int) * CHAR_BIT;
  int i4 : sizeof (int) * CHAR_BIT;
};

int f[sizeof (struct s) != sizeof (int) * 4 ? -1 : 1];
","/* { dg-options """" } */
#include <limits.h>

struct s
{
  int i1 : sizeof (int) * CHAR_BIT;
  int i2 : sizeof (int) * CHAR_BIT;
  int i3 : sizeof (int) * CHAR_BIT;
  int i4 : sizeof (int) * CHAR_BIT;
};

int f[sizeof (struct s) != sizeof (int) * 4 ? -1 : 1];
"
"/* { dg-do run } */
/* { dg-options ""-O2 -mavx512bw -mavx512vl"" } */
/* { dg-require-effective-target avx512vl } */
/* { dg-require-effective-target avx512bw } */

#define AVX512VL
#define AVX512F_LEN 256
#define AVX512F_LEN_HALF 128
#include ""avx512bw-vdbpsadbw-2.c""

#undef AVX512F_LEN
#undef AVX512F_LEN_HALF

#define AVX512F_LEN 128
#define AVX512F_LEN_HALF 128
#include ""avx512bw-vdbpsadbw-2.c""
","/* { dg-do run } */
/* { dg-options ""-O2 -mavx512bw -mavx512vl"" } */
/* { dg-require-effective-target avx512vl } */
/* { dg-require-effective-target avx512bw } */

#define AVX512VL
#define AVX512F_LEN 256
#define AVX512F_LEN_HALF 128
#include ""avx512bw-vdbpsadbw-2.c""

#undef AVX512F_LEN
#undef AVX512F_LEN_HALF

#define AVX512F_LEN 128
#define AVX512F_LEN_HALF 128
#include ""avx512bw-vdbpsadbw-2.c""
"
"/* { dg-do compile } */
/* { dg-options ""-Os -mgeneral-regs-only -mno-cld"" } */


extern void *a;
extern int b;

__attribute__ ((interrupt))
void
foo (void *frame)
{
  __builtin_memset (a, b, 40);
}

/* { dg-final { scan-assembler ""stosb"" } } */
/* { dg-final { scan-assembler-times ""\tcld"" 1 } } */
","/* { dg-do compile } */
/* { dg-options ""-Os -mgeneral-regs-only -mno-cld"" } */


extern void *a;
extern int b;

__attribute__ ((interrupt))
void
foo (void *frame)
{
  __builtin_memset (a, b, 40);
}

/* { dg-final { scan-assembler ""stosb"" } } */
/* { dg-final { scan-assembler-times ""\tcld"" 1 } } */
"
"/* PR c++/24613 */
/* { dg-do compile } */

#pragma omp section	/* { dg-error ""may only be used in"" } */

int i;

void
foo (void)
{
  #pragma omp section	/* { dg-error ""may only be used in"" } */
    i++;
}
","/* PR c++/24613 */
/* { dg-do compile } */

#pragma omp section	/* { dg-error ""may only be used in"" } */

int i;

void
foo (void)
{
  #pragma omp section	/* { dg-error ""may only be used in"" } */
    i++;
}
"
"#include <stdlib.h>
#include <stdio.h>

#include ""libgccjit.h""

#define TEST_COMPILING_TO_FILE
#define OUTPUT_KIND      GCC_JIT_OUTPUT_KIND_ASSEMBLER
#define OUTPUT_FILENAME  ""output-of-test-compile-to-assembler.c.s""
#include ""harness.h""
#include ""create-code-for-hello-world-executable.h""

/* { dg-final { jit-verify-output-file-was-created """" } } */
/* { dg-final { jit-verify-assembler ""hello from ./output-of-test-compile-to-assembler.c.s.exe"" } } */
","#include <stdlib.h>
#include <stdio.h>

#include ""libgccjit.h""

#define TEST_COMPILING_TO_FILE
#define OUTPUT_KIND      GCC_JIT_OUTPUT_KIND_ASSEMBLER
#define OUTPUT_FILENAME  ""output-of-test-compile-to-assembler.c.s""
#include ""harness.h""
#include ""create-code-for-hello-world-executable.h""

/* { dg-final { jit-verify-output-file-was-created """" } } */
/* { dg-final { jit-verify-assembler ""hello from ./output-of-test-compile-to-assembler.c.s.exe"" } } */
"
"/* { dg-do run { target powerpc*-*-* } } */
/* { dg-options ""-O2"" } */
#include <locale.h>
#include <stdlib.h>
register int *testreg asm (""r29"");

int x;
int y;
int *ext_func (int *p) { return p; }

void test_reg_save_restore (int*) __attribute__((noinline));
void
test_reg_save_restore (int *p)
{
    setlocale (LC_ALL, ""C"");
    testreg = ext_func(p);
}
int
main() {
  testreg = &x;
  test_reg_save_restore (&y);
  if (testreg != &y)
    abort ();
  return 0;
}
","/* { dg-do run { target powerpc*-*-* } } */
/* { dg-options ""-O2"" } */
#include <locale.h>
#include <stdlib.h>
register int *testreg asm (""r29"");

int x;
int y;
int *ext_func (int *p) { return p; }

void test_reg_save_restore (int*) __attribute__((noinline));
void
test_reg_save_restore (int *p)
{
    setlocale (LC_ALL, ""C"");
    testreg = ext_func(p);
}
int
main() {
  testreg = &x;
  test_reg_save_restore (&y);
  if (testreg != &y)
    abort ();
  return 0;
}
"
"/* { dg-options ""-O2"" }  */
/* { dg-do compile } */

void foo(int* p)
{
  p[0] = 1;
  p[1] = 0;
}

/* { dg-final { scan-assembler ""strd|stm"" } } */
","/* { dg-options ""-O2"" }  */
/* { dg-do compile } */

void foo(int* p)
{
  p[0] = 1;
  p[1] = 0;
}

/* { dg-final { scan-assembler ""strd|stm"" } } */
"
"/* { dg-do compile } */
/* { dg-options ""-O2 -fdump-tree-vrp1"" } */
     

extern const unsigned char mode_size[];
unsigned int
subreg_highpart_offset (outermode, innermode)
     int outermode, innermode;
{
  unsigned int offset = 0;
  int difference = (mode_size[innermode] - mode_size[outermode]);
  if (difference > 0)
    {
        offset += difference % (0 ? 8 : 4);
	offset += difference / 4 * 4;
    }
  return offset;
}

/* There should be one mask with the value 3.  */
/* { dg-final { scan-tree-dump-times "" \& 3"" 1 ""vrp1""} } */
  
/* There should be one right shift by 2 places.  */
/* { dg-final { scan-tree-dump-times "" >> 2"" 1 ""vrp1""} } */

","/* { dg-do compile } */
/* { dg-options ""-O2 -fdump-tree-vrp1"" } */
     

extern const unsigned char mode_size[];
unsigned int
subreg_highpart_offset (outermode, innermode)
     int outermode, innermode;
{
  unsigned int offset = 0;
  int difference = (mode_size[innermode] - mode_size[outermode]);
  if (difference > 0)
    {
        offset += difference % (0 ? 8 : 4);
	offset += difference / 4 * 4;
    }
  return offset;
}

/* There should be one mask with the value 3.  */
/* { dg-final { scan-tree-dump-times "" \& 3"" 1 ""vrp1""} } */
  
/* There should be one right shift by 2 places.  */
/* { dg-final { scan-tree-dump-times "" >> 2"" 1 ""vrp1""} } */

"
"/* { dg-do compile } */

void
f (long *x, int n)
{
  for (int i = 0; i < n; i++)
    {
      x[i * 2] = 1L << i;
      x[i * 2 + 1] = 1L << i;
    }
}
","/* { dg-do compile } */

void
f (long *x, int n)
{
  for (int i = 0; i < n; i++)
    {
      x[i * 2] = 1L << i;
      x[i * 2 + 1] = 1L << i;
    }
}
"
"/* { dg-do compile } */
/* { dg-options ""-O -fdump-tree-fre1"" } */

int foo (int i)
{
  if (i)
    {
      if (i)
	return 0;
      else
	return 1;
    }
  return 0;
}

/* { dg-final { scan-tree-dump ""return 0;"" ""fre1"" } } */
","/* { dg-do compile } */
/* { dg-options ""-O -fdump-tree-fre1"" } */

int foo (int i)
{
  if (i)
    {
      if (i)
	return 0;
      else
	return 1;
    }
  return 0;
}

/* { dg-final { scan-tree-dump ""return 0;"" ""fre1"" } } */
"
"struct A { int i, j; char pad[512]; } a;

int __attribute__((noinline))
foo (void)
{
  __builtin_memset (&a, 0x26, sizeof a);
  return a.i;
}

void __attribute__((noinline))
bar (void)
{
  __builtin_memset (&a, 0x36, sizeof a);
  a.i = 0x36363636;
  a.j = 0x36373636;
}

int
main (void)
{
  int i;
  if (sizeof (int) != 4 || __CHAR_BIT__ != 8)
    return 0;

  if (foo () != 0x26262626)
    __builtin_abort ();
  for (i = 0; i < sizeof a; i++)
    if (((char *)&a)[i] != 0x26)
      __builtin_abort ();

  bar ();
  if (a.j != 0x36373636)
    __builtin_abort ();
  a.j = 0x36363636;
  for (i = 0; i < sizeof a; i++)
    if (((char *)&a)[i] != 0x36)
      __builtin_abort ();
  return 0;
}
","struct A { int i, j; char pad[512]; } a;

int __attribute__((noinline))
foo (void)
{
  __builtin_memset (&a, 0x26, sizeof a);
  return a.i;
}

void __attribute__((noinline))
bar (void)
{
  __builtin_memset (&a, 0x36, sizeof a);
  a.i = 0x36363636;
  a.j = 0x36373636;
}

int
main (void)
{
  int i;
  if (sizeof (int) != 4 || __CHAR_BIT__ != 8)
    return 0;

  if (foo () != 0x26262626)
    __builtin_abort ();
  for (i = 0; i < sizeof a; i++)
    if (((char *)&a)[i] != 0x26)
      __builtin_abort ();

  bar ();
  if (a.j != 0x36373636)
    __builtin_abort ();
  a.j = 0x36363636;
  for (i = 0; i < sizeof a; i++)
    if (((char *)&a)[i] != 0x36)
      __builtin_abort ();
  return 0;
}
"
"/* { dg-do compile { target pie_enabled } } */
/* { dg-options ""-O2"" } */

int foo (void);

int
main (void)
{
  return foo ();
}

/* { dg-final { scan-assembler ""foo@PLT"" } } */
","/* { dg-do compile { target pie_enabled } } */
/* { dg-options ""-O2"" } */

int foo (void);

int
main (void)
{
  return foo ();
}

/* { dg-final { scan-assembler ""foo@PLT"" } } */
"
"/* { dg-do compile } */ 
/* { dg-options ""-O2 -fdump-tree-thread1-stats -fdump-tree-dom2-stats -fdisable-tree-ethread"" } */

void foo();
void bla();

/* In the following case, we should be able to thread edge through
   the loop header.  */

void thread_latch_through_header (void)
{
  int i = 0;
  int first = 1;

  do
    {
      if (first)
	foo ();

      first = 0;
      bla ();
    } while (i++ < 100);
}

/* Threading the latch to a later point in the loop is safe in this
   case.  And we want to thread through the header as well.  These
   are both caught by threading in DOM.  */
/* { dg-final { scan-tree-dump-not ""Jumps threaded"" ""dom2""} } */
/* { dg-final { scan-tree-dump-times ""Jumps threaded: 1"" 1 ""thread1""} } */
","/* { dg-do compile } */ 
/* { dg-options ""-O2 -fdump-tree-thread1-stats -fdump-tree-dom2-stats -fdisable-tree-ethread"" } */

void foo();
void bla();

/* In the following case, we should be able to thread edge through
   the loop header.  */

void thread_latch_through_header (void)
{
  int i = 0;
  int first = 1;

  do
    {
      if (first)
	foo ();

      first = 0;
      bla ();
    } while (i++ < 100);
}

/* Threading the latch to a later point in the loop is safe in this
   case.  And we want to thread through the header as well.  These
   are both caught by threading in DOM.  */
/* { dg-final { scan-tree-dump-not ""Jumps threaded"" ""dom2""} } */
/* { dg-final { scan-tree-dump-times ""Jumps threaded: 1"" 1 ""thread1""} } */
"
"/* { dg-do run } */
/* { dg-require-effective-target avx2 } */
/* { dg-options ""-O2 -mavx2"" } */

#include <string.h>
#include ""avx2-check.h""

static void
compute_psllvd256 (int *s1, int *s2, int *r)
{
  int i, count;

  for (i = 0; i < 8; ++i)
    {
      count = s2[i];
      r[i] = s1[i] << count;
    }
}

void static
avx2_test (void)
{
  union256i_d s1, s2, res;
  int res_ref[8];
  int i, j, sign = 1;;
  int fail = 0;

  for (i = 0; i < 10; i++)
    {
      for (j = 0; j < 8; j++)
	{
	  s1.a[j] = j * i * sign;
	  s2.a[j] = (j + i) >> 2;
	  sign = -sign;
	}

      res.x = _mm256_sllv_epi32 (s1.x, s2.x);

      compute_psllvd256 (s1.a, s2.a, res_ref);

      fail += check_union256i_d (res, res_ref);
    }

  if (fail != 0)
    abort ();
}
","/* { dg-do run } */
/* { dg-require-effective-target avx2 } */
/* { dg-options ""-O2 -mavx2"" } */

#include <string.h>
#include ""avx2-check.h""

static void
compute_psllvd256 (int *s1, int *s2, int *r)
{
  int i, count;

  for (i = 0; i < 8; ++i)
    {
      count = s2[i];
      r[i] = s1[i] << count;
    }
}

void static
avx2_test (void)
{
  union256i_d s1, s2, res;
  int res_ref[8];
  int i, j, sign = 1;;
  int fail = 0;

  for (i = 0; i < 10; i++)
    {
      for (j = 0; j < 8; j++)
	{
	  s1.a[j] = j * i * sign;
	  s2.a[j] = (j + i) >> 2;
	  sign = -sign;
	}

      res.x = _mm256_sllv_epi32 (s1.x, s2.x);

      compute_psllvd256 (s1.a, s2.a, res_ref);

      fail += check_union256i_d (res, res_ref);
    }

  if (fail != 0)
    abort ();
}
"
"/* PR tree-optimization/42719 */
/* { dg-do compile } */
/* { dg-options ""-O2 -ftracer -fcompare-debug"" } */
/* { dg-xfail-if """" { powerpc-ibm-aix* } } */

int *v;

void
foo (int a)
{
  int i, j;
  for (j = i = a; i != -1; j = i, i = v[i])
    ;
  v[j] = v[a];
}
","/* PR tree-optimization/42719 */
/* { dg-do compile } */
/* { dg-options ""-O2 -ftracer -fcompare-debug"" } */
/* { dg-xfail-if """" { powerpc-ibm-aix* } } */

int *v;

void
foo (int a)
{
  int i, j;
  for (j = i = a; i != -1; j = i, i = v[i])
    ;
  v[j] = v[a];
}
"
"/* { dg-do run } */
/* { dg-options ""-O2 -floop-interchange -fdump-tree-linterchange-details"" } */
/* { dg-skip-if ""too big data segment"" { avr-*-* visium-*-* } } */

#define M 256
int a[M][M], b[M][M];
int __attribute__((noinline))
double_reduc (int n)
{
  int sum = 0;
  for (int j = 0; j < n; j++)
    {
      for (int i = 0; i < n; i++)
	sum = sum + a[i][j]*b[i][j];
    }
  return sum;
}

extern void abort ();

static void __attribute__((noinline))
init (int i)
{
  for (int j = 0; j < M; j++)
    {
      a[i][j] = i;
      b[i][j] = j;
    }
}

int main (void)
{
  for (int i = 0; i < M; ++i)
    init (i);

  int sum = double_reduc (M);

  if (sum != 1065369600)
    abort ();

  return 0;
}

/* { dg-final { scan-tree-dump-times ""Loop_pair<outer:., inner:.> is interchanged"" 1 ""linterchange"" } } */
","/* { dg-do run } */
/* { dg-options ""-O2 -floop-interchange -fdump-tree-linterchange-details"" } */
/* { dg-skip-if ""too big data segment"" { avr-*-* visium-*-* } } */

#define M 256
int a[M][M], b[M][M];
int __attribute__((noinline))
double_reduc (int n)
{
  int sum = 0;
  for (int j = 0; j < n; j++)
    {
      for (int i = 0; i < n; i++)
	sum = sum + a[i][j]*b[i][j];
    }
  return sum;
}

extern void abort ();

static void __attribute__((noinline))
init (int i)
{
  for (int j = 0; j < M; j++)
    {
      a[i][j] = i;
      b[i][j] = j;
    }
}

int main (void)
{
  for (int i = 0; i < M; ++i)
    init (i);

  int sum = double_reduc (M);

  if (sum != 1065369600)
    abort ();

  return 0;
}

/* { dg-final { scan-tree-dump-times ""Loop_pair<outer:., inner:.> is interchanged"" 1 ""linterchange"" } } */
"
"/* PR c/42544 */

extern void abort (void);

int
main ()
{
  signed short s = -1;
  if (sizeof (long long) == sizeof (unsigned int))
    return 0;
  if ((unsigned int) s >= 0x100000000ULL)
    abort ();
  return 0;
}
","/* PR c/42544 */

extern void abort (void);

int
main ()
{
  signed short s = -1;
  if (sizeof (long long) == sizeof (unsigned int))
    return 0;
  if ((unsigned int) s >= 0x100000000ULL)
    abort ();
  return 0;
}
"
"/* { dg-require-effective-target vect_bswap } */

#include ""tree-vect.h""

#define N 128

static inline void
vfoo16 (unsigned short int* a)
{
  int i = 0;
  for (i = 0; i < N; ++i)
    a[i] = __builtin_bswap16 (a[i]);
}

int
main (void)
{
  unsigned short arr[N];
  unsigned short expect[N];
  int i;

  check_vect ();

  for (i = 0; i < N; ++i)
    {
      arr[i] = i;
      expect[i] = __builtin_bswap16 (i);
      asm volatile ("""" ::: ""memory"");
    }

  vfoo16 (arr);

  for (i = 0; i < N; ++i)
    {
      if (arr[i] != expect[i])
        abort ();
    }

  return 0;
}

/* { dg-final { scan-tree-dump-times ""vectorized 1 loops"" 1 ""vect"" } } */
","/* { dg-require-effective-target vect_bswap } */

#include ""tree-vect.h""

#define N 128

static inline void
vfoo16 (unsigned short int* a)
{
  int i = 0;
  for (i = 0; i < N; ++i)
    a[i] = __builtin_bswap16 (a[i]);
}

int
main (void)
{
  unsigned short arr[N];
  unsigned short expect[N];
  int i;

  check_vect ();

  for (i = 0; i < N; ++i)
    {
      arr[i] = i;
      expect[i] = __builtin_bswap16 (i);
      asm volatile ("""" ::: ""memory"");
    }

  vfoo16 (arr);

  for (i = 0; i < N; ++i)
    {
      if (arr[i] != expect[i])
        abort ();
    }

  return 0;
}

/* { dg-final { scan-tree-dump-times ""vectorized 1 loops"" 1 ""vect"" } } */
"
"/* { dg-do run } */
/* { dg-options ""-fno-early-inlining"" } */

extern void abort (void);

union U
{
  int i;
  _Bool b;
};

_Bool gb;

void  __attribute__ ((noinline))
use_bool (union U u)
{
  gb = u.b;
}

union U
bar (void)
{
  union U u;
  u.i = 0xFFFE;
  return u;
}

union U  __attribute__ ((noinline))
foo (void)
{
  union U u,v;

  u.b = 1;
  use_bool (u);
  u = bar ();

  return u;
}

int main (int argc, char **argv)
{
  union U u = foo ();
  if (u.i != 0xFFFE)
    abort ();
  return 0;
}
","/* { dg-do run } */
/* { dg-options ""-fno-early-inlining"" } */

extern void abort (void);

union U
{
  int i;
  _Bool b;
};

_Bool gb;

void  __attribute__ ((noinline))
use_bool (union U u)
{
  gb = u.b;
}

union U
bar (void)
{
  union U u;
  u.i = 0xFFFE;
  return u;
}

union U  __attribute__ ((noinline))
foo (void)
{
  union U u,v;

  u.b = 1;
  use_bool (u);
  u = bar ();

  return u;
}

int main (int argc, char **argv)
{
  union U u = foo ();
  if (u.i != 0xFFFE)
    abort ();
  return 0;
}
"
"#include <arm_neon.h>

/* { dg-do compile } */
/* { dg-skip-if """" { *-*-* } { ""-fno-fat-lto-objects"" } } */
/* { dg-skip-if """" { arm*-*-* } } */

uint8x16x3_t
f_vld3q_lane_u8 (uint8_t * p, uint8x16x3_t v)
{
  uint8x16x3_t res;
  /* { dg-error ""lane 16 out of range 0 - 15"" """" { target *-*-* } 0 } */
  res = vld3q_lane_u8 (p, v, 16);
  /* { dg-error ""lane -1 out of range 0 - 15"" """" { target *-*-* } 0 } */
  res = vld3q_lane_u8 (p, v, -1);
  return res;
}
","#include <arm_neon.h>

/* { dg-do compile } */
/* { dg-skip-if """" { *-*-* } { ""-fno-fat-lto-objects"" } } */
/* { dg-skip-if """" { arm*-*-* } } */

uint8x16x3_t
f_vld3q_lane_u8 (uint8_t * p, uint8x16x3_t v)
{
  uint8x16x3_t res;
  /* { dg-error ""lane 16 out of range 0 - 15"" """" { target *-*-* } 0 } */
  res = vld3q_lane_u8 (p, v, 16);
  /* { dg-error ""lane -1 out of range 0 - 15"" """" { target *-*-* } 0 } */
  res = vld3q_lane_u8 (p, v, -1);
  return res;
}
"
"/* { dg-do run } */

extern void abort (void) __attribute__((noreturn));

union setconflict
{
  int a[20];
  long b[10];
};

int
main ()
{
  int sum = 0;
  {
    union setconflict a;
    int *c;
    c = a.a;
    asm ("""": ""=r"" (c):""0"" (c));
    *c = 0;
    asm ("""": ""=r"" (c):""0"" (c));
    sum += *c;
  }
  {
    union setconflict a;
    long *c;
    c = a.b;
    asm ("""": ""=r"" (c):""0"" (c));
    *c = 1;
    asm ("""": ""=r"" (c):""0"" (c));
    sum += *c;
  }

  if (sum != 1)
    abort();
  return 0;
}
","/* { dg-do run } */

extern void abort (void) __attribute__((noreturn));

union setconflict
{
  int a[20];
  long b[10];
};

int
main ()
{
  int sum = 0;
  {
    union setconflict a;
    int *c;
    c = a.a;
    asm ("""": ""=r"" (c):""0"" (c));
    *c = 0;
    asm ("""": ""=r"" (c):""0"" (c));
    sum += *c;
  }
  {
    union setconflict a;
    long *c;
    c = a.b;
    asm ("""": ""=r"" (c):""0"" (c));
    *c = 1;
    asm ("""": ""=r"" (c):""0"" (c));
    sum += *c;
  }

  if (sum != 1)
    abort();
  return 0;
}
"
"/* { dg-do compile } */
/* { dg-options ""-mavx512vl -O2"" } */
/* { dg-final { scan-assembler-times ""vpord\[ \\t\]+\[^\{\n\]*%ymm\[0-9\]+\{%k\[1-7\]\}(?:\n|\[ \\t\]+#)"" 1 } } */
/* { dg-final { scan-assembler-times ""vpord\[ \\t\]+\[^\{\n\]*%ymm\[0-9\]+\{%k\[1-7\]\}\{z\}(?:\n|\[ \\t\]+#)"" 1 } } */
/* { dg-final { scan-assembler-times ""vpord\[ \\t\]+\[^\{\n\]*%xmm\[0-9\]+\{%k\[1-7\]\}(?:\n|\[ \\t\]+#)"" 1 } } */
/* { dg-final { scan-assembler-times ""vpord\[ \\t\]+\[^\{\n\]*%xmm\[0-9\]+\{%k\[1-7\]\}\{z\}(?:\n|\[ \\t\]+#)"" 1 } } */

#include <immintrin.h>

volatile __m256i y;
volatile __m128i x;
volatile __mmask8 m;

void extern
avx512vl_test (void)
{
  y = _mm256_mask_or_epi32 (y, m, y, y);
  y = _mm256_maskz_or_epi32 (m, y, y);

  x = _mm_mask_or_epi32 (x, m, x, x);
  x = _mm_maskz_or_epi32 (m, x, x);
}
","/* { dg-do compile } */
/* { dg-options ""-mavx512vl -O2"" } */
/* { dg-final { scan-assembler-times ""vpord\[ \\t\]+\[^\{\n\]*%ymm\[0-9\]+\{%k\[1-7\]\}(?:\n|\[ \\t\]+#)"" 1 } } */
/* { dg-final { scan-assembler-times ""vpord\[ \\t\]+\[^\{\n\]*%ymm\[0-9\]+\{%k\[1-7\]\}\{z\}(?:\n|\[ \\t\]+#)"" 1 } } */
/* { dg-final { scan-assembler-times ""vpord\[ \\t\]+\[^\{\n\]*%xmm\[0-9\]+\{%k\[1-7\]\}(?:\n|\[ \\t\]+#)"" 1 } } */
/* { dg-final { scan-assembler-times ""vpord\[ \\t\]+\[^\{\n\]*%xmm\[0-9\]+\{%k\[1-7\]\}\{z\}(?:\n|\[ \\t\]+#)"" 1 } } */

#include <immintrin.h>

volatile __m256i y;
volatile __m128i x;
volatile __mmask8 m;

void extern
avx512vl_test (void)
{
  y = _mm256_mask_or_epi32 (y, m, y, y);
  y = _mm256_maskz_or_epi32 (m, y, y);

  x = _mm_mask_or_epi32 (x, m, x, x);
  x = _mm_maskz_or_epi32 (m, x, x);
}
"
"/* { dg-do run } */
/* { dg-require-effective-target avx } */
/* { dg-options ""-O2 -mfpmath=sse -mavx"" } */

#define CHECK_H ""avx-check.h""
#define TEST avx_test

#include ""sse4_1-roundpd-1.c""
","/* { dg-do run } */
/* { dg-require-effective-target avx } */
/* { dg-options ""-O2 -mfpmath=sse -mavx"" } */

#define CHECK_H ""avx-check.h""
#define TEST avx_test

#include ""sse4_1-roundpd-1.c""
"
"/* { dg-do compile } */
/* { dg-options ""-mavx512f -O2"" } */
/* { dg-final { scan-assembler-times ""vpcmpuq\[ \\t\]+\[^\{\n\]*%zmm\[0-9\]+\[^\n^k\]*%k\[0-7\](?:\n|\[ \\t\]+#)"" 1 } } */
/* { dg-final { scan-assembler-times ""vpcmpuq\[ \\t\]+\[^\{\n\]*%zmm\[0-9\]+\[^\n^k\]*%k\[0-7\]\{%k\[0-7\]\}(?:\n|\[ \\t\]+#)"" 1 } } */

#include <immintrin.h>

volatile __m512i x;
volatile __mmask8 m;

void extern
avx512f_test (void)
{
  m = _mm512_cmple_epu64_mask (x, x);
  m = _mm512_mask_cmple_epu64_mask (m, x, x);
}
","/* { dg-do compile } */
/* { dg-options ""-mavx512f -O2"" } */
/* { dg-final { scan-assembler-times ""vpcmpuq\[ \\t\]+\[^\{\n\]*%zmm\[0-9\]+\[^\n^k\]*%k\[0-7\](?:\n|\[ \\t\]+#)"" 1 } } */
/* { dg-final { scan-assembler-times ""vpcmpuq\[ \\t\]+\[^\{\n\]*%zmm\[0-9\]+\[^\n^k\]*%k\[0-7\]\{%k\[0-7\]\}(?:\n|\[ \\t\]+#)"" 1 } } */

#include <immintrin.h>

volatile __m512i x;
volatile __mmask8 m;

void extern
avx512f_test (void)
{
  m = _mm512_cmple_epu64_mask (x, x);
  m = _mm512_mask_cmple_epu64_mask (m, x, x);
}
"
"/* { dg-options ""-fno-common isa_rev<=5 -mabi=n32 (REQUIRES_STDLIB)"" } */
/* { dg-skip-if ""code quality test"" { *-*-* } { ""-O0"" ""-Os""} { """" } } */
/* { dg-final { scan-assembler-not ""\tmemcpy"" } } */
/* { dg-final { scan-assembler-times ""sdl"" 4 } } */
/* { dg-final { scan-assembler-times ""sdr"" 4 } } */

/* Test that inline memcpy for hardware with sdl, sdr handles subword
   alignment and produces enough sdr/sdls on n32.  */

#include <string.h>

char c[40] __attribute__ ((aligned(2)));

void
f1 ()
{
  memcpy (c, ""1234567890QWERTYUIOPASDFGHJKLZXCVBNM"", 32);
}
","/* { dg-options ""-fno-common isa_rev<=5 -mabi=n32 (REQUIRES_STDLIB)"" } */
/* { dg-skip-if ""code quality test"" { *-*-* } { ""-O0"" ""-Os""} { """" } } */
/* { dg-final { scan-assembler-not ""\tmemcpy"" } } */
/* { dg-final { scan-assembler-times ""sdl"" 4 } } */
/* { dg-final { scan-assembler-times ""sdr"" 4 } } */

/* Test that inline memcpy for hardware with sdl, sdr handles subword
   alignment and produces enough sdr/sdls on n32.  */

#include <string.h>

char c[40] __attribute__ ((aligned(2)));

void
f1 ()
{
  memcpy (c, ""1234567890QWERTYUIOPASDFGHJKLZXCVBNM"", 32);
}
"
"int g_21;
int g_211;
int g_261;

static void __attribute__((noinline,noclone))
func_32 (int b)
{
  if (b) {
lbl_370:
      g_21 = 1;
  }

  for (g_261 = -1; g_261 > -2; g_261--) {
      if (g_211 + 1) {
	  return;
      } else {
	  g_21 = 1;
	  goto lbl_370;
      }
  }
}

extern void abort (void);

int main(void)
{
  func_32(0);
  if (g_261 != -1)
    abort ();
  return 0;
}
","int g_21;
int g_211;
int g_261;

static void __attribute__((noinline,noclone))
func_32 (int b)
{
  if (b) {
lbl_370:
      g_21 = 1;
  }

  for (g_261 = -1; g_261 > -2; g_261--) {
      if (g_211 + 1) {
	  return;
      } else {
	  g_21 = 1;
	  goto lbl_370;
      }
  }
}

extern void abort (void);

int main(void)
{
  func_32(0);
  if (g_261 != -1)
    abort ();
  return 0;
}
"
"/* { dg-do compile } */
/* { dg-skip-if """" { *-*-* } { ""-mtune=*"" } { """" } } */
/* { dg-options ""-mtune=foo"" } */
/* { dg-error ""mtune"" ""mtune"" { target *-*-* } 0 } */
/* { dg-bogus ""march"" ""march"" { target *-*-* } 0 } */
/* { dg-bogus ""mcpu"" ""mcpu"" { target *-*-* } 0 } */
/* { dg-prune-output ""note: valid arguments.*"" } */
int i;
","/* { dg-do compile } */
/* { dg-skip-if """" { *-*-* } { ""-mtune=*"" } { """" } } */
/* { dg-options ""-mtune=foo"" } */
/* { dg-error ""mtune"" ""mtune"" { target *-*-* } 0 } */
/* { dg-bogus ""march"" ""march"" { target *-*-* } 0 } */
/* { dg-bogus ""mcpu"" ""mcpu"" { target *-*-* } 0 } */
/* { dg-prune-output ""note: valid arguments.*"" } */
int i;
"
"/* { dg-do compile } */
/* { dg-options ""-O2 -ftree-loop-distribution"" } */

__extension__ typedef __SIZE_TYPE__ size_t;
typedef struct   {
          long dat[2];
} gsl_complex_long_double;
typedef struct {
 size_t size;
 size_t stride;
 long *data;
} gsl_vector_complex_long_double;

void gsl_vector_complex_long_double_set_zero (gsl_vector_complex_long_double * v) 
{
 long * const data = v->data;
 const size_t n = v->size;
 const size_t stride = v->stride;
 const gsl_complex_long_double zero = { { 0,0} } ;
 size_t i;
 for (i = 0; i < n; i++)     
  *(gsl_complex_long_double *) (data + 2 * i * stride) = zero;
}

","/* { dg-do compile } */
/* { dg-options ""-O2 -ftree-loop-distribution"" } */

__extension__ typedef __SIZE_TYPE__ size_t;
typedef struct   {
          long dat[2];
} gsl_complex_long_double;
typedef struct {
 size_t size;
 size_t stride;
 long *data;
} gsl_vector_complex_long_double;

void gsl_vector_complex_long_double_set_zero (gsl_vector_complex_long_double * v) 
{
 long * const data = v->data;
 const size_t n = v->size;
 const size_t stride = v->stride;
 const gsl_complex_long_double zero = { { 0,0} } ;
 size_t i;
 for (i = 0; i < n; i++)     
  *(gsl_complex_long_double *) (data + 2 * i * stride) = zero;
}

"
"struct T { int a; int *b; };
struct S { int *s; char u; struct T v; long x; };

void bar (int *);
#pragma omp declare target to (bar)

int
main ()
{
  int a[10] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
  struct S s = { a, 5, { 6, a + 5 }, 99L };
  #pragma omp target map (s.v.a, s.u, s.x)
  ;
  #pragma omp target map (s.v.a, s.u, s.x)
  bar (&s.v.a);
  #pragma omp target map (s.v.a) map (always, to: s.u) map (s.x)
  ;
  #pragma omp target map (s.s[0]) map (s.v.b[:3])
  ;
  #pragma omp target map (s.s[0]) map (s.v.b[:3])
  bar (s.s);
  return 0;
}
","struct T { int a; int *b; };
struct S { int *s; char u; struct T v; long x; };

void bar (int *);
#pragma omp declare target to (bar)

int
main ()
{
  int a[10] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
  struct S s = { a, 5, { 6, a + 5 }, 99L };
  #pragma omp target map (s.v.a, s.u, s.x)
  ;
  #pragma omp target map (s.v.a, s.u, s.x)
  bar (&s.v.a);
  #pragma omp target map (s.v.a) map (always, to: s.u) map (s.x)
  ;
  #pragma omp target map (s.s[0]) map (s.v.b[:3])
  ;
  #pragma omp target map (s.s[0]) map (s.v.b[:3])
  bar (s.s);
  return 0;
}
"
"/* { dg-do compile } */

int a, b, c;

int
main ()
{
  for (; c; c++)
    for (a = 0; a < 4; a++)
      {
	c &= 5;
	for (b = 0; b < 2; b++)
	  c |= 1;
      }
  return 0; 
}
","/* { dg-do compile } */

int a, b, c;

int
main ()
{
  for (; c; c++)
    for (a = 0; a < 4; a++)
      {
	c &= 5;
	for (b = 0; b < 2; b++)
	  c |= 1;
      }
  return 0; 
}
"
"/* { dg-do run } */
/* { dg-require-effective-target avx } */
/* { dg-options ""-O2 -mavx"" } */

#define CHECK_H ""avx-check.h""
#define TEST avx_test

#include ""sse2-psubb-1.c""
","/* { dg-do run } */
/* { dg-require-effective-target avx } */
/* { dg-options ""-O2 -mavx"" } */

#define CHECK_H ""avx-check.h""
#define TEST avx_test

#include ""sse2-psubb-1.c""
"
"/* { dg-do run } */
/* { dg-options ""-O3 -mpower8-vector -Wno-psabi"" } */
/* { dg-require-effective-target lp64 } */
/* { dg-require-effective-target p8vector_hw } */

#define NO_WARN_X86_INTRINSICS 1

#ifndef CHECK_H
#define CHECK_H ""sse-check.h""
#endif

#include CHECK_H

#ifndef TEST
#define TEST sse_test_rcpps_1
#endif

#include <xmmintrin.h>

static __m128
__attribute__((noinline, unused))
test (__m128 s1)
{
  return _mm_rcp_ps (s1); 
}

static void
TEST (void)
{
  union128 u, s1;
  float e[4];
  int i;
   
  s1.x = _mm_set_ps (24.43, 68.346, 43.35, 546.46);
  u.x = test (s1.x); 
  
  for (i = 0; i < 4; i++)
    {
      __m128 tmp = _mm_load_ss (&s1.a[i]);
      tmp = _mm_rcp_ss (tmp);
      _mm_store_ss (&e[i], tmp);
    }

  if (check_union128 (u, e))
    abort ();
}
","/* { dg-do run } */
/* { dg-options ""-O3 -mpower8-vector -Wno-psabi"" } */
/* { dg-require-effective-target lp64 } */
/* { dg-require-effective-target p8vector_hw } */

#define NO_WARN_X86_INTRINSICS 1

#ifndef CHECK_H
#define CHECK_H ""sse-check.h""
#endif

#include CHECK_H

#ifndef TEST
#define TEST sse_test_rcpps_1
#endif

#include <xmmintrin.h>

static __m128
__attribute__((noinline, unused))
test (__m128 s1)
{
  return _mm_rcp_ps (s1); 
}

static void
TEST (void)
{
  union128 u, s1;
  float e[4];
  int i;
   
  s1.x = _mm_set_ps (24.43, 68.346, 43.35, 546.46);
  u.x = test (s1.x); 
  
  for (i = 0; i < 4; i++)
    {
      __m128 tmp = _mm_load_ss (&s1.a[i]);
      tmp = _mm_rcp_ss (tmp);
      _mm_store_ss (&e[i], tmp);
    }

  if (check_union128 (u, e))
    abort ();
}
"
"/* { dg-do compile } */
/* { dg-options ""-O1 -fdump-tree-cddce3"" } */
      
extern void abort (void);

struct rtx_def;
typedef struct rtx_def *rtx;
enum rtx_code
{
  UNKNOWN,
  CODE_LABEL,
  NOTE,
  LAST_AND_UNUSED_RTX_CODE = 256
};
typedef union rtunion_def rtunion;
struct rtx_def
{
  enum rtx_code code:16;
};
void
delete_dead_jumptables ()
{
  rtx insn, next;
  if (insn->code == CODE_LABEL)
    {
      rtx const _rtx = insn;
      if (_rtx->code != CODE_LABEL && _rtx->code != NOTE)
	abort ();
    }
  ;
}

/* There should be no loads of ->code.  If any exist, then we failed to
   optimize away all the IF statements and the statements feeding
   their conditions.  */
/* { dg-final { scan-tree-dump-times ""->code"" 0 ""cddce3""} } */
   
/* There should be no IF statements.  */
/* { dg-final { scan-tree-dump-times ""if "" 0 ""cddce3""} } */

","/* { dg-do compile } */
/* { dg-options ""-O1 -fdump-tree-cddce3"" } */
      
extern void abort (void);

struct rtx_def;
typedef struct rtx_def *rtx;
enum rtx_code
{
  UNKNOWN,
  CODE_LABEL,
  NOTE,
  LAST_AND_UNUSED_RTX_CODE = 256
};
typedef union rtunion_def rtunion;
struct rtx_def
{
  enum rtx_code code:16;
};
void
delete_dead_jumptables ()
{
  rtx insn, next;
  if (insn->code == CODE_LABEL)
    {
      rtx const _rtx = insn;
      if (_rtx->code != CODE_LABEL && _rtx->code != NOTE)
	abort ();
    }
  ;
}

/* There should be no loads of ->code.  If any exist, then we failed to
   optimize away all the IF statements and the statements feeding
   their conditions.  */
/* { dg-final { scan-tree-dump-times ""->code"" 0 ""cddce3""} } */
   
/* There should be no IF statements.  */
/* { dg-final { scan-tree-dump-times ""if "" 0 ""cddce3""} } */

"
"// { dg-do preprocess }

"""" /*  { dg-warning ""null character"" } */
"""" /*  { dg-warning ""null character"" } */
"""" /*  { dg-warning ""null character"" } */
"""" /*  { dg-warning ""null character"" } */
"""" /*  { dg-warning ""null character"" } */
","// { dg-do preprocess }

"""" /*  { dg-warning ""null character"" } */
"""" /*  { dg-warning ""null character"" } */
"""" /*  { dg-warning ""null character"" } */
"""" /*  { dg-warning ""null character"" } */
"""" /*  { dg-warning ""null character"" } */
"
"/* { dg-do compile } */
/* { dg-options ""-O1 -fdump-tree-phiopt1-details"" } */

int t( int i)
{
  int j;
  if(i ==0)
  {
   j = 1;
   goto end;
  }
  j = 0;
end:
  return j;
}

/* Should have no ifs left after straightening.  */
/* { dg-final { scan-tree-dump-times ""if "" 0 ""phiopt1""} } */
","/* { dg-do compile } */
/* { dg-options ""-O1 -fdump-tree-phiopt1-details"" } */

int t( int i)
{
  int j;
  if(i ==0)
  {
   j = 1;
   goto end;
  }
  j = 0;
end:
  return j;
}

/* Should have no ifs left after straightening.  */
/* { dg-final { scan-tree-dump-times ""if "" 0 ""phiopt1""} } */
"
"/* { dg-do run } */
/* { dg-skip-if ""Stack alignment is too small"" { hppa*-*-hpux* } } */
/* { dg-require-effective-target alloca } */

#include <stdarg.h>
#include ""check.h""

#ifndef ALIGNMENT
#define ALIGNMENT	64
#endif

typedef int aligned __attribute__((aligned(ALIGNMENT)));

int global;

void
bar (char *p, int size)
{
  __builtin_strncpy (p, ""good"", size);
}

void
foo (const char *fmt, ...)
{
  va_list arg;
  char *p;
  aligned i;
  int size;
  double x;

  va_start (arg, fmt);
  size = va_arg (arg, int);
  if (size != 5)
    abort ();
  p = __builtin_alloca (size + 1);

  x = va_arg (arg, double);
  if (x != 5.0)
    abort ();

  bar (p, size);
  if (__builtin_strncmp (p, ""good"", size) != 0)
    {
#ifdef DEBUG
      p[size] = '\0';
      printf (""Failed: %s != good\n"", p);
#endif
      abort ();
    }

  if (check_int (&i,  __alignof__(i)) != i)
    abort ();
  va_end (arg);
}

int
main()
{
  foo (""foo"", 5, 5.0);
  return 0;
}
","/* { dg-do run } */
/* { dg-skip-if ""Stack alignment is too small"" { hppa*-*-hpux* } } */
/* { dg-require-effective-target alloca } */

#include <stdarg.h>
#include ""check.h""

#ifndef ALIGNMENT
#define ALIGNMENT	64
#endif

typedef int aligned __attribute__((aligned(ALIGNMENT)));

int global;

void
bar (char *p, int size)
{
  __builtin_strncpy (p, ""good"", size);
}

void
foo (const char *fmt, ...)
{
  va_list arg;
  char *p;
  aligned i;
  int size;
  double x;

  va_start (arg, fmt);
  size = va_arg (arg, int);
  if (size != 5)
    abort ();
  p = __builtin_alloca (size + 1);

  x = va_arg (arg, double);
  if (x != 5.0)
    abort ();

  bar (p, size);
  if (__builtin_strncmp (p, ""good"", size) != 0)
    {
#ifdef DEBUG
      p[size] = '\0';
      printf (""Failed: %s != good\n"", p);
#endif
      abort ();
    }

  if (check_int (&i,  __alignof__(i)) != i)
    abort ();
  va_end (arg);
}

int
main()
{
  foo (""foo"", 5, 5.0);
  return 0;
}
"
"/* { dg-do compile } */
/* { dg-options ""-O2 -mavx512f"" } */
/* { dg-final { scan-assembler-times ""vshufps\[ \\t\]+\[^\{\n\]*%zmm\[0-9\]+(?:\n|\[ \\t\]+#)""  1 } } */
/* { dg-final { scan-assembler-times ""vshufps\[ \\t\]+\[^\{\n\]*%zmm\[0-9\]+\{%k\[1-7\]\}(?:\n|\[ \\t\]+#)"" 1 } } */
/* { dg-final { scan-assembler-times ""vshufps\[ \\t\]+\[^\{\n\]*%zmm\[0-9\]+\{%k\[1-7\]\}\{z\}(?:\n|\[ \\t\]+#)"" 1 } } */

#include <immintrin.h>

__m512 x;

void extern
avx512f_test (void)
{
  x = _mm512_shuffle_ps (x, x, 56);
  x = _mm512_mask_shuffle_ps (x, 2, x, x, 56);
  x = _mm512_maskz_shuffle_ps (2, x, x, 56);
}
","/* { dg-do compile } */
/* { dg-options ""-O2 -mavx512f"" } */
/* { dg-final { scan-assembler-times ""vshufps\[ \\t\]+\[^\{\n\]*%zmm\[0-9\]+(?:\n|\[ \\t\]+#)""  1 } } */
/* { dg-final { scan-assembler-times ""vshufps\[ \\t\]+\[^\{\n\]*%zmm\[0-9\]+\{%k\[1-7\]\}(?:\n|\[ \\t\]+#)"" 1 } } */
/* { dg-final { scan-assembler-times ""vshufps\[ \\t\]+\[^\{\n\]*%zmm\[0-9\]+\{%k\[1-7\]\}\{z\}(?:\n|\[ \\t\]+#)"" 1 } } */

#include <immintrin.h>

__m512 x;

void extern
avx512f_test (void)
{
  x = _mm512_shuffle_ps (x, x, 56);
  x = _mm512_mask_shuffle_ps (x, 2, x, x, 56);
  x = _mm512_maskz_shuffle_ps (2, x, x, 56);
}
"
"/* { dg-do compile } */
/* { dg-options ""-O2 -ftree-parallelize-loops=2 -fdump-tree-parloops2-details"" } */

/* Constant bound, vector addition.  */

#define N 1000

unsigned int a[N];
unsigned int b[N];
unsigned int c[N];

void
f (void)
{
  int i;

    for (i = 0; i < N; ++i)
      c[i] = a[i] + b[i];
}

/* { dg-final { scan-tree-dump-times ""alternative exit-first loop transform succeeded"" 1 ""parloops2"" } } */
","/* { dg-do compile } */
/* { dg-options ""-O2 -ftree-parallelize-loops=2 -fdump-tree-parloops2-details"" } */

/* Constant bound, vector addition.  */

#define N 1000

unsigned int a[N];
unsigned int b[N];
unsigned int c[N];

void
f (void)
{
  int i;

    for (i = 0; i < N; ++i)
      c[i] = a[i] + b[i];
}

/* { dg-final { scan-tree-dump-times ""alternative exit-first loop transform succeeded"" 1 ""parloops2"" } } */
"
"/* { dg-do assemble } */
/* { dg-options ""-std=c99"" } */
#include <arm_neon.h>

int
main (int argc, char **argv)
{
  uint64x1_t base_a = vcreate_u64 (0x1111222233334444ULL);
  uint64x1_t base_b = vcreate_u64 (0x5555666677778888ULL);
  uint64x2_t baseq_a = vcombine_u64 (base_a, base_b);
  uint64x1_t base_c = vcreate_u64 (0x9999aaaabbbbccccULL);
  uint64x2_t baseq_b = vcombine_u64 (base_b, base_c);
  int16x8_t int16x8_a = vreinterpretq_s16_u64 (baseq_a);
  int16x8_t int16x8_b = vreinterpretq_s16_u64 (baseq_b);

  /* { dg-error ""lane -1 out of range 0 - 7"" """" {target *-*-*} 0 } */
  vqrdmulhq_laneq_s16 (int16x8_a, int16x8_b, -1);
  /* { dg-error ""lane 8 out of range 0 - 7"" """" {target *-*-*} 0 } */
  vqrdmulhq_laneq_s16 (int16x8_a, int16x8_b, 8);
}
","/* { dg-do assemble } */
/* { dg-options ""-std=c99"" } */
#include <arm_neon.h>

int
main (int argc, char **argv)
{
  uint64x1_t base_a = vcreate_u64 (0x1111222233334444ULL);
  uint64x1_t base_b = vcreate_u64 (0x5555666677778888ULL);
  uint64x2_t baseq_a = vcombine_u64 (base_a, base_b);
  uint64x1_t base_c = vcreate_u64 (0x9999aaaabbbbccccULL);
  uint64x2_t baseq_b = vcombine_u64 (base_b, base_c);
  int16x8_t int16x8_a = vreinterpretq_s16_u64 (baseq_a);
  int16x8_t int16x8_b = vreinterpretq_s16_u64 (baseq_b);

  /* { dg-error ""lane -1 out of range 0 - 7"" """" {target *-*-*} 0 } */
  vqrdmulhq_laneq_s16 (int16x8_a, int16x8_b, -1);
  /* { dg-error ""lane 8 out of range 0 - 7"" """" {target *-*-*} 0 } */
  vqrdmulhq_laneq_s16 (int16x8_a, int16x8_b, 8);
}
"
"/* { dg-do compile } */
/* { dg-options ""-O2 -fcf-protection"" } */
/* { dg-final { scan-assembler-times {\mendbr} 2 } } */

static void
test (void)
{
}

void *
bar (void)
{
  return test;
}
","/* { dg-do compile } */
/* { dg-options ""-O2 -fcf-protection"" } */
/* { dg-final { scan-assembler-times {\mendbr} 2 } } */

static void
test (void)
{
}

void *
bar (void)
{
  return test;
}
"
"/* { dg-do compile { target *-*-darwin* } } */
/* { dg-require-weak """" } */
/* { dg-options ""-fno-common -fno-asynchronous-unwind-tables"" } */

/* { dg-final { scan-assembler ""weak_reference _a"" } } */
/* { dg-final { scan-assembler-not ""weak_\[a-z \t\]*_b"" } } */

extern void a (void) __attribute__((weak_import));
extern void b (void) __attribute__((weak_import));

void b(void)
{
  a();
}
","/* { dg-do compile { target *-*-darwin* } } */
/* { dg-require-weak """" } */
/* { dg-options ""-fno-common -fno-asynchronous-unwind-tables"" } */

/* { dg-final { scan-assembler ""weak_reference _a"" } } */
/* { dg-final { scan-assembler-not ""weak_\[a-z \t\]*_b"" } } */

extern void a (void) __attribute__((weak_import));
extern void b (void) __attribute__((weak_import));

void b(void)
{
  a();
}
"
"/* { dg-do compile { target { powerpc*-*-* } } } */
/* { dg-skip-if ""do not override -mcpu"" { powerpc*-*-* } { ""-mcpu=*"" } { ""-mcpu=power9"" } } */
/* { dg-require-effective-target powerpc_p9vector_ok } */
/* { dg-options ""-mcpu=power9"" } */

#include <altivec.h>

vector bool char
fetch_data (vector unsigned char *arg1_p, vector unsigned char *arg2_p)
{
  vector unsigned char arg_1 = *arg1_p;
  vector unsigned char arg_2 = *arg2_p;

  return vec_cmpnez (arg_1, arg_2);
}

/* { dg-final { scan-assembler ""vcmpnezb"" } } */
","/* { dg-do compile { target { powerpc*-*-* } } } */
/* { dg-skip-if ""do not override -mcpu"" { powerpc*-*-* } { ""-mcpu=*"" } { ""-mcpu=power9"" } } */
/* { dg-require-effective-target powerpc_p9vector_ok } */
/* { dg-options ""-mcpu=power9"" } */

#include <altivec.h>

vector bool char
fetch_data (vector unsigned char *arg1_p, vector unsigned char *arg2_p)
{
  vector unsigned char arg_1 = *arg1_p;
  vector unsigned char arg_2 = *arg2_p;

  return vec_cmpnez (arg_1, arg_2);
}

/* { dg-final { scan-assembler ""vcmpnezb"" } } */
"
"/* { dg-lto-do link } */
/* { dg-lto-options { { -flto -w } } } */

char s[sizeof (char *)];
int main(void)
{
  return strcmp(&s[1], ""foo"");
}
","/* { dg-lto-do link } */
/* { dg-lto-options { { -flto -w } } } */

char s[sizeof (char *)];
int main(void)
{
  return strcmp(&s[1], ""foo"");
}
"
"/* { dg-do run } */

int l_5_5_2 = 4;
int g_3[1][1];

void func_1 (void)
{
  for (g_3[0][0] = 1; g_3[0][0] < 8; g_3[0][0] += 7) {
    int *l_6 = &g_3[0][0];
    *l_6 = l_5_5_2;
  }
}

int main (void)
{
  func_1 ();
  if (g_3[0][0] != 11)
      __builtin_abort ();
  return 0;
}
","/* { dg-do run } */

int l_5_5_2 = 4;
int g_3[1][1];

void func_1 (void)
{
  for (g_3[0][0] = 1; g_3[0][0] < 8; g_3[0][0] += 7) {
    int *l_6 = &g_3[0][0];
    *l_6 = l_5_5_2;
  }
}

int main (void)
{
  func_1 ();
  if (g_3[0][0] != 11)
      __builtin_abort ();
  return 0;
}
"
"/* Test generation of macchwu. on 405.  */
/* Origin: Joseph Myers <joseph@codesourcery.com> */
/* { dg-do compile } */
/* { dg-require-effective-target ilp32 } */
/* { dg-options ""-O2 -mcpu=405"" } */
/* { dg-skip-if ""other options override -mcpu=405"" { ! powerpc_405_nocache } } */

/* { dg-final { scan-assembler ""macchwu\\. "" } } */

unsigned int
f(unsigned int a, unsigned int b, unsigned int c)
{
  a += (unsigned short)b * (c >> 16);
  if (!a)
    return 10;
  return a;
}
","/* Test generation of macchwu. on 405.  */
/* Origin: Joseph Myers <joseph@codesourcery.com> */
/* { dg-do compile } */
/* { dg-require-effective-target ilp32 } */
/* { dg-options ""-O2 -mcpu=405"" } */
/* { dg-skip-if ""other options override -mcpu=405"" { ! powerpc_405_nocache } } */

/* { dg-final { scan-assembler ""macchwu\\. "" } } */

unsigned int
f(unsigned int a, unsigned int b, unsigned int c)
{
  a += (unsigned short)b * (c >> 16);
  if (!a)
    return 10;
  return a;
}
"
"/* PR target/79568 */
/* { dg-do compile } */
/* { dg-options ""-mno-sahf -mno-mmx -mno-sse"" } */
/* { dg-additional-options ""-march=i386"" { target ia32 } } */

#pragma GCC push_options
#pragma GCC target (""sse"")
void
foo (void)
{
  __builtin_ia32_pause ();
}
#pragma GCC pop_options

void
bar (void)
{
  __builtin_ia32_pause ();
}
","/* PR target/79568 */
/* { dg-do compile } */
/* { dg-options ""-mno-sahf -mno-mmx -mno-sse"" } */
/* { dg-additional-options ""-march=i386"" { target ia32 } } */

#pragma GCC push_options
#pragma GCC target (""sse"")
void
foo (void)
{
  __builtin_ia32_pause ();
}
#pragma GCC pop_options

void
bar (void)
{
  __builtin_ia32_pause ();
}
"
"/* PR tree-optimization/58209 */

extern void abort (void);
typedef __INTPTR_TYPE__ T;
T buf[1024];

T *
foo (T n)
{
  if (n == 0)
    return (T *) buf;
  T s = (T) foo (n - 1);
  return (T *) (s + sizeof (T));
}

T *
bar (T n)
{
  if (n == 0)
    return buf;
  return foo (n - 1) + 1;
}

int
main ()
{
  int i;
  for (i = 0; i < 27; i++)
    if (foo (i) != buf + i || bar (i) != buf + i)
      abort ();
  return 0;
}
","/* PR tree-optimization/58209 */

extern void abort (void);
typedef __INTPTR_TYPE__ T;
T buf[1024];

T *
foo (T n)
{
  if (n == 0)
    return (T *) buf;
  T s = (T) foo (n - 1);
  return (T *) (s + sizeof (T));
}

T *
bar (T n)
{
  if (n == 0)
    return buf;
  return foo (n - 1) + 1;
}

int
main ()
{
  int i;
  for (i = 0; i < 27; i++)
    if (foo (i) != buf + i || bar (i) != buf + i)
      abort ();
  return 0;
}
"
"/* { dg-do compile { target { powerpc*-*-* } } } */
/* { dg-skip-if ""do not override -mcpu"" { powerpc*-*-* } { ""-mcpu=*"" } { ""-mcpu=power9"" } } */
/* { dg-require-effective-target powerpc_p9vector_ok } */
/* { dg-skip-if """" { powerpc*-*-aix* } } */
/* { dg-options ""-mcpu=power9"" } */

/* This test should succeed on both 32- and 64-bit configurations.  */
#include <altivec.h>

int doTestBCDSignificance (_Decimal64 *p)
{
  _Decimal64 source = *p;

  return __builtin_dfp_dtstsfi_lt (5, source);
}

/* { dg-final { scan-assembler	   ""dtstsfi"" } } */
","/* { dg-do compile { target { powerpc*-*-* } } } */
/* { dg-skip-if ""do not override -mcpu"" { powerpc*-*-* } { ""-mcpu=*"" } { ""-mcpu=power9"" } } */
/* { dg-require-effective-target powerpc_p9vector_ok } */
/* { dg-skip-if """" { powerpc*-*-aix* } } */
/* { dg-options ""-mcpu=power9"" } */

/* This test should succeed on both 32- and 64-bit configurations.  */
#include <altivec.h>

int doTestBCDSignificance (_Decimal64 *p)
{
  _Decimal64 source = *p;

  return __builtin_dfp_dtstsfi_lt (5, source);
}

/* { dg-final { scan-assembler	   ""dtstsfi"" } } */
"
"/* { dg-do run } */

extern void abort (void);

int foo (int x)
{
  return (x / 2) / ((-__INT_MAX__ - 1) / -2);
}

int main()
{
  if (foo (- __INT_MAX__ - 1) != -1)
    abort ();
  return 0;
}
","/* { dg-do run } */

extern void abort (void);

int foo (int x)
{
  return (x / 2) / ((-__INT_MAX__ - 1) / -2);
}

int main()
{
  if (foo (- __INT_MAX__ - 1) != -1)
    abort ();
  return 0;
}
"
"
int a, b, c = 1;

int main ()
{
  for (; b < 1; b++)
    ;
  if (!(c * (a < 1))) 
    __builtin_abort ();
  return 0; 
}
","
int a, b, c = 1;

int main ()
{
  for (; b < 1; b++)
    ;
  if (!(c * (a < 1))) 
    __builtin_abort ();
  return 0; 
}
"
"/* { dg-do compile } */
/* { dg-options ""-mavx2 -O2"" } */
/* { dg-final { scan-assembler ""vpmovzxdq\[ \\t\]+\[^\n\]*%ymm\[0-9\]"" } } */

#include <immintrin.h>

__m128i x;
__m256i res;

void extern
avx2_test (void)
{
  res = _mm256_cvtepu32_epi64 (x);
}
","/* { dg-do compile } */
/* { dg-options ""-mavx2 -O2"" } */
/* { dg-final { scan-assembler ""vpmovzxdq\[ \\t\]+\[^\n\]*%ymm\[0-9\]"" } } */

#include <immintrin.h>

__m128i x;
__m256i res;

void extern
avx2_test (void)
{
  res = _mm256_cvtepu32_epi64 (x);
}
"
"// { dg-do compile }
// { dg-options ""-O -g -dA -gno-strict-dwarf"" }
// { dg-additional-options ""-fno-common"" { target hppa*-*-hpux* } }
// { dg-final { scan-assembler-times "" DW_AT_alignment"" 1 { xfail { powerpc-ibm-aix* } } } }

struct tt {
  int i;
};

struct tt __attribute__((__aligned__(64))) t;
","// { dg-do compile }
// { dg-options ""-O -g -dA -gno-strict-dwarf"" }
// { dg-additional-options ""-fno-common"" { target hppa*-*-hpux* } }
// { dg-final { scan-assembler-times "" DW_AT_alignment"" 1 { xfail { powerpc-ibm-aix* } } } }

struct tt {
  int i;
};

struct tt __attribute__((__aligned__(64))) t;
"
"/* { dg-options { -nostartfiles below100.o -Tbelow100.ld -O2 } } */
/* { dg-final { scan-assembler ""set1 B100,#0"" } } */

typedef struct
{
  unsigned char b0:1;
  unsigned char b1:1;
  unsigned char b2:1;
  unsigned char b3:1;
  unsigned char b4:1;
  unsigned char b5:1;
  unsigned char b6:1;
  unsigned char b7:1;
} BitField;

char acDummy[0xf0] __attribute__ ((__BELOW100__));
BitField B100 __attribute__ ((__BELOW100__)) =
{
0, 0, 1, 0, 1, 1, 0, 0};
unsigned char *p = (unsigned char *) &B100;

void
Do (void)
{
  B100.b0 = 1;
}

int
main (void)
{
  Do ();
  return (*p == 0x35) ? 0 : 1;
}
","/* { dg-options { -nostartfiles below100.o -Tbelow100.ld -O2 } } */
/* { dg-final { scan-assembler ""set1 B100,#0"" } } */

typedef struct
{
  unsigned char b0:1;
  unsigned char b1:1;
  unsigned char b2:1;
  unsigned char b3:1;
  unsigned char b4:1;
  unsigned char b5:1;
  unsigned char b6:1;
  unsigned char b7:1;
} BitField;

char acDummy[0xf0] __attribute__ ((__BELOW100__));
BitField B100 __attribute__ ((__BELOW100__)) =
{
0, 0, 1, 0, 1, 1, 0, 0};
unsigned char *p = (unsigned char *) &B100;

void
Do (void)
{
  B100.b0 = 1;
}

int
main (void)
{
  Do ();
  return (*p == 0x35) ? 0 : 1;
}
"
"/* Check that the compiler does not optimise the negation out.
   We need to check for this because there is a mismatch in semantics
   between the ACLE, which states that he negative of the minimum
   (signed) value is itself and C, where this is undefined behaviour.  */

/* { dg-do run } */
/* { dg-options ""--save-temps -O2"" } */

#include <arm_neon.h>
#include <limits.h>

extern void abort (void);

int
foo (int64_t x)
{
  if (x < (int64_t) 0)
    return vnegd_s64 (x) < (int64_t) 0;
  else
    return -1;
}

/* { dg-final { scan-assembler-times {neg\tx[0-9]+, x[0-9]+} 1 } } */

int
main (void)
{
  int ans = 1;
  int res = foo (INT64_MIN);

  if (res != ans)
    abort ();

  return 0;
}

","/* Check that the compiler does not optimise the negation out.
   We need to check for this because there is a mismatch in semantics
   between the ACLE, which states that he negative of the minimum
   (signed) value is itself and C, where this is undefined behaviour.  */

/* { dg-do run } */
/* { dg-options ""--save-temps -O2"" } */

#include <arm_neon.h>
#include <limits.h>

extern void abort (void);

int
foo (int64_t x)
{
  if (x < (int64_t) 0)
    return vnegd_s64 (x) < (int64_t) 0;
  else
    return -1;
}

/* { dg-final { scan-assembler-times {neg\tx[0-9]+, x[0-9]+} 1 } } */

int
main (void)
{
  int ans = 1;
  int res = foo (INT64_MIN);

  if (res != ans)
    abort ();

  return 0;
}

"
"/* { dg-do compile } */

int __attribute__ ((common)) common;
static int local;
extern int external_decl;
int external_defn;

int foo ()
{
  return common +  local + external_decl + external_defn;
}

void bar (int i)
{
  common = local = external_decl = external_defn = i;
}

/* { dg-final { scan-assembler ""\[\n\r\]\[\t \]*.weak .global\[^,\n\r\]*common"" } } */
/* { dg-final { scan-assembler ""\[\n\r\]\[\t \]*.global\[^,\n\r\]*local"" } } */
/* { dg-final { scan-assembler ""\[\n\r\]\[\t \]*.extern .global\[^,\n\r\]*external_decl"" } } */
/* { dg-final { scan-assembler ""\[\n\r\]\[\t \]*.visible .global\[^,\n\r\]*external_defn"" } } */
","/* { dg-do compile } */

int __attribute__ ((common)) common;
static int local;
extern int external_decl;
int external_defn;

int foo ()
{
  return common +  local + external_decl + external_defn;
}

void bar (int i)
{
  common = local = external_decl = external_defn = i;
}

/* { dg-final { scan-assembler ""\[\n\r\]\[\t \]*.weak .global\[^,\n\r\]*common"" } } */
/* { dg-final { scan-assembler ""\[\n\r\]\[\t \]*.global\[^,\n\r\]*local"" } } */
/* { dg-final { scan-assembler ""\[\n\r\]\[\t \]*.extern .global\[^,\n\r\]*external_decl"" } } */
/* { dg-final { scan-assembler ""\[\n\r\]\[\t \]*.visible .global\[^,\n\r\]*external_defn"" } } */
"
"struct X {
    struct Y {
	struct YY {
	    struct Z {
		int i;
	    } c;
	} bb;
    } b;
} a;
int __attribute__((noinline, noclone))
foo (struct Z *p)
{
  int i = p->i;
  a.b = (struct Y){};
  return p->i + i;
}
extern void abort (void);
int main()
{
  a.b.bb.c.i = 1;
  if (foo (&a.b.bb.c) != 1)
    abort ();
  return 0;
}
","struct X {
    struct Y {
	struct YY {
	    struct Z {
		int i;
	    } c;
	} bb;
    } b;
} a;
int __attribute__((noinline, noclone))
foo (struct Z *p)
{
  int i = p->i;
  a.b = (struct Y){};
  return p->i + i;
}
extern void abort (void);
int main()
{
  a.b.bb.c.i = 1;
  if (foo (&a.b.bb.c) != 1)
    abort ();
  return 0;
}
"
"/* PR target/29776 */
/* PR tree-optimization/61725 */
/* { dg-do compile } */
/* { dg-options ""-O2 -fdump-tree-vrp1"" } */
/* { dg-final { scan-tree-dump-not ""link_error"" ""vrp1""} } */

#define A(fn, arg, min, max) \
  if (__builtin_##fn (arg) < min || __builtin_##fn (arg) > max) \
    link_error ();
#define B(fn, min, max) \
  A (fn, a, min, max) A (fn##l, b, min, max) A (fn##ll, c, min, max)
#define C(fn, min, sub) \
  A (fn, a, min, ((int) sizeof (a) * __CHAR_BIT__ - sub)) \
  A (fn##l, b, min, ((int) sizeof (b) * __CHAR_BIT__ - sub)) \
  A (fn##ll, c, min, ((int) sizeof (c) * __CHAR_BIT__ - sub))

extern void link_error (void);

unsigned int d;
unsigned long e;
unsigned long long f;

void
foo (int a, long b, long long c)
{
  C (ffs, 0, 0)
  a &= 63; b &= 63; c &= 63;
  B (ffs, 0, 6)
  a++; b++; c++;
  B (ffs, 1, 7)
  a -= 2; b -= 2; c -= 2;
  C (ffs, 0, 0)
  a -= 63; b -= 63; c -= 63;
  C (ffs, 1, 0)
}
","/* PR target/29776 */
/* PR tree-optimization/61725 */
/* { dg-do compile } */
/* { dg-options ""-O2 -fdump-tree-vrp1"" } */
/* { dg-final { scan-tree-dump-not ""link_error"" ""vrp1""} } */

#define A(fn, arg, min, max) \
  if (__builtin_##fn (arg) < min || __builtin_##fn (arg) > max) \
    link_error ();
#define B(fn, min, max) \
  A (fn, a, min, max) A (fn##l, b, min, max) A (fn##ll, c, min, max)
#define C(fn, min, sub) \
  A (fn, a, min, ((int) sizeof (a) * __CHAR_BIT__ - sub)) \
  A (fn##l, b, min, ((int) sizeof (b) * __CHAR_BIT__ - sub)) \
  A (fn##ll, c, min, ((int) sizeof (c) * __CHAR_BIT__ - sub))

extern void link_error (void);

unsigned int d;
unsigned long e;
unsigned long long f;

void
foo (int a, long b, long long c)
{
  C (ffs, 0, 0)
  a &= 63; b &= 63; c &= 63;
  B (ffs, 0, 6)
  a++; b++; c++;
  B (ffs, 1, 7)
  a -= 2; b -= 2; c -= 2;
  C (ffs, 0, 0)
  a -= 63; b -= 63; c -= 63;
  C (ffs, 1, 0)
}
"
"/* { dg-do compile } */
/* { dg-options ""-O2 -fdump-tree-original"" } */

int test1(int a, int b)
{
  return (a ^ b) == 0;
}

int test2(int c, int d)
{
  return (c ^ d) != 0;
}

unsigned int test3(unsigned int e, unsigned int f)
{
  return (e ^ f) == 0;
}

unsigned int test4(unsigned int g, unsigned int h)
{
  return (g ^ h) != 0;
}

/* { dg-final { scan-tree-dump-times ""a == b"" 1 ""original"" } } */
/* { dg-final { scan-tree-dump-times ""c != d"" 1 ""original"" } } */
/* { dg-final { scan-tree-dump-times ""e == f"" 1 ""original"" } } */
/* { dg-final { scan-tree-dump-times ""g != h"" 1 ""original"" } } */
","/* { dg-do compile } */
/* { dg-options ""-O2 -fdump-tree-original"" } */

int test1(int a, int b)
{
  return (a ^ b) == 0;
}

int test2(int c, int d)
{
  return (c ^ d) != 0;
}

unsigned int test3(unsigned int e, unsigned int f)
{
  return (e ^ f) == 0;
}

unsigned int test4(unsigned int g, unsigned int h)
{
  return (g ^ h) != 0;
}

/* { dg-final { scan-tree-dump-times ""a == b"" 1 ""original"" } } */
/* { dg-final { scan-tree-dump-times ""c != d"" 1 ""original"" } } */
/* { dg-final { scan-tree-dump-times ""e == f"" 1 ""original"" } } */
/* { dg-final { scan-tree-dump-times ""g != h"" 1 ""original"" } } */
"
"/* { dg-do compile } */
/* { dg-options ""-mavx512cd -O2"" } */
/* { dg-final { scan-assembler-times ""vplzcntq\[ \\t\]+\[^\{\n\]*%zmm\[0-9\]+(?:\n|\[ \\t\]+#)""  1 } } */
/* { dg-final { scan-assembler-times ""vplzcntq\[ \\t\]+\[^\{\n\]*%zmm\[0-9\]+\{%k\[1-7\]\}(?:\n|\[ \\t\]+#)"" 1 } } */
/* { dg-final { scan-assembler-times ""vplzcntq\[ \\t\]+\[^\{\n\]*%zmm\[0-9\]+\{%k\[1-7\]\}\{z\}(?:\n|\[ \\t\]+#)"" 1 } } */

#include <immintrin.h>

volatile __m512i s;
volatile __m512i res;

void extern
avx512f_test (void)
{
  res = _mm512_lzcnt_epi64 (s);
  res = _mm512_maskz_lzcnt_epi64 (2, s);
  res = _mm512_mask_lzcnt_epi64 (res, 2, s);
}
","/* { dg-do compile } */
/* { dg-options ""-mavx512cd -O2"" } */
/* { dg-final { scan-assembler-times ""vplzcntq\[ \\t\]+\[^\{\n\]*%zmm\[0-9\]+(?:\n|\[ \\t\]+#)""  1 } } */
/* { dg-final { scan-assembler-times ""vplzcntq\[ \\t\]+\[^\{\n\]*%zmm\[0-9\]+\{%k\[1-7\]\}(?:\n|\[ \\t\]+#)"" 1 } } */
/* { dg-final { scan-assembler-times ""vplzcntq\[ \\t\]+\[^\{\n\]*%zmm\[0-9\]+\{%k\[1-7\]\}\{z\}(?:\n|\[ \\t\]+#)"" 1 } } */

#include <immintrin.h>

volatile __m512i s;
volatile __m512i res;

void extern
avx512f_test (void)
{
  res = _mm512_lzcnt_epi64 (s);
  res = _mm512_maskz_lzcnt_epi64 (2, s);
  res = _mm512_mask_lzcnt_epi64 (res, 2, s);
}
"
"/* PR tree-optimization/16951 */

void dummy_use(const char *p);

__inline void f(const char *const p) {
  const char q;
  dummy_use(p);
  f(&q);
}

void crash() {
  f(0);
}
","/* PR tree-optimization/16951 */

void dummy_use(const char *p);

__inline void f(const char *const p) {
  const char q;
  dummy_use(p);
  f(&q);
}

void crash() {
  f(0);
}
"
"/* PR/18160 */

/* { dg-do compile { target i?86-*-* x86_64-*-* } } */

/* This should yield an error even without -pedantic.  */
/* { dg-options ""-ansi"" } */

void g(int *);

void f(void) 
{ 
  register int x __asm (""eax"");
  g(&x);	/* { dg-error ""address of register variable"" } */
} 
","/* PR/18160 */

/* { dg-do compile { target i?86-*-* x86_64-*-* } } */

/* This should yield an error even without -pedantic.  */
/* { dg-options ""-ansi"" } */

void g(int *);

void f(void) 
{ 
  register int x __asm (""eax"");
  g(&x);	/* { dg-error ""address of register variable"" } */
} 
"
"/* { dg-do run } */
/* { dg-require-effective-target avx512er } */
/* { dg-options ""-O2 -mavx512er"" } */

#include ""avx512er-check.h""
#include ""avx512f-mask-type.h""
#include ""avx512f-helper.h""
#include <math.h>

void static
avx512er_test (void)
{
  union128d src1, src2, res;
  double res_ref[2];
  int i;
  
  for (i = 0; i < 2; i++)
    {
      src1.a[i] = 179.345 - 6.5645 * i;
      src2.a[i] = 45 - 6.5645 * i;
      res_ref[i] = src1.a[i];
    }

  res_ref[0] = 1.0 / sqrt (src2.a[0]);

  res.x = _mm_rsqrt28_round_sd (src1.x, src2.x, _MM_FROUND_NO_EXC);

  if (checkVd (res.a, res_ref, 2))
    abort ();
}
","/* { dg-do run } */
/* { dg-require-effective-target avx512er } */
/* { dg-options ""-O2 -mavx512er"" } */

#include ""avx512er-check.h""
#include ""avx512f-mask-type.h""
#include ""avx512f-helper.h""
#include <math.h>

void static
avx512er_test (void)
{
  union128d src1, src2, res;
  double res_ref[2];
  int i;
  
  for (i = 0; i < 2; i++)
    {
      src1.a[i] = 179.345 - 6.5645 * i;
      src2.a[i] = 45 - 6.5645 * i;
      res_ref[i] = src1.a[i];
    }

  res_ref[0] = 1.0 / sqrt (src2.a[0]);

  res.x = _mm_rsqrt28_round_sd (src1.x, src2.x, _MM_FROUND_NO_EXC);

  if (checkVd (res.a, res_ref, 2))
    abort ();
}
"
"/* { dg-do compile } */
/* { dg-options ""-mavx -O2"" } */
/* { dg-final { scan-assembler ""xrstor\[ \\t\]"" } } */

#include <x86intrin.h>

void extern
xsave_test (void)
{
  char xsave_region [512] __attribute__((aligned(64)));
  _xrstor (xsave_region, ((long long) 0xA0000000F));
}
","/* { dg-do compile } */
/* { dg-options ""-mavx -O2"" } */
/* { dg-final { scan-assembler ""xrstor\[ \\t\]"" } } */

#include <x86intrin.h>

void extern
xsave_test (void)
{
  char xsave_region [512] __attribute__((aligned(64)));
  _xrstor (xsave_region, ((long long) 0xA0000000F));
}
"
"/* Test AAPCS layout (VFP variant) */

/* { dg-do run { target arm_eabi } } */
/* { dg-require-effective-target arm_hard_vfp_ok } */
/* { dg-require-effective-target arm32 } */
/* { dg-options ""-O -mfpu=vfp -mfloat-abi=hard"" } */

#ifndef IN_FRAMEWORK
#define VFP
#define TESTFILE ""vfp1.c""
#include ""abitest.h""

#else
  ARG(int, 4, R0)
  ARG(double, 4.0, D0)
  LAST_ARG(int, 3, R1)
#endif
","/* Test AAPCS layout (VFP variant) */

/* { dg-do run { target arm_eabi } } */
/* { dg-require-effective-target arm_hard_vfp_ok } */
/* { dg-require-effective-target arm32 } */
/* { dg-options ""-O -mfpu=vfp -mfloat-abi=hard"" } */

#ifndef IN_FRAMEWORK
#define VFP
#define TESTFILE ""vfp1.c""
#include ""abitest.h""

#else
  ARG(int, 4, R0)
  ARG(double, 4.0, D0)
  LAST_ARG(int, 3, R1)
#endif
"
"/* This should return 1 without setting up a stack frame or
   jumping.  */
/* { dg-do compile } */
/* { dg-require-effective-target ia32 } */
/* { dg-options ""-O2 -fomit-frame-pointer"" } */
int h (char *p)
{
  if (*p)
    __builtin_unreachable ();
  return p ? 1 : 0;
}
/* { dg-final { scan-assembler-not ""%e\[bs\]p"" } } */
/* { dg-final { scan-assembler-not ""\[\\t \]+j"" } } */
","/* This should return 1 without setting up a stack frame or
   jumping.  */
/* { dg-do compile } */
/* { dg-require-effective-target ia32 } */
/* { dg-options ""-O2 -fomit-frame-pointer"" } */
int h (char *p)
{
  if (*p)
    __builtin_unreachable ();
  return p ? 1 : 0;
}
/* { dg-final { scan-assembler-not ""%e\[bs\]p"" } } */
/* { dg-final { scan-assembler-not ""\[\\t \]+j"" } } */
"
"/* { dg-do compile } */
/* { dg-options ""-O2 -fdump-tree-pre -fno-ipa-sra"" } */

typedef struct {
    unsigned int key;
} S;
typedef struct s1  {
    unsigned int key;
    unsigned int bits;
    struct s1 *left, *right;
}S1;
extern S a[1024];
static inline int bar( S* p, S1* n )
{
  S1 *curr;
  S1 *next;

  if ( n->left == n )
    return (int)(p->key == n->key);

  curr = n;
  next = n->left;

  while (curr->bits > next->bits ) {
      curr = next;
      if (p->key & (1 << curr->bits))
	next = curr->right;
      else
	next = curr->left;
  }

  return (int)(p->key == next->key);

}

int foo (S1 *root, int N)
{
  volatile int r;
  int i,j;
  for (i=0; i<N; i++)
    for (j=0;j<1024; j++)
      r = bar(&a[j], root);
  return 0;
} 

/* { dg-final { scan-tree-dump-times ""key"" 3 ""pre"" } } */
","/* { dg-do compile } */
/* { dg-options ""-O2 -fdump-tree-pre -fno-ipa-sra"" } */

typedef struct {
    unsigned int key;
} S;
typedef struct s1  {
    unsigned int key;
    unsigned int bits;
    struct s1 *left, *right;
}S1;
extern S a[1024];
static inline int bar( S* p, S1* n )
{
  S1 *curr;
  S1 *next;

  if ( n->left == n )
    return (int)(p->key == n->key);

  curr = n;
  next = n->left;

  while (curr->bits > next->bits ) {
      curr = next;
      if (p->key & (1 << curr->bits))
	next = curr->right;
      else
	next = curr->left;
  }

  return (int)(p->key == next->key);

}

int foo (S1 *root, int N)
{
  volatile int r;
  int i,j;
  for (i=0; i<N; i++)
    for (j=0;j<1024; j++)
      r = bar(&a[j], root);
  return 0;
} 

/* { dg-final { scan-tree-dump-times ""key"" 3 ""pre"" } } */
"
"__complex__
double f ()
{
  int a[40];
  __complex__ double c;

  a[9] = 0;
  c = a[9];
  return c;
}

main ()
{
  __complex__ double c;

  if (c = f ())
    abort ();
  exit (0);
}
","__complex__
double f ()
{
  int a[40];
  __complex__ double c;

  a[9] = 0;
  c = a[9];
  return c;
}

main ()
{
  __complex__ double c;

  if (c = f ())
    abort ();
  exit (0);
}
"
"/* { dg-do compile } */
/* { dg-options ""-mrtm -dp"" } */
/* { dg-final { scan-assembler ""\txtest"" } } */

#include <immintrin.h>

int
rtm_xtest (void)
{
  return _xtest ();
}
","/* { dg-do compile } */
/* { dg-options ""-mrtm -dp"" } */
/* { dg-final { scan-assembler ""\txtest"" } } */

#include <immintrin.h>

int
rtm_xtest (void)
{
  return _xtest ();
}
"
"/* PR target/85177 */
/* { dg-do run { target { avx512f && int128 } } } */
/* { dg-options ""-O -fno-tree-ccp -fno-tree-sra -mavx512f -mno-avx512bw"" } */

#include ""avx512f-check.h""

typedef short U __attribute__ ((vector_size (64)));
typedef __int128 V __attribute__ ((vector_size (64)));

static inline __attribute__((always_inline)) U
foo (int i, U u)
{
  u[i & 1] = 1;
  return u;
}

__attribute__((noipa)) int
bar ()
{
  V x = (V) foo (0, (U) { });
  for (unsigned i = 0; i < 4; i++)
    if (x[i] != (i == 0)) __builtin_abort ();
  return 0;
}

static void
avx512f_test (void)
{
  bar ();
}
","/* PR target/85177 */
/* { dg-do run { target { avx512f && int128 } } } */
/* { dg-options ""-O -fno-tree-ccp -fno-tree-sra -mavx512f -mno-avx512bw"" } */

#include ""avx512f-check.h""

typedef short U __attribute__ ((vector_size (64)));
typedef __int128 V __attribute__ ((vector_size (64)));

static inline __attribute__((always_inline)) U
foo (int i, U u)
{
  u[i & 1] = 1;
  return u;
}

__attribute__((noipa)) int
bar ()
{
  V x = (V) foo (0, (U) { });
  for (unsigned i = 0; i < 4; i++)
    if (x[i] != (i == 0)) __builtin_abort ();
  return 0;
}

static void
avx512f_test (void)
{
  bar ();
}
"
"/* { dg-do run } */
/* { dg-require-effective-target avx } */
/* { dg-options ""-O2 -mavx"" } */

#define CHECK_H ""avx-check.h""
#define TEST avx_test

#include ""sse2-pshufhw-1.c""
","/* { dg-do run } */
/* { dg-require-effective-target avx } */
/* { dg-options ""-O2 -mavx"" } */

#define CHECK_H ""avx-check.h""
#define TEST avx_test

#include ""sse2-pshufhw-1.c""
"
"struct foo
{
  unsigned half:16;
  unsigned long whole:32 __attribute__ ((packed));
};

f (struct foo *q)
{
  if (q->half != 0x1234)
    abort ();
  if (q->whole != 0x56789abcL)
    abort ();
}

main ()
{
  struct foo bar;

  bar.half = 0x1234;
  bar.whole = 0x56789abcL;
  f (&bar);
  exit (0);
}
","struct foo
{
  unsigned half:16;
  unsigned long whole:32 __attribute__ ((packed));
};

f (struct foo *q)
{
  if (q->half != 0x1234)
    abort ();
  if (q->whole != 0x56789abcL)
    abort ();
}

main ()
{
  struct foo bar;

  bar.half = 0x1234;
  bar.whole = 0x56789abcL;
  f (&bar);
  exit (0);
}
"
"/* Copyright (C) 2000 Free Software Foundation */
/* by Alexandre Oliva  <aoliva@redhat.com> */

enum foo { FOO, BAR };

/* Even though the underlying type of an enum is unspecified, the type
   of enumeration constants is explicitly defined as int (6.4.4.3/2 in
   the C99 Standard).  Therefore, `i' must not be promoted to
   `unsigned' in the comparison below; we must exit the loop when it
   becomes negative. */

int
main ()
{
  int i;
  for (i = BAR; i >= FOO; --i)
    if (i == -1)
      abort ();

  exit (0);
}

","/* Copyright (C) 2000 Free Software Foundation */
/* by Alexandre Oliva  <aoliva@redhat.com> */

enum foo { FOO, BAR };

/* Even though the underlying type of an enum is unspecified, the type
   of enumeration constants is explicitly defined as int (6.4.4.3/2 in
   the C99 Standard).  Therefore, `i' must not be promoted to
   `unsigned' in the comparison below; we must exit the loop when it
   becomes negative. */

int
main ()
{
  int i;
  for (i = BAR; i >= FOO; --i)
    if (i == -1)
      abort ();

  exit (0);
}

"
"/* Test __STDC_VERSION__ for C94.  */
/* { dg-do compile } */
/* { dg-options ""-std=iso9899:199409 -pedantic-errors"" } */

#if __STDC_VERSION__ == 199409L
int i;
#else
#error ""Bad __STDC_VERSION__.""
#endif
","/* Test __STDC_VERSION__ for C94.  */
/* { dg-do compile } */
/* { dg-options ""-std=iso9899:199409 -pedantic-errors"" } */

#if __STDC_VERSION__ == 199409L
int i;
#else
#error ""Bad __STDC_VERSION__.""
#endif
"
"/* { dg-do run } */
/* { dg-require-effective-target avx } */
/* { dg-options ""-O2 -mavx"" } */

#define CHECK_H ""avx-check.h""
#define TEST avx_test

#include ""sse2-movsd-2.c""
","/* { dg-do run } */
/* { dg-require-effective-target avx } */
/* { dg-options ""-O2 -mavx"" } */

#define CHECK_H ""avx-check.h""
#define TEST avx_test

#include ""sse2-movsd-2.c""
"
"/* { dg-options ""-O2"" } */
/* { dg-do compile } */
/* { dg-require-effective-target ilp32 } */

/* The problem was we were not striping the long cast here.
   Note this really should be invalid code but not for the
   current release (4.0) as we have people using it.  */

void blockCopy_MMX2(int*);
void postProcess_MMX2()
{
  int c, x,y, width;
  asm( """" :: ""m"" ((long)x));
  blockCopy_MMX2(&c);
}
","/* { dg-options ""-O2"" } */
/* { dg-do compile } */
/* { dg-require-effective-target ilp32 } */

/* The problem was we were not striping the long cast here.
   Note this really should be invalid code but not for the
   current release (4.0) as we have people using it.  */

void blockCopy_MMX2(int*);
void postProcess_MMX2()
{
  int c, x,y, width;
  asm( """" :: ""m"" ((long)x));
  blockCopy_MMX2(&c);
}
"
"/* { dg-do run } */
/* { dg-options ""-fgimple -O2 -ftree-slp-vectorize"" } */
/* { dg-require-effective-target ptr32plus } */

struct  A
{
  void * a;
  void * b;
};

struct __attribute__((aligned(16))) B
{
  void * pad;
  void * misaligned;
  void * pad2;

  struct A a;
};

__attribute__((noclone, noinline))
void __GIMPLE (startwith(""slp""))
NullB (void * misalignedPtr)
{
  struct B * b;

  bb_2:
#if __SIZEOF_LONG__ == 8
  b_2 = misalignedPtr_1(D) + 18446744073709551608ul;
#else
  b_2 = misalignedPtr_1(D) + 4294967292ul;
#endif
  __MEM <struct B> (b_2).a.a = _Literal (void *) 0;
  __MEM <struct B> (b_2).a.b = _Literal (void *) 0;
  return;

}

int main()
{
  struct B b;
  NullB (&b.misaligned);
  return 0;
}
","/* { dg-do run } */
/* { dg-options ""-fgimple -O2 -ftree-slp-vectorize"" } */
/* { dg-require-effective-target ptr32plus } */

struct  A
{
  void * a;
  void * b;
};

struct __attribute__((aligned(16))) B
{
  void * pad;
  void * misaligned;
  void * pad2;

  struct A a;
};

__attribute__((noclone, noinline))
void __GIMPLE (startwith(""slp""))
NullB (void * misalignedPtr)
{
  struct B * b;

  bb_2:
#if __SIZEOF_LONG__ == 8
  b_2 = misalignedPtr_1(D) + 18446744073709551608ul;
#else
  b_2 = misalignedPtr_1(D) + 4294967292ul;
#endif
  __MEM <struct B> (b_2).a.a = _Literal (void *) 0;
  __MEM <struct B> (b_2).a.b = _Literal (void *) 0;
  return;

}

int main()
{
  struct B b;
  NullB (&b.misaligned);
  return 0;
}
"
"/* { dg-options ""-Wuninitialized"" } */

/* Verify disabling a warning, where the _Pragma is in regular code,
   but the affected code is within a macro.  */

/* TODO: XFAIL: both C and C++ erroneously fail to suppress the warning
   The warning is reported at the macro definition location, rather than
   the macro expansion location.  */

#define WARNABLE_CODE *++yyvsp = yylval; /* { dg-bogus ""used uninitialized"" """" { xfail *-*-* } } */

void test (char yylval)
{
  char *yyvsp; /* { dg-bogus ""declared here"" """" { xfail *-*-* } } */
  _Pragma (""GCC diagnostic push"")
  _Pragma (""GCC diagnostic ignored \""-Wuninitialized\"""")
  _Pragma (""GCC diagnostic ignored \""-Wmaybe-uninitialized\"""")
  WARNABLE_CODE
  _Pragma (""GCC diagnostic pop"")
}
","/* { dg-options ""-Wuninitialized"" } */

/* Verify disabling a warning, where the _Pragma is in regular code,
   but the affected code is within a macro.  */

/* TODO: XFAIL: both C and C++ erroneously fail to suppress the warning
   The warning is reported at the macro definition location, rather than
   the macro expansion location.  */

#define WARNABLE_CODE *++yyvsp = yylval; /* { dg-bogus ""used uninitialized"" """" { xfail *-*-* } } */

void test (char yylval)
{
  char *yyvsp; /* { dg-bogus ""declared here"" """" { xfail *-*-* } } */
  _Pragma (""GCC diagnostic push"")
  _Pragma (""GCC diagnostic ignored \""-Wuninitialized\"""")
  _Pragma (""GCC diagnostic ignored \""-Wmaybe-uninitialized\"""")
  WARNABLE_CODE
  _Pragma (""GCC diagnostic pop"")
}
"
"/* { dg-do compile } */
/* { dg-options ""-O2 -mtune=generic"" } */

int
foo (unsigned char x, unsigned char y)
{
   return (x % y) != 0;
}

/* { dg-final { scan-assembler-not ""test\[b\]?\[^\\n\]*%\[a-d\]l"" } } */
","/* { dg-do compile } */
/* { dg-options ""-O2 -mtune=generic"" } */

int
foo (unsigned char x, unsigned char y)
{
   return (x % y) != 0;
}

/* { dg-final { scan-assembler-not ""test\[b\]?\[^\\n\]*%\[a-d\]l"" } } */
"
"/* { dg-do run } */
/* { dg-options ""-O2"" } */
/* { dg-additional-options ""-minline-all-stringops"" { target { i?86-*-* x86_64-*-* } } } */

extern void abort (void);

#define MAX_OFFSET (sizeof (long long))
#define MAX_COPY (8 * sizeof (long long))
#define MAX_EXTRA (sizeof (long long))

#define MAX_LENGTH (MAX_OFFSET + MAX_COPY + MAX_EXTRA)

static union {
  char buf[MAX_LENGTH];
  long long align_int;
  long double align_fp;
} u;

char A[MAX_LENGTH];

int
main ()
{
  int off, len, i;
  char *p, *q;

  for (i = 0; i < MAX_LENGTH; i++)
    A[i] = 'A';

  for (off = 0; off < MAX_OFFSET; off++)
    for (len = 1; len < MAX_COPY; len++)
      {
	for (i = 0; i < MAX_LENGTH; i++)
	  u.buf[i] = 'a';

	p = __builtin_memcpy (u.buf + off, A, len);
	if (p != u.buf + off)
	  abort ();

	q = u.buf;
	for (i = 0; i < off; i++, q++)
	  if (*q != 'a')
	    abort ();

	for (i = 0; i < len; i++, q++)
	  if (*q != 'A')
	    abort ();

	for (i = 0; i < MAX_EXTRA; i++, q++)
	  if (*q != 'a')
	    abort ();
      }

  return 0;
}
","/* { dg-do run } */
/* { dg-options ""-O2"" } */
/* { dg-additional-options ""-minline-all-stringops"" { target { i?86-*-* x86_64-*-* } } } */

extern void abort (void);

#define MAX_OFFSET (sizeof (long long))
#define MAX_COPY (8 * sizeof (long long))
#define MAX_EXTRA (sizeof (long long))

#define MAX_LENGTH (MAX_OFFSET + MAX_COPY + MAX_EXTRA)

static union {
  char buf[MAX_LENGTH];
  long long align_int;
  long double align_fp;
} u;

char A[MAX_LENGTH];

int
main ()
{
  int off, len, i;
  char *p, *q;

  for (i = 0; i < MAX_LENGTH; i++)
    A[i] = 'A';

  for (off = 0; off < MAX_OFFSET; off++)
    for (len = 1; len < MAX_COPY; len++)
      {
	for (i = 0; i < MAX_LENGTH; i++)
	  u.buf[i] = 'a';

	p = __builtin_memcpy (u.buf + off, A, len);
	if (p != u.buf + off)
	  abort ();

	q = u.buf;
	for (i = 0; i < off; i++, q++)
	  if (*q != 'a')
	    abort ();

	for (i = 0; i < len; i++, q++)
	  if (*q != 'A')
	    abort ();

	for (i = 0; i < MAX_EXTRA; i++, q++)
	  if (*q != 'a')
	    abort ();
      }

  return 0;
}
"
"/* Sparc w/128-bit long double bombed on this because even though
   the trunctfdf libcall passed the long double by reference, the
   libcall was still marked as LCT_CONST instead of LCT_PURE.  */

double *copy(long double *first, long double *last, double *result)
{
	int n;
	for (n = last - first; n > 0; --n) {
		*result = *first;
		++first;
		++result;
	}
	return result;
}
","/* Sparc w/128-bit long double bombed on this because even though
   the trunctfdf libcall passed the long double by reference, the
   libcall was still marked as LCT_CONST instead of LCT_PURE.  */

double *copy(long double *first, long double *last, double *result)
{
	int n;
	for (n = last - first; n > 0; --n) {
		*result = *first;
		++first;
		++result;
	}
	return result;
}
"
"/* Test specification of custom instructions via pragma in the presence
   of LTO.  This test case formerly failed due to PR60179.  */

/* { dg-do link } */
/* { dg-require-effective-target lto } */
/* { dg-options ""-O1 -flto -flto-partition=one -save-temps"" } */

/* -O1 in the options is significant.  Without it FP operations may not be
   optimized to custom instructions.  */

#include <stdio.h> 
#include <math.h>

#pragma GCC target (""custom-fabss=224"")

float
custom_fp (float operand_a)
{
  return fabsf (operand_a);
}

int
main (int argc, char *argv[])
{
  return custom_fp ((float)argc) > 1.0;
}

/* { dg-final { scan-lto-assembler ""custom\\t224, "" } } */
","/* Test specification of custom instructions via pragma in the presence
   of LTO.  This test case formerly failed due to PR60179.  */

/* { dg-do link } */
/* { dg-require-effective-target lto } */
/* { dg-options ""-O1 -flto -flto-partition=one -save-temps"" } */

/* -O1 in the options is significant.  Without it FP operations may not be
   optimized to custom instructions.  */

#include <stdio.h> 
#include <math.h>

#pragma GCC target (""custom-fabss=224"")

float
custom_fp (float operand_a)
{
  return fabsf (operand_a);
}

int
main (int argc, char *argv[])
{
  return custom_fp ((float)argc) > 1.0;
}

/* { dg-final { scan-lto-assembler ""custom\\t224, "" } } */
"
"/* { dg-require-effective-target vect_int } */

#include <stdarg.h>
#include ""tree-vect.h""

#define N 40
int a[200*N+N];

__attribute__ ((noinline)) void
foo (){
  int i,j;
  int sum,s=0;

  for (i = 0; i < 200*N; i++) {
    sum = 0;
    for (j = 0; j < N; j++) {
      sum += (i + j);
      i++;
    }
    a[i] = sum;
  }
}

int main (void)
{
  int i,j,k=0;
  int sum,s=0;

  check_vect ();

  foo ();

    /* check results:  */
  for (i=0; i<200*N; i++)
    {
      sum = 0;
      for (j = 0; j < N; j++){
        sum += (j + i);
	i++;
      }
      if (a[i] != sum)
	abort ();
    }

  return 0;
}

/* { dg-final { scan-tree-dump-times ""OUTER LOOP VECTORIZED."" 1 ""vect"" { xfail *-*-* } } } */
","/* { dg-require-effective-target vect_int } */

#include <stdarg.h>
#include ""tree-vect.h""

#define N 40
int a[200*N+N];

__attribute__ ((noinline)) void
foo (){
  int i,j;
  int sum,s=0;

  for (i = 0; i < 200*N; i++) {
    sum = 0;
    for (j = 0; j < N; j++) {
      sum += (i + j);
      i++;
    }
    a[i] = sum;
  }
}

int main (void)
{
  int i,j,k=0;
  int sum,s=0;

  check_vect ();

  foo ();

    /* check results:  */
  for (i=0; i<200*N; i++)
    {
      sum = 0;
      for (j = 0; j < N; j++){
        sum += (j + i);
	i++;
      }
      if (a[i] != sum)
	abort ();
    }

  return 0;
}

/* { dg-final { scan-tree-dump-times ""OUTER LOOP VECTORIZED."" 1 ""vect"" { xfail *-*-* } } } */
"
"/* PR sanitizer/64121 */
/* { dg-do compile } */
/* { dg-options ""-fsanitize=undefined -Wno-pointer-arith"" } */

extern int tab[16];

void
execute (int *ip, int x)
{
  int *xp = tab;
base:
  if (x)
    return;
  *xp++ = *ip;
  goto *(&&base + *ip);
}
","/* PR sanitizer/64121 */
/* { dg-do compile } */
/* { dg-options ""-fsanitize=undefined -Wno-pointer-arith"" } */

extern int tab[16];

void
execute (int *ip, int x)
{
  int *xp = tab;
base:
  if (x)
    return;
  *xp++ = *ip;
  goto *(&&base + *ip);
}
"
"/* PR rtl-optimization/57300 */
/* { dg-do run } */
/* { dg-options ""-O3"" } */
/* { dg-additional-options ""-msse2"" { target sse2_runtime } } */

extern void abort (void);
int a, b, d[10];
long long c;

int
main ()
{
  int e;
  for (e = 0; e < 10; e++)
    d[e] = 1;
  if (d[0])
    c = a = (b == 0 || 1 % b);
  if (a != 1)
    abort ();
  return 0;
}
","/* PR rtl-optimization/57300 */
/* { dg-do run } */
/* { dg-options ""-O3"" } */
/* { dg-additional-options ""-msse2"" { target sse2_runtime } } */

extern void abort (void);
int a, b, d[10];
long long c;

int
main ()
{
  int e;
  for (e = 0; e < 10; e++)
    d[e] = 1;
  if (d[0])
    c = a = (b == 0 || 1 % b);
  if (a != 1)
    abort ();
  return 0;
}
"
"/* { dg-do compile } */

int x[1024], y[1024], z[1024], w[1024];
void foo (void)
{
  int i;
  for (i = 1; i < 1024; ++i)
    {
      int a = x[i];
      int b = y[i];
      int c = x[i-1];
      int d = y[i-1];
      if (w[i])
	z[i] = (a + b) + (c + d);
    }
}
","/* { dg-do compile } */

int x[1024], y[1024], z[1024], w[1024];
void foo (void)
{
  int i;
  for (i = 1; i < 1024; ++i)
    {
      int a = x[i];
      int b = y[i];
      int c = x[i-1];
      int d = y[i-1];
      if (w[i])
	z[i] = (a + b) + (c + d);
    }
}
"
"#include ""lib/chk.c""
","#include ""lib/chk.c""
"
"/* Alpha -msmall-data didn't transform (mem (symbol_ref)) to
   (mem (lo_sum pic (symbol_ref))) within an asm at the right time.  */
/* { dg-do compile { target fpic } } */
/* { dg-options ""-O2 -fpic"" } */

void foo()
{
  static int test;
  int dummy;
  asm volatile ("""" : ""=m""(test), ""=r""(dummy) : ""m""(test));
}
","/* Alpha -msmall-data didn't transform (mem (symbol_ref)) to
   (mem (lo_sum pic (symbol_ref))) within an asm at the right time.  */
/* { dg-do compile { target fpic } } */
/* { dg-options ""-O2 -fpic"" } */

void foo()
{
  static int test;
  int dummy;
  asm volatile ("""" : ""=m""(test), ""=r""(dummy) : ""m""(test));
}
"
"/* Test for weak aliases with multiple declarations.  Sun assembler
   rejects multiple weak alias definitions in the output.  */
/* { dg-do assemble } */
/* { dg-require-weak """" } */
/* { dg-require-alias """" } */
/* { dg-options """" } */

#pragma weak foo = _foo

extern int foo;
extern int foo;

int _foo = 4;
","/* Test for weak aliases with multiple declarations.  Sun assembler
   rejects multiple weak alias definitions in the output.  */
/* { dg-do assemble } */
/* { dg-require-weak """" } */
/* { dg-require-alias """" } */
/* { dg-options """" } */

#pragma weak foo = _foo

extern int foo;
extern int foo;

int _foo = 4;
"
"/* { dg-do compile } */
/* { dg-options ""-O -fdump-tree-optimized -Wno-psabi"" } */

typedef int v4si __attribute__((vector_size(16)));

int f(v4si t)
{
  union {
      v4si t1;
      int t2[4];
  } u;
  u.t1 = t;
  return u.t2[1];
}

/* { dg-final { scan-tree-dump-not ""u;"" ""optimized"" } } */
/* { dg-final { scan-tree-dump-times ""BIT_FIELD_REF"" 1 ""optimized"" } } */
","/* { dg-do compile } */
/* { dg-options ""-O -fdump-tree-optimized -Wno-psabi"" } */

typedef int v4si __attribute__((vector_size(16)));

int f(v4si t)
{
  union {
      v4si t1;
      int t2[4];
  } u;
  u.t1 = t;
  return u.t2[1];
}

/* { dg-final { scan-tree-dump-not ""u;"" ""optimized"" } } */
/* { dg-final { scan-tree-dump-times ""BIT_FIELD_REF"" 1 ""optimized"" } } */
"
"/* { dg-do compile } */
/* { dg-require-effective-target naked_functions } */
/* { dg-options ""-O2 -fdump-tree-optimized"" } */

static unsigned long __attribute__((naked))
foo (unsigned long base)
{
  asm volatile (""dummy"");
}
unsigned long
bar (void)
{
  static int start, set;

  if (!set)
    {
      set = 1;
      start = foo (0);
    }

  return foo (start);
}

/* { dg-final { scan-tree-dump ""foo \\\(long unsigned int base\\\)"" ""optimized"" } } */
","/* { dg-do compile } */
/* { dg-require-effective-target naked_functions } */
/* { dg-options ""-O2 -fdump-tree-optimized"" } */

static unsigned long __attribute__((naked))
foo (unsigned long base)
{
  asm volatile (""dummy"");
}
unsigned long
bar (void)
{
  static int start, set;

  if (!set)
    {
      set = 1;
      start = foo (0);
    }

  return foo (start);
}

/* { dg-final { scan-tree-dump ""foo \\\(long unsigned int base\\\)"" ""optimized"" } } */
"
"/* { dg-do run } */

struct S { int *p; int *q; };

int **__attribute__((noinline,noclone,const)) foo (struct S *s)
{
  return &s->q;
}

int main()
{
  struct S s;
  int i = 1, j = 2;
  int **x;
  s.p = &i;
  s.q = &j;
  x = foo (&s);
  **x = 7;
  if (j != 7)
    __builtin_abort ();
  return 0;
}
","/* { dg-do run } */

struct S { int *p; int *q; };

int **__attribute__((noinline,noclone,const)) foo (struct S *s)
{
  return &s->q;
}

int main()
{
  struct S s;
  int i = 1, j = 2;
  int **x;
  s.p = &i;
  s.q = &j;
  x = foo (&s);
  **x = 7;
  if (j != 7)
    __builtin_abort ();
  return 0;
}
"
"/* { dg-do run } */
/* { dg-require-effective-target int32plus } */

int main()
{
  int a = -1;
  static int b = -2147483647 - 1;
  static int c = 0;
  int t = a - (b - c);
  if (t != 2147483647)
    __builtin_abort();
  return 0;
}
","/* { dg-do run } */
/* { dg-require-effective-target int32plus } */

int main()
{
  int a = -1;
  static int b = -2147483647 - 1;
  static int c = 0;
  int t = a - (b - c);
  if (t != 2147483647)
    __builtin_abort();
  return 0;
}
"
"foo (a, b)
{
  a = b + b;
  if (a)
    return a;
  return b;
}
","foo (a, b)
{
  a = b + b;
  if (a)
    return a;
  return b;
}
"
"/* PR inline-asm/56405 */

void
foo (void)
{
  asm volatile ("""" : ""+m"" (*(volatile unsigned short *) 0x1001UL));
}
","/* PR inline-asm/56405 */

void
foo (void)
{
  asm volatile ("""" : ""+m"" (*(volatile unsigned short *) 0x1001UL));
}
"
"/* PR rtl-optimization/23561 */

struct A
{
  char a1[1];
  char a2[5];
  char a3[1];
  char a4[2048 - 7];
} a;

typedef __SIZE_TYPE__ size_t;
extern void *memset (void *, int, size_t);
extern void *memcpy (void *, const void *, size_t);
extern int memcmp (const void *, const void *, size_t);
extern void abort (void);

void
bar (struct A *x)
{
  size_t i;
  if (memcmp (x, ""\1HELLO\1"", sizeof ""\1HELLO\1""))
    abort ();
  for (i = 0; i < sizeof (x->a4); i++)
    if (x->a4[i])
      abort ();
}

int
foo (void)
{
  memset (&a, 0, sizeof (a));
  a.a1[0] = 1;
  memcpy (a.a2, ""HELLO"", sizeof ""HELLO"");
  a.a3[0] = 1;
  bar (&a);
  return 0;
}

int
main (void)
{
  foo ();
  return 0;
}
","/* PR rtl-optimization/23561 */

struct A
{
  char a1[1];
  char a2[5];
  char a3[1];
  char a4[2048 - 7];
} a;

typedef __SIZE_TYPE__ size_t;
extern void *memset (void *, int, size_t);
extern void *memcpy (void *, const void *, size_t);
extern int memcmp (const void *, const void *, size_t);
extern void abort (void);

void
bar (struct A *x)
{
  size_t i;
  if (memcmp (x, ""\1HELLO\1"", sizeof ""\1HELLO\1""))
    abort ();
  for (i = 0; i < sizeof (x->a4); i++)
    if (x->a4[i])
      abort ();
}

int
foo (void)
{
  memset (&a, 0, sizeof (a));
  a.a1[0] = 1;
  memcpy (a.a2, ""HELLO"", sizeof ""HELLO"");
  a.a3[0] = 1;
  bar (&a);
  return 0;
}

int
main (void)
{
  foo ();
  return 0;
}
"
"static double one = 1.0;

f()
{
  int colinear;
  colinear = (one == 0.0);
  if (colinear)
    abort ();
  return colinear;
}
main()
{
  if (f()) abort();
  exit (0);
}
","static double one = 1.0;

f()
{
  int colinear;
  colinear = (one == 0.0);
  if (colinear)
    abort ();
  return colinear;
}
main()
{
  if (f()) abort();
  exit (0);
}
"
"struct assembly_operand
{
  int type, value, symtype, symflags, marker;
};

struct assembly_operand to_input, from_input;

void __attribute__ ((__noinline__, __noclone__))
assemblez_1 (int internal_number, struct assembly_operand o1)
{
  if (o1.type != from_input.type)
    __builtin_abort ();
}

void __attribute__ ((__noinline__, __noclone__))
t0 (struct assembly_operand to, struct assembly_operand from)
{
  if (to.value == 0)
    assemblez_1 (32, from);
  else
    __builtin_abort ();
}

int
main (void)
{
  to_input.value = 0;
  to_input.type = 1;
  to_input.symtype = 2;
  to_input.symflags = 3;
  to_input.marker = 4;

  from_input.value = 5;
  from_input.type = 6;
  from_input.symtype = 7;
  from_input.symflags = 8;
  from_input.marker = 9;

  t0 (to_input, from_input);

  return 0;
}
","struct assembly_operand
{
  int type, value, symtype, symflags, marker;
};

struct assembly_operand to_input, from_input;

void __attribute__ ((__noinline__, __noclone__))
assemblez_1 (int internal_number, struct assembly_operand o1)
{
  if (o1.type != from_input.type)
    __builtin_abort ();
}

void __attribute__ ((__noinline__, __noclone__))
t0 (struct assembly_operand to, struct assembly_operand from)
{
  if (to.value == 0)
    assemblez_1 (32, from);
  else
    __builtin_abort ();
}

int
main (void)
{
  to_input.value = 0;
  to_input.type = 1;
  to_input.symtype = 2;
  to_input.symflags = 3;
  to_input.marker = 4;

  from_input.value = 5;
  from_input.type = 6;
  from_input.symtype = 7;
  from_input.symflags = 8;
  from_input.marker = 9;

  t0 (to_input, from_input);

  return 0;
}
"
"/* { dg-do compile } */

struct S 
{
  volatile int f;
} a;

unsigned int b;

static int *c[1][2] = {{0, (int *)&a.f}};
static unsigned int d;

int 
main ()
{
  for (; d < 1; d++)
    for (; b < 1; b++)
      *c[b][d + 1] = 0;

  return 0;
}
","/* { dg-do compile } */

struct S 
{
  volatile int f;
} a;

unsigned int b;

static int *c[1][2] = {{0, (int *)&a.f}};
static unsigned int d;

int 
main ()
{
  for (; d < 1; d++)
    for (; b < 1; b++)
      *c[b][d + 1] = 0;

  return 0;
}
"
"/* PR c/47809 */
/* { dg-do compile } */
/* { dg-options ""-O2 -msse2"" } */

#include <emmintrin.h>
double bar (double, double);

__m128d
foo (__m128d x)
{
  x *= (__m128d) { bar (1.0, 1.0), 0.0 };
  return (__m128d) ((__m128i) x ^ (__m128i) { 0, 0});
}
","/* PR c/47809 */
/* { dg-do compile } */
/* { dg-options ""-O2 -msse2"" } */

#include <emmintrin.h>
double bar (double, double);

__m128d
foo (__m128d x)
{
  x *= (__m128d) { bar (1.0, 1.0), 0.0 };
  return (__m128d) ((__m128i) x ^ (__m128i) { 0, 0});
}
"
"/* { dg-do compile } */
/* { dg-options ""-fstrict-overflow -O2 -Wstrict-overflow=2"" } */

/* Source: Ian Lance Taylor.  Based on strict-overflow-3.c.  */

/* We can only simplify the conditional when using strict overflow
   semantics.  */

int
foo (int i, int j)
{
  return i + 100 < j + 1000;
}
","/* { dg-do compile } */
/* { dg-options ""-fstrict-overflow -O2 -Wstrict-overflow=2"" } */

/* Source: Ian Lance Taylor.  Based on strict-overflow-3.c.  */

/* We can only simplify the conditional when using strict overflow
   semantics.  */

int
foo (int i, int j)
{
  return i + 100 < j + 1000;
}
"
"/* { dg-do compile } */
/* { dg-csky-options ""-mcpu=ck801 -O1"" } */

/* Make sure that constant pools are emitted by the compiler for ck801.
   If this is deferred to the assembler, the compiler will compute
   incorrect branch offsets.  */

void f (unsigned int *u, long long int *l, float *f, double *d)
{
  *u = 0xdeadbeef;
  *l = 0xcafef00dc0ffeeULL;
  *f = 3.14159F;
  *d = 2.718281828459;
}

/* { dg-final { scan-assembler-times ""\\.long"" 6 } } */
","/* { dg-do compile } */
/* { dg-csky-options ""-mcpu=ck801 -O1"" } */

/* Make sure that constant pools are emitted by the compiler for ck801.
   If this is deferred to the assembler, the compiler will compute
   incorrect branch offsets.  */

void f (unsigned int *u, long long int *l, float *f, double *d)
{
  *u = 0xdeadbeef;
  *l = 0xcafef00dc0ffeeULL;
  *f = 3.14159F;
  *d = 2.718281828459;
}

/* { dg-final { scan-assembler-times ""\\.long"" 6 } } */
"
"/* { dg-do compile { target { ! ia32 } } } */
/* { dg-options ""-O2 -mfsgsbase"" } */
/* { dg-final { scan-assembler ""rdfsbase\[ \t]+(%|)eax"" } } */

#include <immintrin.h>

unsigned int
read_fs_base32 (void)
{
  return _readfsbase_u32 ();
}
","/* { dg-do compile { target { ! ia32 } } } */
/* { dg-options ""-O2 -mfsgsbase"" } */
/* { dg-final { scan-assembler ""rdfsbase\[ \t]+(%|)eax"" } } */

#include <immintrin.h>

unsigned int
read_fs_base32 (void)
{
  return _readfsbase_u32 ();
}
"
"/* { dg-do compile } */

void *memmove ();

void *
bar ()
{
  return memmove ();
}
","/* { dg-do compile } */

void *memmove ();

void *
bar ()
{
  return memmove ();
}
"
"/* PR rtl-optimization/79388 */
/* { dg-additional-options ""-fno-tree-coalesce-vars"" } */

unsigned int a, c;

__attribute__ ((noinline, noclone)) unsigned int
foo (unsigned int p)
{
  p |= 1;
  p &= 0xfffe;
  p %= 0xffff;
  c = p;
  return a + p;
}

int
main (void)
{
  int x = foo (6);
  if (x != 6)
    __builtin_abort();
  return 0;
}
","/* PR rtl-optimization/79388 */
/* { dg-additional-options ""-fno-tree-coalesce-vars"" } */

unsigned int a, c;

__attribute__ ((noinline, noclone)) unsigned int
foo (unsigned int p)
{
  p |= 1;
  p &= 0xfffe;
  p %= 0xffff;
  c = p;
  return a + p;
}

int
main (void)
{
  int x = foo (6);
  if (x != 6)
    __builtin_abort();
  return 0;
}
"
"/* { dg-require-effective-target vect_int } */

#include <stdarg.h>
#include ""tree-vect.h""

#define N 16

struct foostr {
  _Complex short f1;
  _Complex short f2;
};

_Complex short a1[64] __attribute__ ((__aligned__(__BIGGEST_ALIGNMENT__)));
_Complex short a2[64] __attribute__ ((__aligned__(__BIGGEST_ALIGNMENT__)));
_Complex short b1[64] __attribute__ ((__aligned__(__BIGGEST_ALIGNMENT__)));
_Complex short b2[64] __attribute__ ((__aligned__(__BIGGEST_ALIGNMENT__)));
struct foostr c[64] __attribute__ ((__aligned__(__BIGGEST_ALIGNMENT__)));

__attribute__ ((noinline)) void
foo (void)
{
  int i;

  for (i = 0; i < N; i++)
    {
      c[i].f1 = a1[i] + b1[i];
      c[i].f2 = a2[i] + b2[i];
    }

}

int
main (void)
{ 
  int i;
  check_vect ();
  
  foo ();

  return 0;
}

/* { dg-final { scan-tree-dump-times ""vectorizing stmts using SLP"" 0 ""vect"" } } */
","/* { dg-require-effective-target vect_int } */

#include <stdarg.h>
#include ""tree-vect.h""

#define N 16

struct foostr {
  _Complex short f1;
  _Complex short f2;
};

_Complex short a1[64] __attribute__ ((__aligned__(__BIGGEST_ALIGNMENT__)));
_Complex short a2[64] __attribute__ ((__aligned__(__BIGGEST_ALIGNMENT__)));
_Complex short b1[64] __attribute__ ((__aligned__(__BIGGEST_ALIGNMENT__)));
_Complex short b2[64] __attribute__ ((__aligned__(__BIGGEST_ALIGNMENT__)));
struct foostr c[64] __attribute__ ((__aligned__(__BIGGEST_ALIGNMENT__)));

__attribute__ ((noinline)) void
foo (void)
{
  int i;

  for (i = 0; i < N; i++)
    {
      c[i].f1 = a1[i] + b1[i];
      c[i].f2 = a2[i] + b2[i];
    }

}

int
main (void)
{ 
  int i;
  check_vect ();
  
  foo ();

  return 0;
}

/* { dg-final { scan-tree-dump-times ""vectorizing stmts using SLP"" 0 ""vect"" } } */
"
"/* PR rtl-optimization/81423 */

extern void abort (void);

unsigned long long int ll = 0;
unsigned long long int ull1 = 1ULL;
unsigned long long int ull2 = 12008284144813806346ULL;
unsigned long long int ull3;

unsigned long long int __attribute__ ((noinline))
foo (void)
{
  ll = -5597998501375493990LL;

  ll = (unsigned int) (5677365550390624949LL - ll) - (ull1 > 0);
  unsigned long long int ull3;
  ull3 = (unsigned int)
    (2067854353LL <<
     (((ll + -2129105131LL) ^ 10280750144413668236ULL) -
      10280750143997242009ULL)) >> ((2873442921854271231ULL | ull2)
				    - 12098357307243495419ULL);

  return ull3;
}

int
main (void)
{
  /* We need a long long of exactly 64 bits and int of exactly 32 bits
     for this test.  */
  if (__SIZEOF_LONG_LONG__ * __CHAR_BIT__ != 64
      || __SIZEOF_INT__ * __CHAR_BIT__ != 32)
    return 0;

  ull3 = foo ();
  if (ull3 != 3998784)
    abort ();
  return 0;
}
","/* PR rtl-optimization/81423 */

extern void abort (void);

unsigned long long int ll = 0;
unsigned long long int ull1 = 1ULL;
unsigned long long int ull2 = 12008284144813806346ULL;
unsigned long long int ull3;

unsigned long long int __attribute__ ((noinline))
foo (void)
{
  ll = -5597998501375493990LL;

  ll = (unsigned int) (5677365550390624949LL - ll) - (ull1 > 0);
  unsigned long long int ull3;
  ull3 = (unsigned int)
    (2067854353LL <<
     (((ll + -2129105131LL) ^ 10280750144413668236ULL) -
      10280750143997242009ULL)) >> ((2873442921854271231ULL | ull2)
				    - 12098357307243495419ULL);

  return ull3;
}

int
main (void)
{
  /* We need a long long of exactly 64 bits and int of exactly 32 bits
     for this test.  */
  if (__SIZEOF_LONG_LONG__ * __CHAR_BIT__ != 64
      || __SIZEOF_INT__ * __CHAR_BIT__ != 32)
    return 0;

  ull3 = foo ();
  if (ull3 != 3998784)
    abort ();
  return 0;
}
"
"/* { dg-do compile } */
/* { dg-options ""-O2 --param max-fields-for-field-sensitive=2 -fdump-tree-alias"" } */

struct Foo {
  int *p, *q;
};

int *foo (int ***x) __attribute__((pure));

int bar (int b)
{
  int i;
  struct Foo f;
  int *p, **q;
  p = &i;
  f.p = &i;
  f.q = f.p;
  if (b)
    q = &f.p;
  else
    q = &f.q;
  return *foo (&q);
}

/* { dg-final { scan-tree-dump ""CALLUSED\\(\[0-9\]+\\) = { ESCAPED NONLOCAL f.* i q }"" ""alias"" } } */

","/* { dg-do compile } */
/* { dg-options ""-O2 --param max-fields-for-field-sensitive=2 -fdump-tree-alias"" } */

struct Foo {
  int *p, *q;
};

int *foo (int ***x) __attribute__((pure));

int bar (int b)
{
  int i;
  struct Foo f;
  int *p, **q;
  p = &i;
  f.p = &i;
  f.q = f.p;
  if (b)
    q = &f.p;
  else
    q = &f.q;
  return *foo (&q);
}

/* { dg-final { scan-tree-dump ""CALLUSED\\(\[0-9\]+\\) = { ESCAPED NONLOCAL f.* i q }"" ""alias"" } } */

"
"/* { dg-do run } */
/* { dg-options ""-fno-toplevel-reorder"" } */
/* { dg-require-effective-target int32plus } */

extern void abort (void);

struct S
{
  signed a : 26;
  signed b : 16;
  signed c : 10;
  volatile signed d : 14;
};

static struct S e = { 0, 0, 0, 1 };
static int f = 1;

void __attribute__((noinline))
foo (void)
{
  e.d = 0;
  f = 2;
}

int
main ()
{
  if (e.a || e.b || e.c || e.d != 1 || f != 1)
    abort ();
  foo ();
  if (e.a || e.b || e.c || e.d || f != 2)
    abort ();
  return 0;
}
","/* { dg-do run } */
/* { dg-options ""-fno-toplevel-reorder"" } */
/* { dg-require-effective-target int32plus } */

extern void abort (void);

struct S
{
  signed a : 26;
  signed b : 16;
  signed c : 10;
  volatile signed d : 14;
};

static struct S e = { 0, 0, 0, 1 };
static int f = 1;

void __attribute__((noinline))
foo (void)
{
  e.d = 0;
  f = 2;
}

int
main ()
{
  if (e.a || e.b || e.c || e.d != 1 || f != 1)
    abort ();
  foo ();
  if (e.a || e.b || e.c || e.d || f != 2)
    abort ();
  return 0;
}
"
"/* { dg-do compile } */
/* { dg-require-effective-target lp64 } */
/* { dg-options ""-msse4 -mcmodel=large"" } */

typedef int V __attribute__((vector_size(16)));

void
foo (V *p, V *mask)
{
  *p = __builtin_shuffle (*p, *mask);
}
","/* { dg-do compile } */
/* { dg-require-effective-target lp64 } */
/* { dg-options ""-msse4 -mcmodel=large"" } */

typedef int V __attribute__((vector_size(16)));

void
foo (V *p, V *mask)
{
  *p = __builtin_shuffle (*p, *mask);
}
"
"/* { dg-do compile } */
/* { dg-options ""-mavx2 -O2"" } */
/* { dg-final { scan-assembler ""vpcmpeqd\[ \\t\]+\[^\n\]*%ymm\[0-9\]"" } } */

#include <immintrin.h>

volatile __m256i x;

void extern
avx2_test (void)
{
  x = _mm256_cmpeq_epi32 (x, x);
}
","/* { dg-do compile } */
/* { dg-options ""-mavx2 -O2"" } */
/* { dg-final { scan-assembler ""vpcmpeqd\[ \\t\]+\[^\n\]*%ymm\[0-9\]"" } } */

#include <immintrin.h>

volatile __m256i x;

void extern
avx2_test (void)
{
  x = _mm256_cmpeq_epi32 (x, x);
}
"
"typedef struct {
  char y;
  char x[32];
} X;

int z (void)
{
  X xxx;
  xxx.x[0] =
  xxx.x[31] = '0';
  xxx.y = 0xf;
  return f (xxx, xxx);
}

int main (void)
{
  int val;

  val = z ();
  if (val != 0x60)
    abort ();
  exit (0);
}

int f(X x, X y)
{
  if (x.y != y.y)
    return 'F';

  return x.x[0] + y.x[0];
}

","typedef struct {
  char y;
  char x[32];
} X;

int z (void)
{
  X xxx;
  xxx.x[0] =
  xxx.x[31] = '0';
  xxx.y = 0xf;
  return f (xxx, xxx);
}

int main (void)
{
  int val;

  val = z ();
  if (val != 0x60)
    abort ();
  exit (0);
}

int f(X x, X y)
{
  if (x.y != y.y)
    return 'F';

  return x.x[0] + y.x[0];
}

"
"/* { dg-do compile } */
/* { dg-options ""-mavx512f -O2"" } */
/* { dg-final { scan-assembler-times ""vpord\[ \\t\]+\[^\{\n\]*%zmm\[0-9\]+(?:\n|\[ \\t\]+#)""  2 } } */
/* { dg-final { scan-assembler-times ""vpord\[ \\t\]+\[^\{\n\]*%zmm\[0-9\]+\{%k\[1-7\]\}(?:\n|\[ \\t\]+#)"" 1 } } */
/* { dg-final { scan-assembler-times ""vpord\[ \\t\]+\[^\{\n\]*%zmm\[0-9\]+\{%k\[1-7\]\}\{z\}(?:\n|\[ \\t\]+#)"" 1 } } */

#include <immintrin.h>

volatile __m512i x;
volatile __mmask16 m;

void extern
avx512f_test (void)
{
  x = _mm512_or_si512 (x, x);
  x = _mm512_or_epi32 (x, x);
  x = _mm512_mask_or_epi32 (x, m, x, x);
  x = _mm512_maskz_or_epi32 (m, x, x);
}
","/* { dg-do compile } */
/* { dg-options ""-mavx512f -O2"" } */
/* { dg-final { scan-assembler-times ""vpord\[ \\t\]+\[^\{\n\]*%zmm\[0-9\]+(?:\n|\[ \\t\]+#)""  2 } } */
/* { dg-final { scan-assembler-times ""vpord\[ \\t\]+\[^\{\n\]*%zmm\[0-9\]+\{%k\[1-7\]\}(?:\n|\[ \\t\]+#)"" 1 } } */
/* { dg-final { scan-assembler-times ""vpord\[ \\t\]+\[^\{\n\]*%zmm\[0-9\]+\{%k\[1-7\]\}\{z\}(?:\n|\[ \\t\]+#)"" 1 } } */

#include <immintrin.h>

volatile __m512i x;
volatile __mmask16 m;

void extern
avx512f_test (void)
{
  x = _mm512_or_si512 (x, x);
  x = _mm512_or_epi32 (x, x);
  x = _mm512_mask_or_epi32 (x, m, x, x);
  x = _mm512_maskz_or_epi32 (m, x, x);
}
"
"/* { dg-do run } */
/* { dg-options ""-O2 -mavx2"" } */
/* { dg-require-effective-target avx2 } */

#include ""avx2-check.h""

#define main() do_main ()

#include ""../../gcc.dg/pr64252.c""

static void
avx2_test (void)
{
  do_main ();
}
","/* { dg-do run } */
/* { dg-options ""-O2 -mavx2"" } */
/* { dg-require-effective-target avx2 } */

#include ""avx2-check.h""

#define main() do_main ()

#include ""../../gcc.dg/pr64252.c""

static void
avx2_test (void)
{
  do_main ();
}
"
"/* { dg-require-effective-target vect_int } */

#include <stdarg.h>
#include ""tree-vect.h""

#define N 16
int resultY[N] = {12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27};
int resultZ[N] = {13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28};
int X[N] = {10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25};
int Y[N] = {};
int Z[N] = {};
 
__attribute__ ((noinline)) void
foo (int *in, int *out1, int *out2)
{
  int i;

  for (i = 0; i < N; i++)
    {
      out1[i] = in[i] + 2;
      out2[i] = in[i] + 3;
    }
}

int
main (void)
{ 
  int i;

  check_vect ();

  foo (X, Y, Z);
  
  /* check results:  */
  for (i = 0; i < N; i++)
    {
      if (Y[i] != resultY[i])
	abort ();

      if (Z[i] != resultZ[i])
	abort ();
    }
  return 0;
} 

/* { dg-final { scan-tree-dump-times ""vectorized 1 loops"" 1 ""vect"" } } */
","/* { dg-require-effective-target vect_int } */

#include <stdarg.h>
#include ""tree-vect.h""

#define N 16
int resultY[N] = {12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27};
int resultZ[N] = {13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28};
int X[N] = {10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25};
int Y[N] = {};
int Z[N] = {};
 
__attribute__ ((noinline)) void
foo (int *in, int *out1, int *out2)
{
  int i;

  for (i = 0; i < N; i++)
    {
      out1[i] = in[i] + 2;
      out2[i] = in[i] + 3;
    }
}

int
main (void)
{ 
  int i;

  check_vect ();

  foo (X, Y, Z);
  
  /* check results:  */
  for (i = 0; i < N; i++)
    {
      if (Y[i] != resultY[i])
	abort ();

      if (Z[i] != resultZ[i])
	abort ();
    }
  return 0;
} 

/* { dg-final { scan-tree-dump-times ""vectorized 1 loops"" 1 ""vect"" } } */
"
"/* PR target/59501 */
/* { dg-do run } */
/* { dg-options ""-O2 -mavx -mno-accumulate-outgoing-args"" } */
/* { dg-require-effective-target avx } */

#define CHECK_H ""avx-check.h""
#define TEST avx_test

#include CHECK_H

typedef double V __attribute__ ((vector_size (32)));

__attribute__((noinline, noclone)) V
foo (double *x, int a, int b, int c, int d, int e, int f, unsigned *y)
{
  V r = { x[y[0]], x[y[1]], x[y[2]], x[y[3]] };
  return r;
}

static void
TEST (void)
{
  double a[16];
  unsigned b[4] = { 5, 0, 15, 7 };
  int i;
  for (i = 0; i < 16; i++)
    a[i] = 0.5 + i;
  V v = foo (a, 0, 0, 0, 0, 0, 0, b);
  if (v[0] != 5.5 || v[1] != 0.5 || v[2] != 15.5 || v[3] != 7.5)
    __builtin_abort ();
}
","/* PR target/59501 */
/* { dg-do run } */
/* { dg-options ""-O2 -mavx -mno-accumulate-outgoing-args"" } */
/* { dg-require-effective-target avx } */

#define CHECK_H ""avx-check.h""
#define TEST avx_test

#include CHECK_H

typedef double V __attribute__ ((vector_size (32)));

__attribute__((noinline, noclone)) V
foo (double *x, int a, int b, int c, int d, int e, int f, unsigned *y)
{
  V r = { x[y[0]], x[y[1]], x[y[2]], x[y[3]] };
  return r;
}

static void
TEST (void)
{
  double a[16];
  unsigned b[4] = { 5, 0, 15, 7 };
  int i;
  for (i = 0; i < 16; i++)
    a[i] = 0.5 + i;
  V v = foo (a, 0, 0, 0, 0, 0, 0, b);
  if (v[0] != 5.5 || v[1] != 0.5 || v[2] != 15.5 || v[3] != 7.5)
    __builtin_abort ();
}
"
"/* { dg-do compile } */
/* { dg-options ""-O2 -mavx512vl"" } */
/* { dg-final { scan-assembler-times ""vcvtps2ph\[ \\t\]+\[^\{\n\]*%ymm\[0-9\]+\[^\n\]*%xmm\[0-9\]+\{%k\[1-7\]\}(?:\n|\[ \\t\]+#)""  1 } } */
/* { dg-final { scan-assembler-times ""vcvtps2ph\[ \\t\]+\[^\{\n\]*%ymm\[0-9\]+\[^\n\]*%xmm\[0-9\]+\{%k\[1-7\]\}\{z\}(?:\n|\[ \\t\]+#)""  1 } } */
/* { dg-final { scan-assembler-times ""vcvtps2ph\[ \\t\]+\[^\{\n\]*%xmm\[0-9\]\[^\n\]*%xmm\[0-9\]+\{%k\[1-7\]\}(?:\n|\[ \\t\]+#)""  1 } } */
/* { dg-final { scan-assembler-times ""vcvtps2ph\[ \\t\]+\[^\{\n\]*%xmm\[0-9\]\[^\n\]*%xmm\[0-9\]+\{%k\[1-7\]\}\{z\}(?:\n|\[ \\t\]+#)""  1 } } */

#include <immintrin.h>

volatile __m256 x;
volatile __m128i y;
volatile __m128 xx;
volatile __m128i yy;

void extern
avx512bw_test (void)
{
  y = _mm256_maskz_cvtps_ph (4, x, 0);
  y = _mm256_mask_cvtps_ph (y, 2, x, 0);
  yy = _mm_maskz_cvtps_ph (4, xx, 0);
  yy = _mm_mask_cvtps_ph (yy, 2, xx, 0);
}
","/* { dg-do compile } */
/* { dg-options ""-O2 -mavx512vl"" } */
/* { dg-final { scan-assembler-times ""vcvtps2ph\[ \\t\]+\[^\{\n\]*%ymm\[0-9\]+\[^\n\]*%xmm\[0-9\]+\{%k\[1-7\]\}(?:\n|\[ \\t\]+#)""  1 } } */
/* { dg-final { scan-assembler-times ""vcvtps2ph\[ \\t\]+\[^\{\n\]*%ymm\[0-9\]+\[^\n\]*%xmm\[0-9\]+\{%k\[1-7\]\}\{z\}(?:\n|\[ \\t\]+#)""  1 } } */
/* { dg-final { scan-assembler-times ""vcvtps2ph\[ \\t\]+\[^\{\n\]*%xmm\[0-9\]\[^\n\]*%xmm\[0-9\]+\{%k\[1-7\]\}(?:\n|\[ \\t\]+#)""  1 } } */
/* { dg-final { scan-assembler-times ""vcvtps2ph\[ \\t\]+\[^\{\n\]*%xmm\[0-9\]\[^\n\]*%xmm\[0-9\]+\{%k\[1-7\]\}\{z\}(?:\n|\[ \\t\]+#)""  1 } } */

#include <immintrin.h>

volatile __m256 x;
volatile __m128i y;
volatile __m128 xx;
volatile __m128i yy;

void extern
avx512bw_test (void)
{
  y = _mm256_maskz_cvtps_ph (4, x, 0);
  y = _mm256_mask_cvtps_ph (y, 2, x, 0);
  yy = _mm_maskz_cvtps_ph (4, xx, 0);
  yy = _mm_mask_cvtps_ph (yy, 2, xx, 0);
}
"
"/* PR tree-optimization/58164 */
/* { dg-require-effective-target indirect_jumps } */

int
foo (void)
{
  int x = 0;
  goto *&x;
}
","/* PR tree-optimization/58164 */
/* { dg-require-effective-target indirect_jumps } */

int
foo (void)
{
  int x = 0;
  goto *&x;
}
"
"/* Test for constraints on return statements.  */
/* Origin: Joseph Myers <jsm28@cam.ac.uk> */
/* { dg-do compile } */
/* { dg-options ""-std=iso9899:1990 -pedantic-errors"" } */

int
foo (void)
{
  return;
}

void
bar (void)
{
  return 1; /* { dg-bogus ""warning"" ""warning in place of error"" } */
  /* { dg-error ""with a value"" ""return constraint violation"" { target *-*-* } .-1 } */
}
","/* Test for constraints on return statements.  */
/* Origin: Joseph Myers <jsm28@cam.ac.uk> */
/* { dg-do compile } */
/* { dg-options ""-std=iso9899:1990 -pedantic-errors"" } */

int
foo (void)
{
  return;
}

void
bar (void)
{
  return 1; /* { dg-bogus ""warning"" ""warning in place of error"" } */
  /* { dg-error ""with a value"" ""return constraint violation"" { target *-*-* } .-1 } */
}
"
